{"version":3,
 "file":"_build/top/app.js",
 "sourceRoot":"",
 "names":
 ["absolutePath",
  "failwith",
  "s",
  "invalid_arg",
  "min",
  "x",
  "y",
  "abs",
  "_b_",
  "s1",
  "s2",
  "l1",
  "l2",
  "_c_",
  "tl",
  "hd",
  "stdout",
  "flush_all",
  "iter",
  "l",
  "a",
  "output_string",
  "oc",
  "print_endline",
  "do_at_exit",
  "a1",
  "ofs1",
  "a2",
  "ofs2",
  "len",
  "f",
  "r",
  "i",
  "tolist",
  "res",
  "i$0",
  "res$0",
  "res$1",
  "i$1",
  "n",
  "nth_aux",
  "l$0",
  "n$0",
  "l$1",
  "n$1",
  "l1$0",
  "l2$0",
  "l2$1",
  "accu",
  "accu$0",
  "accu$1",
  "l1$1",
  "b",
  "p",
  "find",
  "h",
  "d",
  "hl",
  "hr",
  "h$0",
  "lr",
  "ld",
  "lv",
  "ll",
  "lrr",
  "lrd",
  "lrv",
  "lrl",
  "rr",
  "rd",
  "rv",
  "rl",
  "rlr",
  "rld",
  "rlv",
  "rll",
  "data",
  "v",
  "c",
  "param$1",
  "r$0",
  "t",
  "match",
  "d$0",
  "m",
  "m$0",
  "k",
  "rh",
  "lh",
  "t1",
  "t2",
  "pres",
  "pres$0",
  "h1",
  "r1",
  "d1",
  "v1",
  "r2",
  "d2",
  "r2$0",
  "d2$0",
  "v2",
  "r1$0",
  "d1$0",
  "pvd",
  "lf",
  "lt",
  "rf",
  "rt",
  "e",
  "e$0",
  "e$1",
  "cmp",
  "m1",
  "m2",
  "compare_aux",
  "e1",
  "e2",
  "e1$0",
  "e2$0",
  "e2$1",
  "e1$1",
  "c$0",
  "e2$2",
  "e1$2",
  "equal_aux",
  "printers",
  "register_printer",
  "fn",
  "name",
  "exn",
  "slot",
  "initial_object_size",
  "public_method_label",
  "tag",
  "table_count",
  "pub_labels",
  "methods",
  "array",
  "new_size",
  "old_size",
  "new_buck",
  "label",
  "element",
  "table",
  "index",
  "names",
  "arr",
  "vars",
  "virt_meths",
  "concr_meths",
  "vars$0",
  "virt_meths$0",
  "concr_meths$0",
  "virt_meth_labs",
  "concr_meth_labs",
  "lab",
  "info",
  "tvars",
  "by_name",
  "by_label",
  "met",
  "hm",
  "saved_vars",
  "saved_hidden_meths",
  "meths",
  "vals",
  "meths$0",
  "nmeths",
  "nvals",
  "public_methods",
  "tags",
  "cla",
  "top",
  "env",
  "super$0",
  "init",
  "nm",
  "pub_meths",
  "class_init",
  "init_table",
  "env_init",
  "obj_0",
  "obj",
  "inits",
  "keys",
  "tables",
  "key",
  "lookup_key",
  "tables$0",
  "next",
  "tables$1",
  "root",
  "clo",
  "n$2",
  "x$0",
  "f$0",
  "n$3",
  "f$1",
  "n$4",
  "f$2",
  "n$5",
  "f$3",
  "x$1",
  "f$4",
  "x$2",
  "n$6",
  "f$5",
  "x$3",
  "n$7",
  "f$6",
  "x$4",
  "n$8",
  "f$7",
  "n$9",
  "x$5",
  "f$8",
  "e$2",
  "n$10",
  "x$6",
  "f$9",
  "n$11",
  "x$7",
  "n$12",
  "x$8",
  "n$13",
  "n$14",
  "e$3",
  "n$15",
  "m$1",
  "m$2",
  "x$9",
  "m$3",
  "n$16",
  "m$4",
  "e$4",
  "n$17",
  "m$5",
  "n$18",
  "jsoo_self",
  "str",
  "evtType",
  "evt",
  "cb",
  "self_1",
  "self_3",
  "uri",
  "self_4",
  "innerCb",
  "self_5",
  "startTime",
  "animName",
  "loop",
  "randomInt",
  "from",
  "too",
  "duration",
  "self_6",
  "child",
  "self_7",
  "opt",
  "sth",
  "sth$0",
  "sth$1",
  "width",
  "height",
  "param",
  "self_8",
  "renderTexture",
  "sprite",
  "container",
  "stage",
  "renderedStr",
  "self_9",
  "loader",
  "prevInner",
  "prevInner$0",
  "prevInner$1",
  "o",
  "io",
  "jsoo_32b5ee21",
  "jsoo_res",
  "createDudeSprite",
  "dude",
  "dudeTexture",
  "renderer",
  "scale",
  "textureButton",
  "dudeSprite",
  "gridCells",
  "otherDudes",
  "otherDudesSprites",
  "onButtonDown",
  "this$0",
  "centerY",
  "centerX",
  "dudeY",
  "dudeX",
  "dy",
  "dx",
  "everythingElseStage",
  "j",
  "tile",
  "packet",
  "typ",
  "pos",
  "id",
  "value",
  "theDude",
  "animate",
  "express",
  "app",
  "http",
  "req",
  "socketio",
  "socket",
  "otherDude",
  "isServer"],
 "mappings":
 "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",
 "sources":
 ["/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/fs.js",
  "/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/unix.js",
  "/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/mlString.js",
  "/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/stdlib.js",
  "/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/int64.js",
  "/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/ieee_754.js",
  "/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/bigarray.js",
  "/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/bigstring.js",
  "/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/jslib.js",
  "/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/marshal.js",
  "/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/jslib_js_of_ocaml.js",
  "/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/io.js",
  "/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/gc.js",
  "/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/parsing.js",
  "/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/internalMod.js",
  "/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/lexing.js",
  "/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/polyfill/json2.js",
  "/Users/sansouci/.opam/4.02.3/lib/js_of_ocaml/md5.js",
  "/Users/sansouci/Desktop/tapknight/src/server.re",
  "/Users/sansouci/.opam/4.02.3/lib/ocaml/pervasives.ml",
  "/Users/sansouci/.opam/4.02.3/lib/ocaml/array.ml",
  "/Users/sansouci/.opam/4.02.3/lib/ocaml/list.ml",
  "/Users/sansouci/.opam/4.02.3/lib/ocaml/sys.ml",
  "/Users/sansouci/.opam/4.02.3/lib/ocaml/map.ml",
  "/Users/sansouci/.opam/4.02.3/lib/ocaml/printexc.ml",
  "/Users/sansouci/.opam/4.02.3/lib/ocaml/callback.ml",
  "/Users/sansouci/.opam/4.02.3/lib/ocaml/camlinternalOO.ml",
  "/Users/sansouci/.opam/4.02.3/lib/ocaml/camlinternalFormatBasics.ml",
  "/Users/sansouci/Desktop/tapknight/src/nodejs.re",
  "/Users/sansouci/Desktop/tapknight/node_modules/repixi/src/repixi.re",
  "/Users/sansouci/Desktop/tapknight/src/helpers.re",
  "/Users/sansouci/Desktop/tapknight/src/clientsocket.re",
  "/Users/sansouci/Desktop/tapknight/src/client.re",
  "/Users/sansouci/Desktop/tapknight/src/index.re",
  "/Users/sansouci/.opam/4.02.3/lib/ocaml/std_exit.ml"],
 "sourcesContent":
 ["// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Dummy filesystem\n\n//Provides: caml_current_dir\nvar caml_current_dir = \"/\";\n//Provides: file_inode\nvar file_inode = 0\n\n//Provides: MlDir\n//Requires: file_inode, unix_time\nfunction MlDir(){ this.content={};\n                  this.inode = file_inode++;\n                  var now = unix_time();\n                  this.atime = now;\n                  this.mtime = now;\n                  this.ctime = now;\n                  }\nMlDir.prototype = {\n  exists:function(name){return this.content[name]?1:0;},\n  mk:function(name,c){this.content[name]=c},\n  get:function(name){return this.content[name]},\n  list:function(){\n    var a = [];\n    for(var n in this.content)\n      a.push(n);\n    return a;\n  },\n  remove:function(name){delete this.content[name];}\n}\n\n//Provides: MlFile\n//Requires: caml_create_string, file_inode, unix_time\nfunction MlFile(content){ this.data = content;\n                          this.inode = file_inode++;\n                          var now = unix_time();\n                          this.atime = now;\n                          this.mtime = now;\n                          this.ctime = now;\n}\nMlFile.prototype = {\n  truncate:function(){\n    this.data = caml_create_string(0);\n    this.modified();\n  },\n  modified:function() {\n    var now = unix_time();\n    this.atime = now;\n    this.mtime = now;\n  }\n}\n\n//Provides: caml_root_dir\n//Requires: MlDir\nvar caml_root_dir = new MlDir();\ncaml_root_dir.mk(\"\",new MlDir());\n\n//Provides: caml_sys_getcwd\n//Requires: caml_current_dir, caml_new_string\nfunction caml_sys_getcwd() { return caml_new_string(caml_current_dir); }\n//Provides: caml_sys_chdir\n//Requires: caml_current_dir, caml_make_path\n//Requires: caml_sys_file_exists, caml_sys_is_directory,caml_raise_no_such_file\nfunction caml_sys_chdir(dir) {\n  if(caml_sys_file_exists(dir) && caml_sys_is_directory(dir)){\n    var name = caml_make_path(dir);\n    name.push(\"\"); // we want the slash a the end\n    caml_current_dir = name.join(\"/\");\n    return 0;\n  }\n  else\n    caml_raise_no_such_file(dir);\n}\n//Provides: caml_raise_no_such_file\n//Requires: MlString, caml_raise_sys_error\nfunction caml_raise_no_such_file(name){\n  name = (name instanceof MlString)?name.toString():name;\n  caml_raise_sys_error (name + \": No such file or directory\");\n}\n\n//Provides: caml_raise_not_a_dir\n//Requires: MlString, caml_raise_sys_error\nfunction caml_raise_not_a_dir(name){\n  name = (name instanceof MlString)?name.toString():name;\n  caml_raise_sys_error (name + \": Not a directory\");\n}\n\n//Provides: caml_make_path\n//Requires: caml_current_dir,MlString\nfunction caml_make_path (name) {\n  name=(name instanceof MlString)?name.toString():name;\n  if(name.charCodeAt(0) != 47)\n    name = caml_current_dir + name;\n  var comp = name.split(\"/\");\n  var ncomp = []\n  for(var i = 0; i<comp.length; i++){\n    switch(comp[i]){\n    case \"..\": if(ncomp.length>1) ncomp.pop(); break;\n    case \".\": break;\n    case \"\": if(ncomp.length == 0) ncomp.push(\"\"); break;\n    default: ncomp.push(comp[i]);break\n    }\n  }\n  ncomp.orig = name;\n  return ncomp;\n\n}\n\n\n//Provides: caml_fs_register\n//Requires: MlDir, MlFile, caml_root_dir, caml_make_path, caml_raise_sys_error\n//Requires: MlString, caml_array_of_string\n//Requires: caml_invalid_argument, caml_new_string\n//Requires: caml_string_of_array\n// content can be : MlDIr,MlFile,MlString,Array, string\nfunction caml_fs_register(name,content) {\n  var path = caml_make_path(name);\n  var dir = caml_root_dir;\n  for(var i=0;i<path.length-1;i++){\n    var d = path[i];\n    if(!(dir.exists(d)))\n      dir.mk(d,new MlDir());\n    dir = dir.get(d);\n    if(!(dir instanceof MlDir))\n      caml_raise_sys_error (path.orig + \" : file already exists\");\n  }\n  var d = path[path.length-1];\n  if(dir.exists(d)) caml_raise_sys_error (path.orig + \" : file already exists\");\n  if(content instanceof MlDir) dir.mk(d,content);\n  else if(content instanceof MlFile) dir.mk(d,content);\n  else if(content instanceof MlString) dir.mk(d,new MlFile(content));\n  else if(content instanceof Array) dir.mk(d,new MlFile(caml_string_of_array(content)));\n  else if(content.toString) {\n    var mlstring = caml_new_string(content.toString());\n    //caml_array_of_string(mlstring);\n    dir.mk(d,new MlFile(mlstring));\n  }\n  else caml_invalid_argument(\"caml_fs_register\");\n  return 0;\n}\n\n//Provides: caml_fs_update_inode\n//Requires: MlDir, caml_root_dir, caml_make_path, caml_raise_sys_error\n//Requires: MlString\n//Requires: caml_invalid_argument\nfunction caml_fs_update_inode(name,content) {\n  var path = caml_make_path(name);\n  var dir = caml_root_dir;\n  for(var i=0;i<path.length-1;i++){\n    var d = path[i];\n    if(!(dir.exists(d)))\n      dir.mk(d,new MlDir());\n    dir = dir.get(d);\n    if(!(dir instanceof MlDir))\n      caml_raise_sys_error (path.orig + \" : file does not exists\");\n  }\n  var d = path[path.length-1];\n  if(!dir.exists(d)) caml_raise_sys_error (path.orig + \" : file does not exists\");\n  if(content instanceof MlString) {\n    var inode = dir.get(d);\n    inode.data = content;\n  }\n  else caml_invalid_argument(\"caml_fs_update_inode\");\n  return 0;\n}\n\n//Provides: caml_fs_init\n//Requires: caml_fs_register\nfunction caml_fs_init (){\n  var tmp=joo_global_object.caml_fs_tmp\n  if(tmp){\n    for(var i = 0; i < tmp.length; i++){\n      caml_fs_register(tmp[i].name,tmp[i].content);\n    }\n  }\n  joo_global_object.caml_fs_register = caml_fs_register;\n  return 0;\n}\n\n//Provides: caml_fs_register_extern\nfunction caml_fs_register_extern(name,content){\n  if(joo_global_object.caml_fs_register)\n    joo_global_object.caml_fs_register(name,content);\n  else {\n    if(!joo_global_object.caml_fs_tmp) joo_global_object.caml_fs_tmp = [];\n    joo_global_object.caml_fs_tmp.push({name:name,content:content});\n  }\n  return 0;\n}\n\n//Provides: caml_fs_content\n//Requires: caml_root_dir, caml_raise_no_such_file\nfunction caml_fs_content(path){\n  var dir = caml_root_dir;\n  for(var i=0;i<path.length;i++){\n    if(!(dir.exists && dir.exists(path[i]))) caml_raise_no_such_file(path.orig);\n    dir=dir.get(path[i]);\n  }\n  return dir\n}\n\n//Provides: caml_sys_file_exists\n//Requires: caml_root_dir, caml_make_path\nfunction caml_sys_file_exists (name) {\n  var dir = caml_root_dir;\n  var path = caml_make_path(name);\n  var auto_load;\n  var pos;\n  for(var i=0;i<path.length;i++){\n    if(dir.auto) { auto_load = dir.auto; pos = i}\n    if(!(dir.exists && dir.exists(path[i]))) {\n      if(auto_load) {\n        return auto_load(path,pos);\n      }\n      else return 0;\n    }\n    dir=dir.get(path[i]);\n  }\n  return 1;\n}\n\n//Provides: caml_fs_register_autoload\n//Requires: MlDir, caml_make_path, caml_raise_sys_error, caml_root_dir\nfunction caml_fs_register_autoload(path,f){\n  var path = caml_make_path(path);\n  var dir = caml_root_dir;\n  for(var i=0;i<path.length;i++){\n    var d = path[i];\n    if(!(dir.exists(d)))\n      dir.mk(d,new MlDir());\n    dir = dir.get(d);\n    if(!(dir instanceof MlDir))\n      caml_raise_sys_error (path.orig + \" : not a directory\");\n  }\n  dir.auto = f;\n  return 0;\n}\n\n//Provides: caml_sys_read_directory\n//Requires: caml_new_string, MlDir\n//Requires: caml_fs_content, caml_make_path, caml_raise_not_a_dir\nfunction caml_sys_read_directory(name){\n  var dir = caml_fs_content(caml_make_path(name));\n  if(!(dir instanceof MlDir)){\n    caml_raise_not_a_dir(name);\n  }\n  var list = dir.list();\n  var l = new Array(list.length + 1);\n  l[0] = 0;\n  for(var i=0;i<list.length;i++)\n    l[i+1] = caml_new_string(list[i]);\n  return l;\n}\n\n//Provides: caml_sys_remove\n//Requires: caml_make_path, caml_fs_content, caml_raise_no_such_file\nfunction caml_sys_remove(name){\n  var path = caml_make_path(name);\n  var dir = caml_fs_content(path.slice(0,-1))\n  if(dir.exists(path[path.length-1]))\n    dir.remove(path[path.length-1]);\n  else caml_raise_no_such_file(name);\n  return 0;\n}\n\n//Provides: caml_sys_is_directory\n//Requires: caml_make_path, caml_fs_content, MlDir\nfunction caml_sys_is_directory(name){\n  var path = caml_make_path(name);\n  var dir = caml_fs_content(path);\n  return (dir instanceof MlDir)?1:0;\n}\n\n//Provides: caml_sys_rename\n//Requires: caml_fs_register,caml_sys_remove\n//Requires: caml_make_path,caml_fs_content\n//Requires: caml_sys_file_exists, caml_sys_is_directory, caml_raise_sys_error\nfunction caml_sys_rename(o,n){\n  var path = caml_make_path(o);\n  var content = caml_fs_content(path);\n  if(caml_sys_file_exists(n)){\n    if(caml_sys_is_directory(n)) caml_raise_sys_error(n.toString() + \" : is a directory\");\n    caml_sys_remove(n);\n  }\n  caml_fs_register(n, content);\n  caml_sys_remove(o);\n  return 0;\n}\n\n\n//Provides: caml_ba_map_file\n//Requires: caml_failwith\nfunction caml_ba_map_file(vfd, kind, layout, shared, dims, pos) {\n    // var data = caml_global_data.fds[vfd];\n    caml_failwith(\"caml_ba_map_file not Implemented\");\n}\n\n//Provides: caml_ba_map_file_bytecode\n//Requires: caml_ba_map_file\nfunction caml_ba_map_file_bytecode(argv,argn){\n  return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5]);\n}\n\n\n//Provides: unix_stat_file\n//Requires: caml_make_path, caml_fs_content, MlFile, MlDir,caml_ml_string_length\nfunction unix_stat_file(f){\n  if (f instanceof MlDir) {\n    var kind = 1; //S_DIR\n    var size = 0;\n  }\n  if (f instanceof MlFile) {\n    var kind = 0; //S_REG\n    var size = caml_ml_string_length(f.data);\n  }\n\n  return [0,\n   0, //st_dev\n   f.inode, // st_ino\n   kind, // st_kind\n   436, //st_perm 0o664\n   1, //st_nlink\n   1, //st_uid\n   1, //st_gid\n   0, //st_rdev\n   size,//st_size\n   +f.atime,\n   +f.mtime,\n   +f.ctime\n  ]\n}\n\n//Provides: unix_stat\n//Requires: caml_fs_content, caml_make_path, unix_stat_file\nfunction unix_stat(name){\n  var f = caml_fs_content(caml_make_path(name));\n  return unix_stat_file(f)\n}\n\n//Provides: unix_lstat\n//Requires: unix_stat\nvar unix_lstat = unix_stat\n\n//Provides: unix_fstat\n//Requires: unix_stat_file, caml_global_data\nfunction unix_fstat(idx){\n  return unix_stat_file(caml_global_data.fds[idx].file)\n}\n",
  "//Provides: unix_gettimeofday\nfunction unix_gettimeofday () {\n  return (new Date()).getTime() / 1000;\n}\n\n//Provides: unix_time\n//Requires: unix_gettimeofday\nfunction unix_time () {\n  return Math.floor(unix_gettimeofday ());\n}\n\n//Provides: unix_gmtime\nfunction unix_gmtime (t) {\n  var d = new Date (t * 1000);\n  var januaryfirst = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));\n  var doy = Math.floor((d - januaryfirst) / 86400000);\n  return [0, d.getUTCSeconds(), d.getUTCMinutes(), d.getUTCHours(),\n          d.getUTCDate(), d.getUTCMonth(), d.getUTCFullYear() - 1900,\n          d.getUTCDay(), doy,\n          false | 0 /* for UTC daylight savings time is false */]\n}\n\n//Provides: unix_localtime\nfunction unix_localtime (t) {\n  var d = new Date (t * 1000);\n  var januaryfirst = new Date(d.getFullYear(), 0, 1);\n  var doy = Math.floor((d - januaryfirst) / 86400000);\n  var jan = new Date(d.getFullYear(), 0, 1);\n  var jul = new Date(d.getFullYear(), 6, 1);\n  var stdTimezoneOffset = Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());\n  return [0, d.getSeconds(), d.getMinutes(), d.getHours(),\n  d.getDate(), d.getMonth(), d.getFullYear() - 1900,\n  d.getDay(), doy,\n  (d.getTimezoneOffset() < stdTimezoneOffset) | 0 /* daylight savings time  field. */]\n}\n\n//Provides: unix_mktime\n//Requires: unix_localtime\nfunction unix_mktime(tm){\n    var d = new Date(tm[6]+1900,tm[5],tm[4],tm[3],tm[2],tm[1]);\n    var t = Math.floor(d.getTime() / 1000);\n    var tm2 = unix_localtime(t);\n    return [0,t,tm2];\n}\n\n//Provides: win_startup const\nfunction win_startup() {}\n\n//Provides: win_cleanup const\nfunction win_cleanup() {}\n\n//Provides: win_handle_fd const\nfunction win_handle_fd(x) {return x;}\n",
  "// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010-2014 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n// An OCaml string is an object with three fields:\n// - tag 't'\n// - length 'l'\n// - contents 'c'\n//\n// The contents of the string can be either a JavaScript array or\n// a JavaScript string. The length of this string can be less than the\n// length of the OCaml string. In this case, remaining bytes are\n// assumed to be zeroes. Arrays are mutable but consumes more memory\n// than strings. A common pattern is to start from an empty string and\n// progressively fill it from the start. Partial strings makes it\n// possible to implement this efficiently.\n//\n// When converting to and from UTF-16, we keep track of whether the\n// string is composed only of ASCII characters (in which case, no\n// conversion needs to be performed) or not.\n//\n// The string tag can thus take the following values:\n//   full string     BYTE | UNKNOWN:      0\n//                   BYTE | ASCII:        9\n//                   BYTE | NOT_ASCII:    8\n//   string prefix   PARTIAL:             2\n//   array           ARRAY:               4\n//\n// One can use bit masking to discriminate these different cases:\n//   known_encoding(x) = x&8\n//   is_ascii(x) =       x&1\n//   kind(x) =           x&6\n\n//Provides: caml_str_repeat\nfunction caml_str_repeat(n, s) {\n  if (s.repeat) return s.repeat(n); // ECMAscript 6 and Firefox 24+\n  var r = \"\", l = 0;\n  if (n == 0) return r;\n  for(;;) {\n    if (n & 1) r += s;\n    n >>= 1;\n    if (n == 0) return r;\n    s += s;\n    l++;\n    if (l == 9) {\n      s.slice(0,1); // flatten the string\n      // then, the flattening of the whole string will be faster,\n      // as it will be composed of larger pieces\n    }\n  }\n}\n\n//Provides: caml_subarray_to_string\n//Requires: raw_array_sub\nfunction caml_subarray_to_string (a, i, len) {\n  var f = String.fromCharCode;\n  if (i == 0 && len <= 4096 && len == a.length) return f.apply (null, a);\n  var s = \"\";\n  for (; 0 < len; i += 1024,len-=1024)\n    s += f.apply (null, raw_array_sub(a,i, Math.min(len, 1024)));\n  return s;\n}\n\n//Provides: caml_utf8_of_utf16\nfunction caml_utf8_of_utf16(s) {\n  for (var b = \"\", t = b, c, d, i = 0, l = s.length; i < l; i++) {\n    c = s.charCodeAt(i);\n    if (c < 0x80) {\n      for (var j = i + 1; (j < l) && (c = s.charCodeAt(j)) < 0x80; j++);\n      if (j - i > 512) { t.substr(0, 1); b += t; t = \"\"; b += s.slice(i, j) }\n      else t += s.slice(i, j);\n      if (j == l) break;\n      i = j;\n    }\n    if (c < 0x800) {\n      t += String.fromCharCode(0xc0 | (c >> 6));\n      t += String.fromCharCode(0x80 | (c & 0x3f));\n    } else if (c < 0xd800 || c >= 0xdfff) {\n      t += String.fromCharCode(0xe0 | (c >> 12),\n                               0x80 | ((c >> 6) & 0x3f),\n                               0x80 | (c & 0x3f));\n    } else if (c >= 0xdbff || i + 1 == l ||\n               (d = s.charCodeAt(i + 1)) < 0xdc00 || d > 0xdfff) {\n      // Unmatched surrogate pair, replaced by \\ufffd (replacement character)\n      t += \"\\xef\\xbf\\xbd\";\n    } else {\n      i++;\n      c = (c << 10) + d - 0x35fdc00;\n      t += String.fromCharCode(0xf0 | (c >> 18),\n                               0x80 | ((c >> 12) & 0x3f),\n                               0x80 | ((c >> 6) & 0x3f),\n                               0x80 | (c & 0x3f));\n    }\n    if (t.length > 1024) {t.substr(0, 1); b += t; t = \"\";}\n  }\n  return b+t;\n}\n\n//Provides: caml_utf16_of_utf8\nfunction caml_utf16_of_utf8(s) {\n  for (var b = \"\", t = \"\", c, c1, c2, v, i = 0, l = s.length; i < l; i++) {\n    c1 = s.charCodeAt(i);\n    if (c1 < 0x80) {\n      for (var j = i + 1; (j < l) && (c1 = s.charCodeAt(j)) < 0x80; j++);\n      if (j - i > 512) { t.substr(0, 1); b += t; t = \"\"; b += s.slice(i, j) }\n      else t += s.slice(i, j);\n      if (j == l) break;\n      i = j;\n    }\n    v = 1;\n    if ((++i < l) && (((c2 = s.charCodeAt(i)) & -64) == 128)) {\n      c = c2 + (c1 << 6);\n      if (c1 < 0xe0) {\n        v = c - 0x3080;\n        if (v < 0x80) v = 1;\n      } else {\n        v = 2;\n        if ((++i < l) && (((c2 = s.charCodeAt(i)) & -64) == 128)) {\n          c = c2 + (c << 6);\n          if (c1 < 0xf0) {\n            v = c - 0xe2080;\n            if ((v < 0x800) || ((v >= 0xd7ff) && (v < 0xe000))) v = 2;\n          } else {\n              v = 3;\n              if ((++i < l) && (((c2 = s.charCodeAt(i)) & -64) == 128) &&\n                  (c1 < 0xf5)) {\n                v = c2 - 0x3c82080 + (c << 6);\n                if (v < 0x10000 || v > 0x10ffff) v = 3;\n              }\n          }\n        }\n      }\n    }\n    if (v < 4) { // Invalid sequence\n      i -= v;\n      t += \"\\ufffd\";\n    } else if (v > 0xffff)\n      t += String.fromCharCode(0xd7c0 + (v >> 10), 0xdc00 + (v & 0x3FF))\n    else\n      t += String.fromCharCode(v);\n    if (t.length > 1024) {t.substr(0, 1); b += t; t = \"\";}\n  }\n  return b+t;\n}\n\n//Provides: caml_is_ascii\nfunction caml_is_ascii (s) {\n  // The regular expression gets better at around this point for all browsers\n  if (s.length < 24) {\n    // Spidermonkey gets much slower when s.length >= 24 (on 64 bit archs)\n    for (var i = 0; i < s.length; i++) if (s.charCodeAt(i) > 127) return false;\n    return true;\n  } else\n    return !/[^\\x00-\\x7f]/.test(s);\n}\n\n//Provides: caml_to_js_string\n//Requires: caml_convert_string_to_bytes, caml_is_ascii, caml_utf16_of_utf8\nfunction caml_to_js_string(s) {\n  switch (s.t) {\n  case 9: /*BYTES | ASCII*/\n    return s.c;\n  default:\n    caml_convert_string_to_bytes(s);\n  case 0: /*BYTES | UNKOWN*/\n    if (caml_is_ascii(s.c)) {\n      s.t = 9; /*BYTES | ASCII*/\n      return s.c;\n    }\n    s.t = 8; /*BYTES | NOT_ASCII*/\n  case 8: /*BYTES | NOT_ASCII*/\n    return caml_utf16_of_utf8(s.c);\n  }\n}\n\n//Provides: caml_string_unsafe_get mutable\nfunction caml_string_unsafe_get (s, i) {\n  switch (s.t & 6) {\n  default: /* PARTIAL */\n    if (i >= s.c.length) return 0;\n  case 0: /* BYTES */\n    return s.c.charCodeAt(i);\n  case 4: /* ARRAY */\n    return s.c[i]\n  }\n}\n\n//Provides: caml_string_unsafe_set\n//Requires: caml_convert_string_to_array\nfunction caml_string_unsafe_set (s, i, c) {\n  // The OCaml compiler uses Char.unsafe_chr on integers larger than 255!\n  c &= 0xff;\n  if (s.t != 4 /* ARRAY */) {\n    if (i == s.c.length) {\n      s.c += String.fromCharCode (c);\n      if (i + 1 == s.l) s.t = 0; /*BYTES | UNKOWN*/\n      return 0;\n    }\n    caml_convert_string_to_array (s);\n  }\n  s.c[i] = c;\n  return 0;\n}\n\n//Provides: caml_string_bound_error\n//Requires: caml_invalid_argument\nfunction caml_string_bound_error () {\n  caml_invalid_argument (\"index out of bounds\");\n}\n\n//Provides: caml_string_get\n//Requires: caml_string_bound_error, caml_string_unsafe_get\nfunction caml_string_get (s, i) {\n  if (i >>> 0 >= s.l) caml_string_bound_error();\n  return caml_string_unsafe_get (s, i);\n}\n\n//Provides: caml_string_set\n//Requires: caml_string_bound_error, caml_string_unsafe_set\nfunction caml_string_set (s, i, c) {\n  if (i >>> 0 >= s.l) caml_string_bound_error();\n  return caml_string_unsafe_set (s, i, c);\n}\n\n//Provides: MlString\n//Requires: caml_to_js_string\nfunction MlString (tag, contents, length) {\n  this.t=tag; this.c=contents; this.l=length;\n}\nMlString.prototype.toString = function(){return caml_to_js_string(this)};\n\n//Provides: caml_convert_string_to_bytes\n//Requires: caml_str_repeat, caml_subarray_to_string\nfunction caml_convert_string_to_bytes (s) {\n  /* Assumes not BYTES */\n  if (s.t == 2 /* PARTIAL */)\n    s.c += caml_str_repeat(s.l - s.c.length, '\\0')\n  else\n    s.c = caml_subarray_to_string (s.c, 0, s.c.length);\n  s.t = 0; /*BYTES | UNKOWN*/\n}\n\n//Provides: caml_convert_string_to_array\nfunction caml_convert_string_to_array (s) {\n  /* Assumes not ARRAY */\n  if(joo_global_object.Uint8Array) {\n    var a = new joo_global_object.Uint8Array(s.l);\n  } else {\n    var a = new Array(s.l);\n  }\n  var b = s.c, l = b.length, i = 0;\n  for (; i < l; i++) a[i] = b.charCodeAt(i);\n  for (l = s.l; i < l; i++) a[i] = 0;\n  s.c = a;\n  s.t = 4; /* ARRAY */\n  return a;\n}\n\n//Provides: caml_array_of_string mutable\n//Requires: caml_convert_string_to_array\nfunction caml_array_of_string (s) {\n  if (s.t != 4 /* ARRAY */) caml_convert_string_to_array(s);\n  return s.c;\n}\n\n//Provides: caml_bytes_of_string mutable\n//Requires: caml_convert_string_to_bytes\nfunction caml_bytes_of_string (s) {\n  if ((s.t & 6) != 0 /* BYTES */) caml_convert_string_to_bytes(s);\n  return s.c;\n}\n\n//Provides: caml_js_to_string const\n//Requires: caml_is_ascii, caml_utf8_of_utf16, MlString\nfunction caml_js_to_string (s) {\n  var tag = 9 /* BYTES | ASCII */;\n  if (!caml_is_ascii(s))\n    tag = 8 /* BYTES | NOT_ASCII */, s = caml_utf8_of_utf16(s);\n  return new MlString(tag, s, s.length);\n}\n\n//Provides: caml_create_string const\n//Requires: MlString,caml_invalid_argument\nfunction caml_create_string(len) {\n  if (len < 0) caml_invalid_argument(\"String.create\");\n  return new MlString(len?2:9,\"\",len);\n}\n//Provides: caml_new_string\n//Requires: MlString\nfunction caml_new_string (s) { return new MlString(0,s,s.length); }\n//Provides: caml_string_of_array\n//Requires: MlString\nfunction caml_string_of_array (a) { return new MlString(4,a,a.length); }\n\n//Provides: caml_string_compare mutable\n//Requires: caml_convert_string_to_bytes\nfunction caml_string_compare(s1, s2) {\n  (s1.t & 6) && caml_convert_string_to_bytes(s1);\n  (s2.t & 6) && caml_convert_string_to_bytes(s2);\n  return (s1.c < s2.c)?-1:(s1.c > s2.c)?1:0;\n}\n\n//Provides: caml_string_equal mutable (const, const)\n//Requires: caml_convert_string_to_bytes\nfunction caml_string_equal(s1, s2) {\n  (s1.t & 6) && caml_convert_string_to_bytes(s1);\n  (s2.t & 6) && caml_convert_string_to_bytes(s2);\n  return (s1.c == s2.c)?1:0;\n}\n\n//Provides: caml_string_notequal mutable (const, const)\n//Requires: caml_string_equal\nfunction caml_string_notequal(s1, s2) { return 1-caml_string_equal(s1, s2); }\n\n//Provides: caml_string_lessequal mutable\n//Requires: caml_convert_string_to_bytes\nfunction caml_string_lessequal(s1, s2) {\n  (s1.t & 6) && caml_convert_string_to_bytes(s1);\n  (s2.t & 6) && caml_convert_string_to_bytes(s2);\n  return (s1.c <= s2.c)?1:0;\n}\n\n//Provides: caml_string_lessthan mutable\n//Requires: caml_convert_string_to_bytes\nfunction caml_string_lessthan(s1, s2) {\n  (s1.t & 6) && caml_convert_string_to_bytes(s1);\n  (s2.t & 6) && caml_convert_string_to_bytes(s2);\n  return (s1.c < s2.c)?1:0;\n}\n\n//Provides: caml_string_greaterequal\n//Requires: caml_string_lessequal\nfunction caml_string_greaterequal(s1, s2) {\n  return caml_string_lessequal(s2,s1);\n}\n\n//Provides: caml_string_greaterthan\n//Requires: caml_string_lessthan\nfunction caml_string_greaterthan(s1, s2) {\n  return caml_string_lessthan(s2, s1);\n}\n\n//Provides: caml_fill_string\n//Requires: caml_str_repeat, caml_convert_string_to_array\nfunction caml_fill_string(s, i, l, c) {\n  if (l > 0) {\n    if (i == 0 && (l >= s.l || (s.t == 2 /* PARTIAL */ && l >= s.c.length))) {\n      if (c == 0) {\n        s.c = \"\";\n        s.t = 2; /* PARTIAL */\n      } else {\n        s.c = caml_str_repeat (l, String.fromCharCode(c));\n        s.t = (l == s.l)?0 /* BYTES | UNKOWN */ :2; /* PARTIAL */\n      }\n    } else {\n      if (s.t != 4 /* ARRAY */) caml_convert_string_to_array(s);\n      for (l += i; i < l; i++) s.c[i] = c;\n    }\n  }\n  return 0;\n}\n\n//Provides: caml_blit_string\n//Requires: caml_subarray_to_string, caml_convert_string_to_array\nfunction caml_blit_string(s1, i1, s2, i2, len) {\n  if (len == 0) return 0;\n  if ((i2 == 0) &&\n      (len >= s2.l || (s2.t == 2 /* PARTIAL */ && len >= s2.c.length))) {\n    s2.c = (s1.t == 4 /* ARRAY */)?\n             caml_subarray_to_string(s1.c, i1, len):\n             (i1 == 0 && s1.c.length == len)?s1.c:s1.c.substr(i1, len);\n    s2.t = (s2.c.length == s2.l)?0 /* BYTES | UNKOWN */ :2; /* PARTIAL */\n  } else if (s2.t == 2 /* PARTIAL */ && i2 == s2.c.length) {\n    s2.c += (s1.t == 4 /* ARRAY */)?\n             caml_subarray_to_string(s1.c, i1, len):\n             (i1 == 0 && s1.c.length == len)?s1.c:s1.c.substr(i1, len);\n    s2.t = (s2.c.length == s2.l)?0 /* BYTES | UNKOWN */ :2; /* PARTIAL */\n  } else {\n    if (s2.t != 4 /* ARRAY */) caml_convert_string_to_array(s2);\n    var c1 = s1.c, c2 = s2.c;\n    if (s1.t == 4 /* ARRAY */)\n      for (var i = 0; i < len; i++) c2 [i2 + i] = c1 [i1 + i];\n    else {\n      var l = Math.min (len, c1.length - i1);\n      for (var i = 0; i < l; i++) c2 [i2 + i] = c1.charCodeAt(i1 + i);\n      for (; i < len; i++) c2 [i2 + i] = 0;\n    }\n  }\n  return 0;\n}\n\n//Provides: caml_ml_string_length const\nfunction caml_ml_string_length(s) { return s.l }\n",
  "// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Core\n\n//Provides: raw_array_sub\nfunction raw_array_sub (a,i,l) {\n  var b = new Array(l);\n  for(var j = 0; j < l; j++) b[j] = a[i+j];\n  return b\n}\n\n//Provides: raw_array_copy\nfunction raw_array_copy (a) {\n  var l = a.length;\n  var b = new Array(l);\n  for(var i = 0; i < l; i++ ) b[i] = a[i];\n  return b\n}\n\n//Provides: raw_array_cons\nfunction raw_array_cons (a,x) {\n  var l = a.length;\n  var b = new Array(l+1);\n  b[0]=x;\n  for(var i = 1; i <= l; i++ ) b[i] = a[i-1];\n  return b\n}\n\n//Provides: raw_array_append_one\nfunction raw_array_append_one(a,x) {\n  var l = a.length;\n  var b = new Array(l+1);\n  var i = 0;\n  for(; i < l; i++ ) b[i] = a[i];\n  b[i]=x;\n  return b\n}\n\n//Provides: caml_call_gen (const, shallow)\n//Requires: raw_array_sub\n//Requires: raw_array_append_one\nfunction caml_call_gen(f, args) {\n  if(f.fun)\n    return caml_call_gen(f.fun, args);\n  var n = f.length;\n  var argsLen = args.length;\n  var d = n - argsLen;\n  if (d == 0)\n    return f.apply(null, args);\n  else if (d < 0)\n    return caml_call_gen(f.apply(null,\n                                 raw_array_sub(args,0,n)),\n                         raw_array_sub(args,n,argsLen - n));\n  else\n    return function (x){ return caml_call_gen(f, raw_array_append_one(args,x)); };\n}\n\n//Provides: caml_named_values\nvar caml_named_values = {};\n\n//Provides: caml_register_named_value (const,const)\n//Requires: caml_named_values, caml_bytes_of_string\nfunction caml_register_named_value(nm,v) {\n  caml_named_values[caml_bytes_of_string(nm)] = v;\n  return 0;\n}\n\n//Provides: caml_named_value\n//Requires: caml_named_values\nfunction caml_named_value(nm) {\n  return caml_named_values[nm]\n}\n\n//Provides: caml_global_data\nvar caml_global_data = [0];\n\n//Provides: caml_register_global (const, shallow, const)\n//Requires: caml_global_data\nfunction caml_register_global (n, v, name_opt) {\n  caml_global_data[n + 1] = v;\n  if(name_opt) caml_global_data[name_opt] = v;\n}\n\n//Provides: caml_get_global_data mutable\n//Requires: caml_global_data\nfunction caml_get_global_data () { return caml_global_data; }\n\n//Raise exception\n\n\n//Provides: caml_raise_constant (const)\n//Version: < 4.02\nfunction caml_raise_constant (tag) { throw [0, tag]; }\n\n//Provides: caml_raise_constant (const)\n//Version: >= 4.02\nfunction caml_raise_constant (tag) { throw tag; }\n\n//Provides: caml_return_exn_constant (const)\n//Version: < 4.02\nfunction caml_return_exn_constant (tag) { return [0, tag]; }\n\n//Provides: caml_return_exn_constant (const)\n//Version: >= 4.02\nfunction caml_return_exn_constant (tag) { return tag; }\n\n//Provides: caml_raise_with_arg (const, const)\nfunction caml_raise_with_arg (tag, arg) { throw [0, tag, arg]; }\n\n//Provides: caml_raise_with_string (const, const)\n//Requires: caml_raise_with_arg,caml_new_string\nfunction caml_raise_with_string (tag, msg) {\n  caml_raise_with_arg (tag, caml_new_string (msg));\n}\n\n//Provides: caml_raise_sys_error (const)\n//Requires: caml_raise_with_string, caml_global_data\nfunction caml_raise_sys_error (msg) {\n  caml_raise_with_string(caml_global_data.Sys_error, msg);\n}\n\n//Provides: caml_failwith (const)\n//Requires: caml_raise_with_string, caml_global_data\nfunction caml_failwith (msg) {\n  caml_raise_with_string(caml_global_data.Failure, msg);\n}\n\n//Provides: caml_wrap_exception const (const)\n//Requires: caml_global_data,caml_js_to_string,caml_named_value\n//Requires: caml_return_exn_constant\nfunction caml_wrap_exception(e) {\n  if(e instanceof Array) return e;\n  //Stack_overflow: chrome, safari\n  if(joo_global_object.RangeError\n     && e instanceof joo_global_object.RangeError\n     && e.message\n     && e.message.match(/maximum call stack/i))\n    return caml_return_exn_constant(caml_global_data.Stack_overflow);\n  //Stack_overflow: firefox\n  if(joo_global_object.InternalError\n     && e instanceof joo_global_object.InternalError\n     && e.message\n     && e.message.match(/too much recursion/i))\n    return caml_return_exn_constant(caml_global_data.Stack_overflow);\n  //Wrap Error in Js.Error exception\n  if(e instanceof joo_global_object.Error)\n    return [0,caml_named_value(\"jsError\"),e];\n  //fallback: wrapped in Failure\n  return [0,caml_global_data.Failure,caml_js_to_string (String(e))];\n}\n\n// Experimental\n//Provides: caml_exn_with_js_backtrace\n//Requires: caml_global_data\nfunction caml_exn_with_js_backtrace(exn, force) {\n  if(!exn.js_error || force) exn.js_error = new joo_global_object.Error(\"Js exception containing backtrace\");\n  return exn;\n}\n//Provides: caml_js_error_of_exception\nfunction caml_js_error_of_exception(exn) {\n  if(exn.js_error) { return exn.js_error; }\n  return null;\n}\n\n//Provides: caml_invalid_argument (const)\n//Requires: caml_raise_with_string, caml_global_data\nfunction caml_invalid_argument (msg) {\n  caml_raise_with_string(caml_global_data.Invalid_argument, msg);\n}\n\n//Provides: caml_raise_end_of_file\n//Requires: caml_raise_constant, caml_global_data\nfunction caml_raise_end_of_file () {\n  caml_raise_constant(caml_global_data.End_of_file);\n}\n\n//Provides: caml_raise_zero_divide\n//Requires: caml_raise_constant, caml_global_data\nfunction caml_raise_zero_divide () {\n  caml_raise_constant(caml_global_data.Division_by_zero);\n}\n\n//Provides: caml_raise_not_found\n//Requires: caml_raise_constant, caml_global_data\nfunction caml_raise_not_found () {\n  caml_raise_constant(caml_global_data.Not_found); }\n\n\n//Provides: caml_array_bound_error\n//Requires: caml_invalid_argument\nfunction caml_array_bound_error () {\n  caml_invalid_argument(\"index out of bounds\");\n}\n\n//Provides: caml_update_dummy\nfunction caml_update_dummy (x, y) {\n  if( typeof y===\"function\" ) { x.fun = y; return 0; }\n  if( y.fun ) { x.fun = y.fun; return 0; }\n  var i = y.length; while (i--) x[i] = y[i]; return 0;\n}\n\n//Provides: caml_obj_is_block const (const)\nfunction caml_obj_is_block (x) { return +(x instanceof Array); }\n//Provides: caml_obj_tag const (const)\n//Requires: MlString\nfunction caml_obj_tag (x) { return (x instanceof Array)?x[0]:(x instanceof MlString)?252:1000; }\n//Provides: caml_obj_set_tag (mutable, const)\nfunction caml_obj_set_tag (x, tag) { x[0] = tag; return 0; }\n//Provides: caml_obj_block const (const,const)\nfunction caml_obj_block (tag, size) {\n  var o = new Array(size+1);\n  o[0]=tag;\n  for (var i = 1; i <= size; i++) o[i] = 0;\n  return o;\n}\n//Provides: caml_obj_dup mutable (const)\nfunction caml_obj_dup (x) {\n  var l = x.length;\n  var a = new Array(l);\n  for(var i = 0; i < l; i++ ) a[i] = x[i];\n  return a;\n}\n//Provides: caml_obj_truncate (mutable, const)\n//Requires: caml_invalid_argument\nfunction caml_obj_truncate (x, s) {\n  if (s<=0 || s + 1 > x.length)\n    caml_invalid_argument (\"Obj.truncate\");\n  if (x.length != s + 1) x.length = s + 1;\n  return 0;\n}\n\n//Provides: caml_lazy_make_forward const (const)\nfunction caml_lazy_make_forward (v) { return [250, v]; }\n\n//Provides: caml_mul const\nif (!Math.imul)\n  Math.imul =\n    function (x,y)\n    { y |= 0; return ((((x >> 16) * y) << 16) + (x & 0xffff) * y)|0; };\nvar caml_mul = Math.imul;\n\n//slightly slower\n// function mul32(x,y) {\n//   var xlo = x & 0xffff;\n//   var xhi = x - xlo;\n//   return (((xhi * y) |0) + xlo * y)|0;\n// }\n\n//Provides: caml_div\n//Requires: caml_raise_zero_divide\nfunction caml_div(x,y) {\n  if (y == 0) caml_raise_zero_divide ();\n  return (x/y)|0;\n}\n\n//Provides: caml_mod\n//Requires: caml_raise_zero_divide\nfunction caml_mod(x,y) {\n  if (y == 0) caml_raise_zero_divide ();\n  return x%y;\n}\n\n///////////// Pervasive\n//Provides: caml_array_set (mutable, const, const)\n//Requires: caml_array_bound_error\nfunction caml_array_set (array, index, newval) {\n  if ((index < 0) || (index >= array.length - 1)) caml_array_bound_error();\n  array[index+1]=newval; return 0;\n}\n\n//Provides: caml_array_get mutable (const, const)\n//Requires: caml_array_bound_error\nfunction caml_array_get (array, index) {\n  if ((index < 0) || (index >= array.length - 1)) caml_array_bound_error();\n  return array[index+1];\n}\n\n//Provides: caml_check_bound (const, const)\n//Requires: caml_array_bound_error\nfunction caml_check_bound (array, index) {\n  if (index >>> 0 >= array.length - 1) caml_array_bound_error();\n  return array;\n}\n\n//Provides: caml_make_vect const (const, const)\nfunction caml_make_vect (len, init) {\n  var len = len + 1 | 0;\n  var b = new Array(len);\n  b[0]=0;\n  for (var i = 1; i < len; i++) b[i] = init;\n  return b;\n}\n\n//Provides: caml_make_float_vect const (const)\nfunction caml_make_float_vect(len){\n  var len = len + 1 | 0;\n  var b = new Array(len);\n  b[0]=254;\n  for (var i = 1; i < len; i++) b[i] = 0;\n  return b\n}\n\n//Provides: caml_compare_val (const, const, const)\n//Requires: MlString, caml_int64_compare, caml_int_compare, caml_string_compare\n//Requires: caml_invalid_argument\nfunction caml_compare_val (a, b, total) {\n  var stack = [];\n  for(;;) {\n    if (!(total && a === b)) {\n      if (a instanceof MlString) {\n        if (b instanceof MlString) {\n            if (a !== b) {\n\u0009\u0009var x = caml_string_compare(a, b);\n\u0009\u0009if (x != 0) return x;\n\u0009    }\n        } else\n          // Should not happen\n          return 1;\n      } else if (a instanceof Array && a[0] === (a[0]|0)) {\n        var ta = a[0];\n        // ignore double_array_tag\n        if (ta === 254) ta=0;\n        // Forward object\n        if (ta === 250) {\n          a = a[1];\n          continue;\n        } else if (b instanceof Array && b[0] === (b[0]|0)) {\n          var tb = b[0];\n          // ignore double_array_tag\n          if (tb === 254) tb=0;\n          // Forward object\n          if (tb === 250) {\n            b = b[1];\n            continue;\n          } else if (ta != tb) {\n            return (ta < tb)?-1:1;\n          } else {\n            switch (ta) {\n            case 248: {\n\u0009\u0009// Object\n\u0009\u0009var x = caml_int_compare(a[2], b[2]);\n\u0009\u0009if (x != 0) return x;\n\u0009\u0009break;\n\u0009    }\n            case 251: {\n                caml_invalid_argument(\"equal: abstract value\");\n            }\n            case 255: {\n\u0009\u0009// Int64\n\u0009\u0009var x = caml_int64_compare(a, b);\n\u0009\u0009if (x != 0) return x;\n\u0009\u0009break;\n\u0009    }\n            default:\n              if (a.length != b.length) return (a.length < b.length)?-1:1;\n              if (a.length > 1) stack.push(a, b, 1);\n            }\n          }\n        } else\n          return 1;\n      } else if (b instanceof MlString ||\n                 (b instanceof Array && b[0] === (b[0]|0))) {\n        return -1;\n      } else if (typeof a != \"number\" && a && a.compare) {\n        return a.compare(b,total);\n      } else if (typeof a == \"function\") {\n        caml_invalid_argument(\"equal: functional value\");\n      } else {\n        if (a < b) return -1;\n        if (a > b) return 1;\n        if (a != b) {\n          if (!total) return NaN;\n          if (a == a) return 1;\n          if (b == b) return -1;\n        }\n      }\n    }\n    if (stack.length == 0) return 0;\n    var i = stack.pop();\n    b = stack.pop();\n    a = stack.pop();\n    if (i + 1 < a.length) stack.push(a, b, i + 1);\n    a = a[i];\n    b = b[i];\n  }\n}\n//Provides: caml_compare (const, const)\n//Requires: caml_compare_val\nfunction caml_compare (a, b) { return caml_compare_val (a, b, true); }\n//Provides: caml_int_compare mutable (const, const)\nfunction caml_int_compare (a, b) {\n  if (a < b) return (-1); if (a == b) return 0; return 1;\n}\n//Provides: caml_equal mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_equal (x, y) { return +(caml_compare_val(x,y,false) == 0); }\n//Provides: caml_notequal mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_notequal (x, y) { return +(caml_compare_val(x,y,false) != 0); }\n//Provides: caml_greaterequal mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_greaterequal (x, y) { return +(caml_compare_val(x,y,false) >= 0); }\n//Provides: caml_greaterthan mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_greaterthan (x, y) { return +(caml_compare_val(x,y,false) > 0); }\n//Provides: caml_lessequal mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_lessequal (x, y) { return +(caml_compare_val(x,y,false) <= 0); }\n//Provides: caml_lessthan mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_lessthan (x, y) { return +(caml_compare_val(x,y,false) < 0); }\n\n//Provides: caml_parse_sign_and_base\n//Requires: caml_string_unsafe_get, caml_ml_string_length\nfunction caml_parse_sign_and_base (s) {\n  var i = 0, len = caml_ml_string_length(s), base = 10,\n     sign = (len > 0 && caml_string_unsafe_get(s,0) == 45)?(i++,-1):1;\n  if (i + 1 < len && caml_string_unsafe_get(s, i) == 48)\n    switch (caml_string_unsafe_get(s, i + 1)) {\n    case 120: case 88: base = 16; i += 2; break;\n    case 111: case 79: base =  8; i += 2; break;\n    case  98: case 66: base =  2; i += 2; break;\n    }\n  return [i, sign, base];\n}\n\n//Provides: caml_parse_digit\nfunction caml_parse_digit(c) {\n  if (c >= 48 && c <= 57)  return c - 48;\n  if (c >= 65 && c <= 90)  return c - 55;\n  if (c >= 97 && c <= 122) return c - 87;\n  return -1;\n}\n\n//Provides: caml_int_of_string (const)\n//Requires: caml_ml_string_length, caml_string_unsafe_get\n//Requires: caml_parse_sign_and_base, caml_parse_digit, caml_failwith\nfunction caml_int_of_string (s) {\n  var r = caml_parse_sign_and_base (s);\n  var i = r[0], sign = r[1], base = r[2];\n  var len = caml_ml_string_length(s);\n  var threshold = -1 >>> 0;\n  var c = (i < len)?caml_string_unsafe_get(s, i):0;\n  var d = caml_parse_digit(c);\n  if (d < 0 || d >= base) caml_failwith(\"int_of_string\");\n  var res = d;\n  for (i++;i<len;i++) {\n    c = caml_string_unsafe_get(s, i);\n    if (c == 95) continue;\n    d = caml_parse_digit(c);\n    if (d < 0 || d >= base) break;\n    res = base * res + d;\n    if (res > threshold) caml_failwith(\"int_of_string\");\n  }\n  if (i != len) caml_failwith(\"int_of_string\");\n  // For base different from 10, we expect an unsigned representation,\n  // hence any value of 'res' (less than 'threshold') is acceptable.\n  // But we have to convert the result back to a signed integer.\n  res = sign * res;\n  if ((base == 10) && ((res | 0) != res))\n    /* Signed representation expected, allow -2^(nbits-1) to 2^(nbits-1) - 1 */\n    caml_failwith(\"int_of_string\");\n  return res | 0;\n}\n\n//Provides: caml_float_of_string (const)\n//Requires: caml_failwith, caml_bytes_of_string\nfunction caml_float_of_string(s) {\n  var res;\n  s = caml_bytes_of_string (s);\n  res = +s;\n  if ((s.length > 0) && (res === res)) return res;\n  s = s.replace(/_/g,\"\");\n  res = +s;\n  if (((s.length > 0) && (res === res)) || /^[+-]?nan$/i.test(s)) return res;\n  var m = /^ *([+-]?)0x([0-9a-f]+)\\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);\n//            1        2             3           4\n  if(m){\n    var m3 = m[3].replace(/0+$/,'');\n    var mantissa = parseInt(m[1] + m[2] + m3, 16);\n    var exponent = (m[4]|0) - 4*m3.length;\n    res = mantissa * Math.pow(2, exponent);\n    return res;\n  }\n  if(/^\\+?inf(inity)?$/i.test(s)) return Infinity;\n  if(/^-inf(inity)?$/i.test(s)) return -Infinity;\n  caml_failwith(\"float_of_string\");\n}\n\n//Provides: caml_is_printable const (const)\nfunction caml_is_printable(c) { return +(c > 31 && c < 127); }\n\n///////////// Format\n//Provides: caml_parse_format\n//Requires: caml_bytes_of_string, caml_invalid_argument\nfunction caml_parse_format (fmt) {\n  fmt = caml_bytes_of_string(fmt);\n  var len = fmt.length;\n  if (len > 31) caml_invalid_argument(\"format_int: format too long\");\n  var f =\n    { justify:'+', signstyle:'-', filler:' ', alternate:false,\n      base:0, signedconv:false, width:0, uppercase:false,\n      sign:1, prec:-1, conv:'f' };\n  for (var i = 0; i < len; i++) {\n    var c = fmt.charAt(i);\n    switch (c) {\n    case '-':\n      f.justify = '-'; break;\n    case '+': case ' ':\n      f.signstyle = c; break;\n    case '0':\n      f.filler = '0'; break;\n    case '#':\n      f.alternate = true; break;\n    case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n      f.width = 0;\n      while (c=fmt.charCodeAt(i) - 48, c >= 0 && c <= 9) {\n        f.width = f.width * 10 + c; i++\n      }\n      i--;\n     break;\n    case '.':\n      f.prec = 0;\n      i++;\n      while (c=fmt.charCodeAt(i) - 48, c >= 0 && c <= 9) {\n        f.prec = f.prec * 10 + c; i++\n      }\n      i--;\n    case 'd': case 'i':\n      f.signedconv = true; /* fallthrough */\n    case 'u':\n      f.base = 10; break;\n    case 'x':\n      f.base = 16; break;\n    case 'X':\n      f.base = 16; f.uppercase = true; break;\n    case 'o':\n      f.base = 8; break;\n    case 'e': case 'f': case 'g':\n      f.signedconv = true; f.conv = c; break;\n    case 'E': case 'F': case 'G':\n      f.signedconv = true; f.uppercase = true;\n      f.conv = c.toLowerCase (); break;\n    }\n  }\n  return f;\n}\n\n//Provides: caml_finish_formatting\n//Requires: caml_new_string\nfunction caml_finish_formatting(f, rawbuffer) {\n  if (f.uppercase) rawbuffer = rawbuffer.toUpperCase();\n  var len = rawbuffer.length;\n  /* Adjust len to reflect additional chars (sign, etc) */\n  if (f.signedconv && (f.sign < 0 || f.signstyle != '-')) len++;\n  if (f.alternate) {\n    if (f.base == 8) len += 1;\n    if (f.base == 16) len += 2;\n  }\n  /* Do the formatting */\n  var buffer = \"\";\n  if (f.justify == '+' && f.filler == ' ')\n    for (var i = len; i < f.width; i++) buffer += ' ';\n  if (f.signedconv) {\n    if (f.sign < 0) buffer += '-';\n    else if (f.signstyle != '-') buffer += f.signstyle;\n  }\n  if (f.alternate && f.base == 8) buffer += '0';\n  if (f.alternate && f.base == 16) buffer += \"0x\";\n  if (f.justify == '+' && f.filler == '0')\n    for (var i = len; i < f.width; i++) buffer += '0';\n  buffer += rawbuffer;\n  if (f.justify == '-')\n    for (var i = len; i < f.width; i++) buffer += ' ';\n  return caml_new_string (buffer);\n}\n\n//Provides: caml_format_int const (const, const)\n//Requires: caml_parse_format, caml_finish_formatting, caml_str_repeat\n//Requires: caml_new_string, caml_bytes_of_string\nfunction caml_format_int(fmt, i) {\n  if (caml_bytes_of_string(fmt) == \"%d\") return caml_new_string(\"\"+i);\n  var f = caml_parse_format(fmt);\n  if (i < 0) { if (f.signedconv) { f.sign = -1; i = -i; } else i >>>= 0; }\n  var s = i.toString(f.base);\n  if (f.prec >= 0) {\n    f.filler = ' ';\n    var n = f.prec - s.length;\n    if (n > 0) s = caml_str_repeat (n, '0') + s;\n  }\n  return caml_finish_formatting(f, s);\n}\n\n//Provides: caml_format_float const\n//Requires: caml_parse_format, caml_finish_formatting\nfunction caml_format_float (fmt, x) {\n  var s, f = caml_parse_format(fmt);\n  var prec = (f.prec < 0)?6:f.prec;\n  if (x < 0 || (x == 0 && 1/x == -Infinity)) { f.sign = -1; x = -x; }\n  if (isNaN(x)) { s = \"nan\"; f.filler = ' '; }\n  else if (!isFinite(x)) { s = \"inf\"; f.filler = ' '; }\n  else\n    switch (f.conv) {\n    case 'e':\n      var s = x.toExponential(prec);\n      // exponent should be at least two digits\n      var i = s.length;\n      if (s.charAt(i - 3) == 'e')\n        s = s.slice (0, i - 1) + '0' + s.slice (i - 1);\n      break;\n    case 'f':\n      s = x.toFixed(prec); break;\n    case 'g':\n      prec = prec?prec:1;\n      s = x.toExponential(prec - 1);\n      var j = s.indexOf('e');\n      var exp = +s.slice(j + 1);\n      if (exp < -4 || x >= 1e21 || x.toFixed(0).length > prec) {\n        // remove trailing zeroes\n        var i = j - 1; while (s.charAt(i) == '0') i--;\n        if (s.charAt(i) == '.') i--;\n        s = s.slice(0, i + 1) + s.slice(j);\n        i = s.length;\n        if (s.charAt(i - 3) == 'e')\n          s = s.slice (0, i - 1) + '0' + s.slice (i - 1);\n        break;\n      } else {\n        var p = prec;\n        if (exp < 0) { p -= exp + 1; s = x.toFixed(p); }\n        else while (s = x.toFixed(p), s.length > prec + 1) p--;\n        if (p) {\n          // remove trailing zeroes\n          var i = s.length - 1; while (s.charAt(i) == '0') i--;\n          if (s.charAt(i) == '.') i--;\n          s = s.slice(0, i + 1);\n        }\n      }\n      break;\n    }\n  return caml_finish_formatting(f, s);\n}\n\n///////////// Hashtbl\n//Provides: caml_hash_univ_param mutable\n//Requires: MlString, caml_convert_string_to_bytes\n//Requires: caml_int64_to_bytes, caml_int64_bits_of_float\nfunction caml_hash_univ_param (count, limit, obj) {\n  var hash_accu = 0;\n  function hash_aux (obj) {\n    limit --;\n    if (count < 0 || limit < 0) return;\n    if (obj instanceof Array && obj[0] === (obj[0]|0)) {\n      switch (obj[0]) {\n      case 248:\n        // Object\n        count --;\n        hash_accu = (hash_accu * 65599 + obj[2]) | 0;\n        break;\n      case 250:\n        // Forward\n        limit++; hash_aux(obj); break;\n      case 255:\n        // Int64\n        count --;\n        hash_accu = (hash_accu * 65599 + obj[1] + (obj[2] << 24)) | 0;\n        break;\n      default:\n        count --;\n        hash_accu = (hash_accu * 19 + obj[0]) | 0;\n        for (var i = obj.length - 1; i > 0; i--) hash_aux (obj[i]);\n      }\n    } else if (obj instanceof MlString) {\n      count --;\n      switch (obj.t & 6) {\n      default: /* PARTIAL */\n        caml_convert_string_to_bytes(obj);\n      case 0: /* BYTES */\n        for (var b = obj.c, l = obj.l, i = 0; i < l; i++)\n          hash_accu = (hash_accu * 19 + b.charCodeAt(i)) | 0;\n        break;\n      case 2: /* ARRAY */\n        for (var a = obj.c, l = obj.l, i = 0; i < l; i++)\n          hash_accu = (hash_accu * 19 + a[i]) | 0;\n      }\n    } else if (obj === (obj|0)) {\n      // Integer\n      count --;\n      hash_accu = (hash_accu * 65599 + obj) | 0;\n    } else if (obj === +obj) {\n      // Float\n      count--;\n      var p = caml_int64_to_bytes (caml_int64_bits_of_float (obj));\n      for (var i = 7; i >= 0; i--) hash_accu = (hash_accu * 19 + p[i]) | 0;\n    }\n  }\n  hash_aux (obj);\n  return hash_accu & 0x3FFFFFFF;\n}\n\n//function ROTL32(x,n) { return ((x << n) | (x >>> (32-n))); }\n//Provides: caml_hash_mix_int\n//Requires: caml_mul\nfunction caml_hash_mix_int(h,d) {\n  d = caml_mul(d, 0xcc9e2d51|0);\n  d = ((d << 15) | (d >>> (32-15))); // ROTL32(d, 15);\n  d = caml_mul(d, 0x1b873593);\n  h ^= d;\n  h = ((h << 13) | (h >>> (32-13)));   //ROTL32(h, 13);\n  return (((h + (h << 2))|0) + (0xe6546b64|0))|0;\n}\n\n//Provides: caml_hash_mix_final\n//Requires: caml_mul\nfunction caml_hash_mix_final(h) {\n  h ^= h >>> 16;\n  h = caml_mul (h, 0x85ebca6b|0);\n  h ^= h >>> 13;\n  h = caml_mul (h, 0xc2b2ae35|0);\n  h ^= h >>> 16;\n  return h;\n}\n\n//Provides: caml_hash_mix_float\n//Requires: caml_hash_mix_int, caml_int64_bits_of_float\nfunction caml_hash_mix_float (h, v0) {\n  var v = caml_int64_bits_of_float (v0);\n  var lo = v[1] | (v[2] << 24);\n  var hi = (v[2] >>> 8) | (v[3] << 16);\n  h = caml_hash_mix_int(h, lo);\n  h = caml_hash_mix_int(h, hi);\n  return h;\n}\n//Provides: caml_hash_mix_int64\n//Requires: caml_hash_mix_int\nfunction caml_hash_mix_int64 (h, v) {\n  var lo = v[1] | (v[2] << 24);\n  var hi = (v[2] >>> 8) | (v[3] << 16);\n  h = caml_hash_mix_int(h, hi ^ lo);\n  return h;\n}\n\n//Provides: caml_hash_mix_string_str\n//Requires: caml_hash_mix_int\nfunction caml_hash_mix_string_str(h, s) {\n  var len = s.length, i, w;\n  for (i = 0; i + 4 <= len; i += 4) {\n    w = s.charCodeAt(i)\n        | (s.charCodeAt(i+1) << 8)\n        | (s.charCodeAt(i+2) << 16)\n        | (s.charCodeAt(i+3) << 24);\n    h = caml_hash_mix_int(h, w);\n  }\n  w = 0;\n  switch (len & 3) {\n  case 3: w  = s.charCodeAt(i+2) << 16;\n  case 2: w |= s.charCodeAt(i+1) << 8;\n  case 1: w |= s.charCodeAt(i);\n          h = caml_hash_mix_int(h, w);\n  default:\n  }\n  h ^= len;\n  return h;\n}\n\n//Provides: caml_hash_mix_string_arr\n//Requires: caml_hash_mix_int\nfunction caml_hash_mix_string_arr(h, s) {\n  var len = s.length, i, w;\n  for (i = 0; i + 4 <= len; i += 4) {\n    w = s[i]\n      | (s[i+1] << 8)\n      | (s[i+2] << 16)\n      | (s[i+3] << 24);\n    h = caml_hash_mix_int(h, w);\n  }\n  w = 0;\n  switch (len & 3) {\n  case 3: w  = s[i+2] << 16;\n  case 2: w |= s[i+1] << 8;\n  case 1: w |= s[i];\n    h = caml_hash_mix_int(h, w);\n  default:\n  }\n  h ^= len;\n  return h;\n}\n\n//Provides: caml_hash_mix_string\n//Requires: caml_convert_string_to_bytes\n//Requires: caml_hash_mix_string_str\n//Requires: caml_hash_mix_string_arr\nfunction caml_hash_mix_string(h, v) {\n    switch (v.t & 6) {\n    default:\n        caml_convert_string_to_bytes (v);\n    case 0: /* BYTES */\n        h = caml_hash_mix_string_str(h, v.c);\n        break;\n    case 2: /* ARRAY */\n        h = caml_hash_mix_string_arr(h, v.c);\n    }\n    return h\n}\n\n\n//Provides: caml_hash mutable\n//Requires: MlString\n//Requires: caml_int64_bits_of_float, caml_hash_mix_int, caml_hash_mix_final\n//Requires: caml_hash_mix_int64, caml_hash_mix_float, caml_hash_mix_string\nvar HASH_QUEUE_SIZE = 256;\nfunction caml_hash (count, limit, seed, obj) {\n    var queue, rd, wr, sz, num, h, v, i, len;\n    sz = limit;\n    if (sz < 0 || sz > HASH_QUEUE_SIZE) sz = HASH_QUEUE_SIZE;\n    num = count;\n    h = seed;\n    queue = [obj]; rd = 0; wr = 1;\n    while (rd < wr && num > 0) {\n        v = queue[rd++];\n        if (v instanceof Array && v[0] === (v[0]|0)) {\n            switch (v[0]) {\n            case 248:\n                // Object\n                h = caml_hash_mix_int(h, v[2]);\n                num--;\n                break;\n            case 250:\n                // Forward\n                queue[--rd] = v[1];\n                break;\n            case 255:\n                // Int64\n                h = caml_hash_mix_int64 (h, v);\n                num --;\n                break;\n            default:\n                var tag = ((v.length - 1) << 10) | v[0];\n                h = caml_hash_mix_int(h, tag);\n                for (i = 1, len = v.length; i < len; i++) {\n                    if (wr >= sz) break;\n                    queue[wr++] = v[i];\n                }\n                break;\n            }\n        } else if (v instanceof MlString) {\n            h = caml_hash_mix_string(h,v)\n            num--;\n        } else if (v === (v|0)) {\n            // Integer\n            h = caml_hash_mix_int(h, v+v+1);\n            num--;\n        } else if (v === +v) {\n            // Float\n            h = caml_hash_mix_float(h,v);\n            num--;\n        }\n    }\n    h = caml_hash_mix_final(h);\n    return h & 0x3FFFFFFF;\n}\n\n///////////// Sys\n//Provides: caml_sys_time mutable\nvar caml_initial_time = new Date() * 0.001;\nfunction caml_sys_time () { return new Date() * 0.001 - caml_initial_time; }\n//Provides: caml_sys_get_config const\n//Requires: caml_new_string\nfunction caml_sys_get_config () {\n  return [0, caml_new_string(\"Unix\"), 32, 0];\n}\n\n//Provides: caml_sys_const_backend_type const\n//Requires: caml_new_string\nfunction caml_sys_const_backend_type () {\n  return [0, caml_new_string(\"js_of_ocaml\")];\n}\n\n\n//Provides: caml_sys_random_seed mutable\n//Version: < 4.00\n//The function needs to return an array since OCaml 4.0...\nfunction caml_sys_random_seed () {\n  var x = new Date()^0xffffffff*Math.random();\n  return x;\n}\n\n//Provides: caml_sys_random_seed mutable\n//Version: >= 4.00\n//The function needs to return an array since OCaml 4.0...\nfunction caml_sys_random_seed () {\n  var x = new Date()^0xffffffff*Math.random();\n  return [0,x];\n}\n\n\n\n//Provides: caml_sys_const_big_endian const\nfunction caml_sys_const_big_endian () { return 0; }\n//Provides: caml_sys_const_word_size const\nfunction caml_sys_const_word_size () { return 32; }\n//Provides: caml_sys_const_int_size const\nfunction caml_sys_const_int_size () { return 32; }\n\n//Provides: caml_sys_const_max_wosize const\n// max_int / 4 so that the following does not overflow\n//let max_string_length = word_size / 8 * max_array_length - 1;;\nfunction caml_sys_const_max_wosize () { return (0x7FFFFFFF/4) | 0;}\n\n//Provides: caml_sys_const_ostype_cygwin const\nfunction caml_sys_const_ostype_cygwin () { return 0; }\n//Provides: caml_sys_const_ostype_unix const\nfunction caml_sys_const_ostype_unix () { return 1; }\n//Provides: caml_sys_const_ostype_win32 const\nfunction caml_sys_const_ostype_win32 () { return 0; }\n\n//Provides: caml_sys_system_command\nfunction caml_sys_system_command(_cmd){\n  return 127;\n}\n\n///////////// Array\n//Provides: caml_array_sub mutable\nfunction caml_array_sub (a, i, len) {\n  var a2 = new Array(len+1);\n  a2[0]=0;\n  for(var i2 = 1, i1= i+1; i2 <= len; i2++,i1++ ){\n    a2[i2]=a[i1];\n  }\n  return a2;\n}\n\n//Provides: caml_array_append mutable\nfunction caml_array_append(a1, a2) {\n  var l1 = a1.length, l2 = a2.length;\n  var l = l1+l2-1\n  var a = new Array(l);\n  a[0] = 0;\n  var i = 1,j = 1;\n  for(;i<l1;i++) a[i]=a1[i];\n  for(;i<l;i++,j++) a[i]=a2[j];\n  return a;\n}\n\n//Provides: caml_array_concat mutable\nfunction caml_array_concat(l) {\n  var a = [0];\n  while (l !== 0) {\n    var b = l[1];\n    for (var i = 1; i < b.length; i++) a.push(b[i]);\n    l = l[2];\n  }\n  return a;\n}\n\n//Provides: caml_array_blit\nfunction caml_array_blit(a1, i1, a2, i2, len) {\n  if (i2 <= i1) {\n    for (var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];\n  } else {\n    for (var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];\n  };\n  return 0;\n}\n\n///////////// CamlinternalOO\n//Provides: caml_get_public_method const\nvar caml_method_cache = [];\nfunction caml_get_public_method (obj, tag, cacheid) {\n  var meths = obj[1];\n  var ofs = caml_method_cache[cacheid];\n  if (ofs === null) {\n    // Make sure the array is not sparse\n    for (var i = caml_method_cache.length; i < cacheid; i++)\n      caml_method_cache[i] = 0;\n  } else if (meths[ofs] === tag) {\n//      console.log(\"cache hit\");\n    return meths[ofs - 1];\n  }\n//  console.log(\"cache miss\");\n  var li = 3, hi = meths[1] * 2 + 1, mi;\n  while (li < hi) {\n    mi = ((li+hi) >> 1) | 1;\n    if (tag < meths[mi+1]) hi = mi-2;\n    else li = mi;\n  }\n  caml_method_cache[cacheid] = li + 1;\n  /* return 0 if tag is not there */\n  return (tag == meths[li+1] ? meths[li] : 0);\n}\n\n//Provides: caml_final_register const\nfunction caml_final_register () { return 0; }\n//Provides: caml_final_release const\nfunction caml_final_release () { return 0; }\n//Provides: caml_backtrace_status const\nfunction caml_backtrace_status () { return 0; }\n//Provides: caml_get_exception_backtrace const\nfunction caml_get_exception_backtrace () { return 0; }\n//Provides: caml_get_exception_raw_backtrace const\nfunction caml_get_exception_raw_backtrace () { return [0]; }\n//Provides: caml_record_backtrace\nfunction caml_record_backtrace () { return 0; }\n//Provides: caml_convert_raw_backtrace const\nfunction caml_convert_raw_backtrace () { return 0; }\n//Provides: caml_get_current_callstack const\nfunction caml_get_current_callstack () { return [0]; }\n//Provides: caml_sys_getenv (const)\n//Requires: caml_raise_not_found\n//Requires: caml_js_to_string\nfunction caml_sys_getenv (name) {\n  var g = joo_global_object;\n  var n = name.toString();\n  //nodejs env\n  if(g.process\n     && g.process.env\n     && g.process.env[n] != undefined)\n    return caml_js_to_string(g.process.env[n]);\n  caml_raise_not_found ();\n}\n//Provides: caml_sys_exit\n//Requires: caml_invalid_argument\nfunction caml_sys_exit (code) {\n  var g = joo_global_object;\n  if(g.quit) g.quit(code);\n  //nodejs\n  if(g.process && g.process.exit) g.process.exit(code);\n  caml_invalid_argument(\"Function 'exit' not implemented\");\n}\n\n//Provides: caml_sys_get_argv const\n//Requires: caml_js_to_string\n//Requires: raw_array_sub\nfunction caml_sys_get_argv () {\n  var g = joo_global_object;\n  var main = \"a.out\";\n  var args = []\n\n  if(g.process\n     && g.process.argv\n     && g.process.argv.length > 0) {\n    var argv = g.process.argv\n    //nodejs\n    main = argv[1];\n    args = raw_array_sub(argv,2,argv.length - 2);\n  }\n\n  var p = caml_js_to_string(main);\n  var args2 = [0, p];\n  for(var i = 0; i < args.length; i++)\n    args2.push(caml_js_to_string(args[i]));\n  return [0, p, args2];\n}\n\n//Provides: unix_inet_addr_of_string\nfunction unix_inet_addr_of_string () {return 0;}\n\n//Provides: caml_oo_last_id\nvar caml_oo_last_id = 0;\n\n//Provides: caml_set_oo_id\n//Requires: caml_oo_last_id\nfunction caml_set_oo_id (b) {\n  b[2]=caml_oo_last_id++;\n  return b;\n}\n\n//Provides: caml_fresh_oo_id\n//Requires: caml_oo_last_id\nfunction caml_fresh_oo_id() {\n  return caml_oo_last_id++;\n}\n\n//Provides: caml_install_signal_handler const\nfunction caml_install_signal_handler(){return 0}\n\n\n//Provides: caml_convert_raw_backtrace_slot\n//Requires: caml_failwith\nfunction caml_convert_raw_backtrace_slot(){\n  caml_failwith(\"caml_convert_raw_backtrace_slot\");\n}\n\n//Provides: caml_bswap16\nfunction caml_bswap16(x) {\n  return ((((x & 0x00FF) << 8) |\n           ((x & 0xFF00) >> 8)));\n}\n//Provides: caml_int32_bswap\nfunction caml_int32_bswap(x) {\n  return (((x & 0x000000FF) << 24) |\n          ((x & 0x0000FF00) << 8) |\n          ((x & 0x00FF0000) >> 8) |\n          ((x & 0xFF000000) >> 24));\n}\n//Provides: caml_int64_bswap\nfunction caml_int64_bswap(x) {\n  return [\n    255,\n    (((x[3] & 0x0000ff00) >> 8) |\n     ((x[3] & 0x000000ff) << 8) |\n     ((x[2] & 0x00ff0000))),\n    (((x[2] & 0x0000ff00) >> 8) |\n     ((x[2] & 0x000000ff) << 8) |\n     ((x[1] & 0x00ff0000))),\n    (((x[1] & 0x0000ff00) >> 8) |\n     ((x[1] & 0x000000ff) << 8))]\n}\n\n//Provides: caml_list_of_js_array const (const)\nfunction caml_list_of_js_array(a){\n  var l = 0;\n  for(var i=a.length - 1; i>=0; i--){\n    var e = a[i];\n    l = [0,e,l];\n  }\n  return l\n}\n\n//Provides: caml_runtime_warnings\nvar caml_runtime_warnings = 0;\n\n//Provides: caml_ml_enable_runtime_warnings\n//Requires: caml_runtime_warnings\nfunction caml_ml_enable_runtime_warnings (bool) {\n  caml_runtime_warnings = bool;\n  return 0;\n}\n\n//Provides: caml_ml_runtime_warnings_enabled\n//Requires: caml_runtime_warnings\nfunction caml_ml_runtime_warnings_enabled (_unit) {\n  return caml_runtime_warnings;\n}\n\n\n//Provides: caml_sys_isatty\nfunction caml_sys_isatty(_chan) {\n  return 0;\n}\n",
  "// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_int64_offset\nvar caml_int64_offset = Math.pow(2, -24);\n\n//Provides: caml_int64_ucompare const\nfunction caml_int64_ucompare(x,y) {\n  if (x[3] > y[3]) return 1;\n  if (x[3] < y[3]) return -1;\n  if (x[2] > y[2]) return 1;\n  if (x[2] < y[2]) return -1;\n  if (x[1] > y[1]) return 1;\n  if (x[1] < y[1]) return -1;\n  return 0;\n}\n\n//Provides: caml_int64_ult const\n//Requires: caml_int64_ucompare\nfunction caml_int64_ult(x,y) { return caml_int64_ucompare(x,y) < 0; }\n\n//Provides: caml_int64_compare const\nfunction caml_int64_compare(x,y) {\n  var x3 = x[3] << 16;\n  var y3 = y[3] << 16;\n  if (x3 > y3) return 1;\n  if (x3 < y3) return -1;\n  if (x[2] > y[2]) return 1;\n  if (x[2] < y[2]) return -1;\n  if (x[1] > y[1]) return 1;\n  if (x[1] < y[1]) return -1;\n  return 0;\n}\n\n//Provides: caml_int64_neg const\nfunction caml_int64_neg (x) {\n  var y1 = - x[1];\n  var y2 = - x[2] + (y1 >> 24);\n  var y3 = - x[3] + (y2 >> 24);\n  return [255, y1 & 0xffffff, y2 & 0xffffff, y3 & 0xffff];\n}\n\n//Provides: caml_int64_add const\nfunction caml_int64_add (x, y) {\n  var z1 = x[1] + y[1];\n  var z2 = x[2] + y[2] + (z1 >> 24);\n  var z3 = x[3] + y[3] + (z2 >> 24);\n  return [255, z1 & 0xffffff, z2 & 0xffffff, z3 & 0xffff];\n}\n\n//Provides: caml_int64_sub const\nfunction caml_int64_sub (x, y) {\n  var z1 = x[1] - y[1];\n  var z2 = x[2] - y[2] + (z1 >> 24);\n  var z3 = x[3] - y[3] + (z2 >> 24);\n  return [255, z1 & 0xffffff, z2 & 0xffffff, z3 & 0xffff];\n}\n\n//Provides: caml_int64_mul const\n//Requires: caml_int64_offset\nfunction caml_int64_mul(x,y) {\n  var z1 = x[1] * y[1];\n  var z2 = ((z1 * caml_int64_offset) | 0) + x[2] * y[1] + x[1] * y[2];\n  var z3 = ((z2 * caml_int64_offset) | 0) + x[3] * y[1] + x[2] * y[2] + x[1] * y[3];\n  return [255, z1 & 0xffffff, z2 & 0xffffff, z3 & 0xffff];\n}\n\n//Provides: caml_int64_is_zero const\nfunction caml_int64_is_zero(x) {\n  return (x[3]|x[2]|x[1]) == 0;\n}\n\n//Provides: caml_int64_is_negative const\nfunction caml_int64_is_negative(x) {\n  return (x[3] << 16) < 0;\n}\n\n//Provides: caml_int64_is_min_int const\nfunction caml_int64_is_min_int(x) {\n  return x[3] == 0x8000 && (x[1]|x[2]) == 0;\n}\n\n//Provides: caml_int64_is_minus_one const\nfunction caml_int64_is_minus_one(x) {\n  return x[3] == 0xffff && (x[1]&x[2]) == 0xffffff;\n}\n\n//Provides: caml_int64_and const\nfunction caml_int64_and (x, y) {\n  return [255, x[1]&y[1], x[2]&y[2], x[3]&y[3]];\n}\n\n//Provides: caml_int64_or const\nfunction caml_int64_or (x, y) {\n  return [255, x[1]|y[1], x[2]|y[2], x[3]|y[3]];\n}\n\n//Provides: caml_int64_xor const\nfunction caml_int64_xor (x, y) {\n  return [255, x[1]^y[1], x[2]^y[2], x[3]^y[3]];\n}\n\n//Provides: caml_int64_shift_left const\nfunction caml_int64_shift_left (x, s) {\n  s = s & 63;\n  if (s == 0) return x;\n  if (s < 24)\n    return [255,\n            (x[1] << s) & 0xffffff,\n            ((x[2] << s) | (x[1] >> (24 - s))) & 0xffffff,\n            ((x[3] << s) | (x[2] >> (24 - s))) & 0xffff];\n  if (s < 48)\n    return [255, 0,\n            (x[1] << (s - 24)) & 0xffffff,\n            ((x[2] << (s - 24)) | (x[1] >> (48 - s))) & 0xffff];\n  return [255, 0, 0, (x[1] << (s - 48)) & 0xffff];\n}\n\n//Provides: caml_int64_shift_right_unsigned const\nfunction caml_int64_shift_right_unsigned (x, s) {\n  s = s & 63;\n  if (s == 0) return x;\n  if (s < 24)\n    return [255,\n            ((x[1] >> s) | (x[2] << (24 - s))) & 0xffffff,\n            ((x[2] >> s) | (x[3] << (24 - s))) & 0xffffff,\n            (x[3] >> s)];\n  if (s < 48)\n    return [255,\n            ((x[2] >> (s - 24)) | (x[3] << (48 - s))) & 0xffffff,\n            (x[3] >> (s - 24)),\n            0];\n  return [255, (x[3] >> (s - 48)), 0, 0];\n}\n\n//Provides: caml_int64_shift_right const\nfunction caml_int64_shift_right (x, s) {\n  s = s & 63;\n  if (s == 0) return x;\n  var h = (x[3] << 16) >> 16;\n  if (s < 24)\n    return [255,\n            ((x[1] >> s) | (x[2] << (24 - s))) & 0xffffff,\n            ((x[2] >> s) | (h << (24 - s))) & 0xffffff,\n            ((x[3] << 16) >> s) >>> 16];\n  var sign = (x[3] << 16) >> 31;\n  if (s < 48)\n    return [255,\n            ((x[2] >> (s - 24)) | (x[3] << (48 - s))) & 0xffffff,\n            ((x[3] << 16) >> (s - 24) >> 16) & 0xffffff,\n            sign & 0xffff];\n  return [255,\n          ((x[3] << 16) >> (s - 32)) & 0xffffff,\n          sign & 0xffffff, sign & 0xffff];\n}\n\n//Provides: caml_int64_lsl1 const\nfunction caml_int64_lsl1 (x) {\n  x[3] = (x[3] << 1) | (x[2] >> 23);\n  x[2] = ((x[2] << 1) | (x[1] >> 23)) & 0xffffff;\n  x[1] = (x[1] << 1) & 0xffffff;\n}\n\n//Provides: caml_int64_lsr1 const\nfunction caml_int64_lsr1 (x) {\n  x[1] = ((x[1] >>> 1) | (x[2] << 23)) & 0xffffff;\n  x[2] = ((x[2] >>> 1) | (x[3] << 23)) & 0xffffff;\n  x[3] = x[3] >>> 1;\n}\n\n//Provides: caml_int64_udivmod const\n//Requires: caml_int64_ucompare, caml_int64_lsl1, caml_int64_lsr1\n//Requires: caml_int64_sub\n//Requires: caml_obj_dup\nfunction caml_int64_udivmod (x, y) {\n  var offset = 0;\n  var modulus = caml_obj_dup(x);\n  var divisor = caml_obj_dup(y);\n  var quotient = [255, 0, 0, 0];\n  while (caml_int64_ucompare (modulus, divisor) > 0) {\n    offset++;\n    caml_int64_lsl1 (divisor);\n  }\n  while (offset >= 0) {\n    offset --;\n    caml_int64_lsl1 (quotient);\n    if (caml_int64_ucompare (modulus, divisor) >= 0) {\n      quotient[1] ++;\n      modulus = caml_int64_sub (modulus, divisor);\n    }\n    caml_int64_lsr1 (divisor);\n  }\n  return [0,quotient, modulus];\n}\n\n//Provides: caml_int64_div const\n//Requires: caml_int64_is_zero, caml_raise_zero_divide\n//Requires: caml_int64_neg, caml_int64_udivmod\nfunction caml_int64_div (x, y)\n{\n  if (caml_int64_is_zero (y)) caml_raise_zero_divide ();\n  var sign = x[3] ^ y[3];\n  if (x[3] & 0x8000) x = caml_int64_neg(x);\n  if (y[3] & 0x8000) y = caml_int64_neg(y);\n  var q = caml_int64_udivmod(x, y)[1];\n  if (sign & 0x8000) q = caml_int64_neg(q);\n  return q;\n}\n\n//Provides: caml_int64_mod const\n//Requires: caml_int64_is_zero, caml_raise_zero_divide\n//Requires: caml_int64_neg, caml_int64_udivmod\nfunction caml_int64_mod (x, y)\n{\n  if (caml_int64_is_zero (y)) caml_raise_zero_divide ();\n  var sign = x[3];\n  if (x[3] & 0x8000) x = caml_int64_neg(x);\n  if (y[3] & 0x8000) y = caml_int64_neg(y);\n  var r = caml_int64_udivmod(x, y)[2];\n  if (sign & 0x8000) r = caml_int64_neg(r);\n  return r;\n}\n\n//Provides: caml_int64_of_int32 const\nfunction caml_int64_of_int32 (x) {\n  return [255, x & 0xffffff, (x >> 24) & 0xffffff, (x >> 31) & 0xffff]\n}\n\n//Provides: caml_int64_to_int32 const\nfunction caml_int64_to_int32 (x) {\n  return x[1] | (x[2] << 24);\n}\n\n//Provides: caml_int64_to_float const\nfunction caml_int64_to_float (x) {\n  return ((x[3] << 16) * Math.pow(2, 32) + x[2] * Math.pow(2, 24)) + x[1];\n}\n\n//Provides: caml_int64_of_float const\n//Requires: caml_int64_offset\nfunction caml_int64_of_float (x) {\n  if (x < 0) x = Math.ceil(x);\n  return [255,\n          x & 0xffffff,\n          Math.floor(x * caml_int64_offset) & 0xffffff,\n          Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff];\n}\n\n//Provides: caml_int64_format const\n//Requires: caml_parse_format, caml_finish_formatting\n//Requires: caml_int64_is_negative, caml_int64_neg\n//Requires: caml_int64_of_int32, caml_int64_udivmod, caml_int64_to_int32\n//Requires: caml_int64_is_zero, caml_str_repeat\nfunction caml_int64_format (fmt, x) {\n  var f = caml_parse_format(fmt);\n  if (f.signedconv && caml_int64_is_negative(x)) {\n    f.sign = -1; x = caml_int64_neg(x);\n  }\n  var buffer = \"\";\n  var wbase = caml_int64_of_int32(f.base);\n  var cvtbl = \"0123456789abcdef\";\n  do {\n    var p = caml_int64_udivmod(x, wbase);\n    x = p[1];\n    buffer = cvtbl.charAt(caml_int64_to_int32(p[2])) + buffer;\n  } while (! caml_int64_is_zero(x));\n  if (f.prec >= 0) {\n    f.filler = ' ';\n    var n = f.prec - buffer.length;\n    if (n > 0) buffer = caml_str_repeat (n, '0') + buffer;\n  }\n  return caml_finish_formatting(f, buffer);\n}\n\n//Provides: caml_int64_of_string\n//Requires: caml_parse_sign_and_base, caml_failwith, caml_parse_digit, MlString\n//Requires: caml_int64_of_int32, caml_int64_udivmod, caml_int64_ult\n//Requires: caml_int64_add, caml_int64_mul, caml_int64_neg\n//Requires: caml_ml_string_length,caml_string_unsafe_get\nfunction caml_int64_of_string(s) {\n  var r = caml_parse_sign_and_base (s);\n  var i = r[0], sign = r[1], base = r[2];\n  var base64 = caml_int64_of_int32(base);\n  var threshold =\n    caml_int64_udivmod([255, 0xffffff, 0xfffffff, 0xffff], base64)[1];\n  var c = caml_string_unsafe_get(s, i);\n  var d = caml_parse_digit(c);\n  if (d < 0 || d >= base) caml_failwith(\"int_of_string\");\n  var res = caml_int64_of_int32(d);\n  for (;;) {\n    i++;\n    c = caml_string_unsafe_get(s, i);\n    if (c == 95) continue;\n    d = caml_parse_digit(c);\n    if (d < 0 || d >= base) break;\n    /* Detect overflow in multiplication base * res */\n    if (caml_int64_ult(threshold, res)) caml_failwith(\"int_of_string\");\n    d = caml_int64_of_int32(d);\n    res = caml_int64_add(caml_int64_mul(base64, res), d);\n    /* Detect overflow in addition (base * res) + d */\n    if (caml_int64_ult(res, d)) caml_failwith(\"int_of_string\");\n  }\n  if (i != caml_ml_string_length(s)) caml_failwith(\"int_of_string\");\n  if (r[2] == 10 && caml_int64_ult([255, 0, 0, 0x8000], res))\n    caml_failwith(\"int_of_string\");\n  if (sign < 0) res = caml_int64_neg(res);\n  return res;\n}\n\n//Provides: caml_int64_of_bytes\nfunction caml_int64_of_bytes(a) {\n  return [255, a[7] | (a[6] << 8) | (a[5] << 16),\n          a[4] | (a[3] << 8) | (a[2] << 16), a[1] | (a[0] << 8)];\n}\n//Provides: caml_int64_to_bytes\nfunction caml_int64_to_bytes(x) {\n  return [x[3] >> 8, x[3] & 0xff, x[2] >> 16, (x[2] >> 8) & 0xff, x[2] & 0xff,\n          x[1] >> 16, (x[1] >> 8) & 0xff, x[1] & 0xff];\n}\n",
  "// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: jsoo_floor_log2\nvar log2_ok = Math.log2 && Math.log2(1.1235582092889474E+307) == 1020\nfunction jsoo_floor_log2(x) {\n    if(log2_ok) return Math.floor(Math.log2(x))\n    var i = 0;\n    if (x == 0) return -Infinity;\n    if(x>=1) {while (x>=2) {x/=2; i++} }\n    else {while (x < 1) {x*=2; i--} };\n    return i;\n}\n\n//Provides: caml_int64_bits_of_float const\n//Requires: jsoo_floor_log2\nfunction caml_int64_bits_of_float (x) {\n  if (!isFinite(x)) {\n    if (isNaN(x)) return [255, 1, 0, 0xfff0];\n    return (x > 0)?[255,0,0,0x7ff0]:[255,0,0,0xfff0];\n  }\n  var sign = (x==0 && 1/x == -Infinity)?0x8000:(x>=0)?0:0x8000;\n  if (sign) x = -x;\n  // Int64.bits_of_float 1.1235582092889474E+307 = 0x7fb0000000000000L\n  // using Math.LOG2E*Math.log(x) in place of Math.log2 result in precision lost\n  var exp = jsoo_floor_log2(x) + 1023;\n  if (exp <= 0) {\n    exp = 0;\n    x /= Math.pow(2,-1026);\n  } else {\n    x /= Math.pow(2,exp-1027);\n    if (x < 16) {\n      x *= 2; exp -=1; }\n    if (exp == 0) {\n      x /= 2; }\n  }\n  var k = Math.pow(2,24);\n  var r3 = x|0;\n  x = (x - r3) * k;\n  var r2 = x|0;\n  x = (x - r2) * k;\n  var r1 = x|0;\n  r3 = (r3 &0xf) | sign | exp << 4;\n  return [255, r1, r2, r3];\n}\n\n//Provides: caml_int32_bits_of_float const\n//Requires: jsoo_floor_log2\nfunction caml_int32_bits_of_float (x) {\n  var float32a = new joo_global_object.Float32Array(1);\n  float32a[0] = x;\n  var int32a = new joo_global_object.Int32Array(float32a.buffer);\n  return int32a[0] | 0;\n}\n\n//FP literals can be written using the hexadecimal\n//notation 0x<mantissa in hex>p<exponent> from ISO C99.\n//https://github.com/dankogai/js-hexfloat/blob/master/hexfloat.js\n//Provides: caml_hexstring_of_float const\n//Requires: caml_js_to_string, caml_str_repeat\nfunction caml_hexstring_of_float (x, prec, style) {\n  if (!isFinite(x)) {\n    if (isNaN(x)) return caml_js_to_string(\"nan\");\n    return caml_js_to_string ((x > 0)?\"infinity\":\"-infinity\");\n  }\n  var sign = (x==0 && 1/x == -Infinity)?1:(x>=0)?0:1;\n  if(sign) x = -x;\n  var exp = 0;\n  if (x == 0) { }\n  else if (x < 1) {\n    while (x < 1 && exp > -1022)  { x *= 2; exp-- }\n  } else {\n    while (x >= 2) { x /= 2; exp++ }\n  }\n  var exp_sign = exp < 0 ? '' : '+';\n  var sign_str = '';\n  if (sign) sign_str = '-'\n  else {\n    switch(style){\n    case 43 /* '+' */: sign_str = '+'; break;\n    case 32 /* ' ' */: sign_str = ' '; break;\n    default: break;\n    }\n  }\n  if (prec >= 0 && prec < 13) {\n    /* If a precision is given, and is small, round mantissa accordingly */\n      var cst = Math.pow(2,prec * 4);\n      x = Math.round(x * cst) / cst;\n  }\n  var x_str = x.toString(16);\n  if(prec >= 0){\n      var idx = x_str.indexOf('.');\n    if(idx<0) {\n      x_str += '.' + caml_str_repeat(prec, '0');\n    }\n    else {\n      var size = idx+1+prec;\n      if(x_str.length < size)\n        x_str += caml_str_repeat(size - x_str.length, '0');\n      else\n        x_str = x_str.substr(0,size);\n    }\n  }\n  return caml_js_to_string (sign_str + '0x' + x_str + 'p' + exp_sign + exp.toString(10));\n}\n\n//Provides: caml_int64_float_of_bits const\nfunction caml_int64_float_of_bits (x) {\n  var exp = (x[3] & 0x7fff) >> 4;\n  if (exp == 2047) {\n      if ((x[1]|x[2]|(x[3]&0xf)) == 0)\n        return (x[3] & 0x8000)?(-Infinity):Infinity;\n      else\n        return NaN;\n  }\n  var k = Math.pow(2,-24);\n  var res = (x[1]*k+x[2])*k+(x[3]&0xf);\n  if (exp > 0) {\n    res += 16;\n    res *= Math.pow(2,exp-1027);\n  } else\n    res *= Math.pow(2,-1026);\n  if (x[3] & 0x8000) res = - res;\n  return res;\n}\n\n//Provides: caml_int32_float_of_bits const\nfunction caml_int32_float_of_bits (x) {\n  var int32a = new joo_global_object.Int32Array(1);\n  int32a[0] = x;\n  var float32a = new joo_global_object.Float32Array(int32a.buffer);\n  return float32a[0];\n}\n\n//Provides: caml_classify_float const\nfunction caml_classify_float (x) {\n  if (isFinite (x)) {\n    if (Math.abs(x) >= 2.2250738585072014e-308) return 0;\n    if (x != 0) return 1;\n    return 2;\n  }\n  return isNaN(x)?4:3;\n}\n//Provides: caml_modf_float const\nfunction caml_modf_float (x) {\n  if (isFinite (x)) {\n    var neg = (1/x) < 0;\n    x = Math.abs(x);\n    var i = Math.floor (x);\n    var f = x - i;\n    if (neg) { i = -i; f = -f; }\n    return [0, f, i];\n  }\n  if (isNaN (x)) return [0, NaN, NaN];\n  return [0, 1/x, x];\n}\n//Provides: caml_ldexp_float const\nfunction caml_ldexp_float (x,exp) {\n  exp |= 0;\n  if (exp > 1023) {\n    exp -= 1023;\n    x *= Math.pow(2, 1023);\n    if (exp > 1023) {  // in case x is subnormal\n      exp -= 1023;\n      x *= Math.pow(2, 1023);\n    }\n  }\n  if (exp < -1023) {\n    exp += 1023;\n    x *= Math.pow(2, -1023);\n  }\n  x *= Math.pow(2, exp);\n  return x;\n}\n//Provides: caml_frexp_float const\n//Requires: jsoo_floor_log2\nfunction caml_frexp_float (x) {\n  if ((x == 0) || !isFinite(x)) return [0, x, 0];\n  var neg = x < 0;\n  if (neg) x = - x;\n  var exp = jsoo_floor_log2(x) + 1;\n  x *= Math.pow(2,-exp);\n  if (x < 0.5) { x *= 2; exp -= 1; }\n  if (neg) x = - x;\n  return [0, x, exp];\n}\n\n//Provides: caml_float_compare const\nfunction caml_float_compare (x, y) {\n  if (x === y) return 0;\n  if (x < y) return -1;\n  if (x > y) return 1;\n  if (x === x) return 1;\n  if (y === y) return -1;\n  return 0;\n}\n\n//Provides: caml_copysign_float const\nfunction caml_copysign_float (x, y) {\n  if (y == 0) y = 1 / y;\n  x = Math.abs(x);\n  return (y < 0)?(-x):x;\n}\n\n//Provides: caml_expm1_float const\nfunction caml_expm1_float (x) {\n  var y = Math.exp(x), z = y - 1;\n  return (Math.abs(x)>1?z:(z==0?x:x*z/Math.log(y)));\n}\n\n//Provides: caml_log1p_float const\nfunction caml_log1p_float (x) {\n  var y = 1 + x, z = y - 1;\n  return (z==0?x:x*Math.log(y)/z);\n}\n\n//Provides: caml_hypot_float const\nfunction caml_hypot_float (x, y) {\n  var x = Math.abs(x), y = Math.abs(y);\n  var a = Math.max(x, y), b = Math.min(x,y) / (a?a:1);\n  return (a * Math.sqrt(1 + b*b));\n}\n\n// FIX: these five functions only give approximate results.\n//Provides: caml_log10_float const\nfunction caml_log10_float (x) { return Math.LOG10E * Math.log(x); }\n//Provides: caml_cosh_float const\nfunction caml_cosh_float (x) { return (Math.exp(x) + Math.exp(-x)) / 2; }\n//Provides: caml_sinh_float const\nfunction caml_sinh_float (x) { return (Math.exp(x) - Math.exp(-x)) / 2; }\n//Provides: caml_tanh_float const\nfunction caml_tanh_float (x) {\n  var y = Math.exp(x), z = Math.exp(-x);\n  return (y + z) / (y - z);\n}\n",
  "// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard, Andy Ray\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n//\n// Bigarray.\n//\n// - all bigarray types including Int64 and Complex.\n// - fortran + c layouts\n// - sub/slice/reshape\n// - retain fast path for 1d array access\n//\n// Note; int64+complex support if provided by allocating a second TypedArray\n// Note; accessor functions are selected when the bigarray is created.  It is assumed\n//       that this results in just a function pointer and will thus be fast.\n\n//Provides: caml_ba_init const\nfunction caml_ba_init() {\n    return 0;\n}\n\n//Provides: caml_ba_init_views\n//Requires: caml_ba_views\nfunction caml_ba_init_views() {\n    if (!caml_ba_views) {\n        var g = joo_global_object;\n        caml_ba_views = [\n            [\n                g.Float32Array, g.Float64Array, g.Int8Array, g.Uint8Array,\n                g.Int16Array, g.Uint16Array, g.Int32Array, g.Int32Array,\n                g.Int32Array, g.Int32Array, g.Float32Array, g.Float64Array, g.Uint8Array],\n            [\n                0 /* General */, 0 /* General */, 0 /* General */, 0 /* General */,\n                0 /* General */, 0 /* General */, 0 /* General */, 1 /* Int64 */,\n                0 /* General */, 0 /* General */, 2 /* Complex */, 2 /* Complex */, 0 /* General */]\n        ];\n    }\n}\n\n//Provides: caml_ba_get_size\n//Requires: caml_invalid_argument\nfunction caml_ba_get_size(dims) {\n    var n_dims = dims.length;\n    var size = 1;\n    for (var i = 0; i < n_dims; i++) {\n        if (dims[i] < 0)\n            caml_invalid_argument(\"Bigarray.create: negative dimension\");\n        size = size * dims[i];\n    }\n    return size;\n}\n\n//Provides: caml_ba_views\nvar caml_ba_views;\n\n//Provides: caml_ba_create_from\n//Requires: caml_ba_get_size\n//Requires: caml_invalid_argument\n//Requires: caml_array_bound_error\nfunction caml_ba_create_from(data, data2, data_type, kind, layout, dims) {\n    var n_dims = dims.length;\n    var size = caml_ba_get_size(dims);\n\n    //\n    // Functions to compute the offsets for C or Fortran layout arrays\n    // from the given array of indices.\n    //\n    function offset_c(index) {\n        var ofs = 0;\n        if (n_dims != index.length)\n            caml_invalid_argument(\"Bigarray.get/set: bad number of dimensions\");\n        for (var i = 0; i < n_dims; i++) {\n            if (index[i] < 0 || index[i] >= dims[i])\n                caml_array_bound_error();\n            ofs = (ofs * dims[i]) + index[i];\n        }\n        return ofs;\n    }\n\n    function offset_fortran(index) {\n        var ofs = 0;\n        if (n_dims != index.length)\n            caml_invalid_argument(\"Bigarray.get/set: wrong number of indices\");\n        for (var i = n_dims - 1; i >= 0; i--) {\n            if (index[i] < 1 || index[i] > dims[i])\n                caml_array_bound_error();\n            ofs = (ofs * dims[i]) + (index[i] - 1);\n        }\n        return ofs;\n    }\n\n    var offset = layout == 0 ? offset_c : offset_fortran;\n\n    var dim0 = dims[0];\n\n    //\n    // Element get functions.\n    //\n    function get_std(index) {\n        var ofs = offset(index);\n        var v = data[ofs];\n        return v;\n    }\n\n    function get_int64(index) {\n        var off = offset(index);\n        var l = data[off];\n        var h = data2[off];\n        return [\n            255,\n            l & 0xffffff,\n            ((l >>> 24) & 0xff) | ((h & 0xffff) << 8),\n            (h >>> 16) & 0xffff];\n    }\n\n    function get_complex(index) {\n        var off = offset(index);\n        var r = data[off];\n        var i = data2[off];\n        return [254, r, i];\n    }\n\n    var get = data_type == 1 /* Int64 */ ? get_int64 : (data_type == 2 /* Complex */ ? get_complex : get_std);\n\n    function get1_c(i) {\n        if (i < 0 || i >= dim0)\n            caml_array_bound_error();\n        return data[i];\n    }\n    function get1_fortran(i) {\n        if (i < 1 || i > dim0)\n            caml_array_bound_error();\n        return data[i - 1];\n    }\n    function get1_any(i) {\n        return get([i]);\n    }\n\n    var get1 = data_type == 0 /* General */ ? (layout == 0 ? get1_c : get1_fortran) : get1_any;\n\n    //\n    // Element set functions\n    //\n    function set_std_raw(off, v) {\n        data[off] = v;\n    }\n\n    function set_int64_raw(off, v) {\n        data[off] = v[1] | ((v[2] & 0xff) << 24);\n        data2[off] = ((v[2] >>> 8) & 0xffff) | (v[3] << 16);\n    }\n\n    function set_complex_raw(off, v) {\n        data[off] = v[1];\n        data2[off] = v[2];\n    }\n\n    function set_std(index, v) {\n        var ofs = offset(index);\n        return set_std_raw(ofs, v);\n    }\n    function set_int64(index, v) {\n        return set_int64_raw(offset(index), v);\n    }\n    function set_complex(index, v) {\n        return set_complex_raw(offset(index), v);\n    }\n\n    var set = data_type == 1 /* Int64 */ ? set_int64 : (data_type == 2 /* Complex */ ? set_complex : set_std);\n\n    function set1_c(i, v) {\n        if (i < 0 || i >= dim0)\n            caml_array_bound_error();\n        data[i] = v;\n    }\n    function set1_fortran(i, v) {\n        if (i < 1 || i > dim0)\n            caml_array_bound_error();\n        data[i - 1] = v;\n    }\n    function set1_any(i, v) {\n        set([i], v);\n    }\n\n    var set1 = data_type == 0 /* General */ ? (layout == 0 ? set1_c : set1_fortran) : set1_any;\n\n    //\n    // other\n    //\n    function nth_dim(i) {\n        if (i < 0 || i >= n_dims)\n            caml_invalid_argument(\"Bigarray.dim\");\n        return dims[i];\n    }\n\n    function fill(v) {\n        if (data_type == 0 /* General */)\n            for (var i = 0; i < data.length; i++)\n                set_std_raw(i, v);\n        if (data_type == 1 /* Int64 */)\n            for (var i = 0; i < data.length; i++)\n                set_int64_raw(i, v);\n        if (data_type == 2 /* Complex */)\n            for (var i = 0; i < data.length; i++)\n                set_complex_raw(i, v);\n    }\n    function blit(from) {\n        if (n_dims != from.num_dims)\n            caml_invalid_argument(\"Bigarray.blit: dimension mismatch\");\n        for (var i = 0; i < n_dims; i++)\n            if (dims[i] != from.nth_dim(i))\n                caml_invalid_argument(\"Bigarray.blit: dimension mismatch\");\n        data.set(from.data);\n        if (data_type != 0 /* General */)\n            data2.set(from.data2);\n    }\n\n    function sub(ofs, len) {\n        var changed_dim;\n        var mul = 1;\n\n        if (layout == 0) {\n            for (var i = 1; i < n_dims; i++)\n                mul = mul * dims[i];\n            changed_dim = 0;\n        } else {\n            for (var i = 0; i < (n_dims - 1); i++)\n                mul = mul * dims[i];\n            changed_dim = n_dims - 1;\n            ofs = ofs - 1;\n        }\n\n        if (ofs < 0 || len < 0 || (ofs + len) > dims[changed_dim])\n            caml_invalid_argument(\"Bigarray.sub: bad sub-array\");\n\n        var new_data = data.subarray(ofs * mul, (ofs + len) * mul);\n        var new_data2 = data_type == 0 /* General */ ? null : data2.subarray(ofs * mul, (ofs + len) * mul);\n\n        var new_dims = [];\n        for (var i = 0; i < n_dims; i++)\n            new_dims[i] = dims[i];\n        new_dims[changed_dim] = len;\n\n        return caml_ba_create_from(new_data, new_data2, data_type, kind, layout, new_dims);\n    }\n\n    function slice(vind) {\n        var num_inds = vind.length;\n        var index = [];\n        var sub_dims = [];\n        var ofs;\n\n        if (num_inds >= n_dims)\n            caml_invalid_argument(\"Bigarray.slice: too many indices\");\n\n        // Compute offset and check bounds\n        if (layout == 0) {\n            for (var i = 0; i < num_inds; i++)\n                index[i] = vind[i];\n            for (; i < n_dims; i++)\n                index[i] = 0;\n            ofs = offset(index);\n            sub_dims = dims.slice(num_inds);\n        } else {\n            for (var i = 0; i < num_inds; i++)\n                index[n_dims - num_inds + i] = vind[i];\n            for (var i = 0; i < n_dims - num_inds; i++)\n                index[i] = 1;\n            ofs = offset(index);\n            sub_dims = dims.slice(0, num_inds);\n        }\n\n        var size = caml_ba_get_size(sub_dims);\n        var new_data = data.subarray(ofs, ofs + size);\n        var new_data2 = data_type == 0 /* General */ ? null : data2.subarray(ofs, ofs + size);\n\n        return caml_ba_create_from(new_data, new_data2, data_type, kind, layout, sub_dims);\n    }\n\n    function reshape(vdim) {\n        var new_dim = [];\n        var num_dims = vdim.length;\n\n        if (num_dims < 1)\n            caml_invalid_argument(\"Bigarray.reshape: bad number of dimensions\");\n        var num_elts = 1;\n        for (var i = 0; i < num_dims; i++) {\n            new_dim[i] = vdim[i];\n            if (new_dim[i] < 0)\n                caml_invalid_argument(\"Bigarray.reshape: negative dimension\");\n            num_elts = num_elts * new_dim[i];\n        }\n\n        // Check that sizes agree\n        if (num_elts != size)\n            caml_invalid_argument(\"Bigarray.reshape: size mismatch\");\n\n        return caml_ba_create_from(data, data2, data_type, kind, layout, new_dim);\n    }\n\n    function compare(b, total) {\n        if (layout != b.layout)\n            return b.layout - layout;\n        if (n_dims != b.num_dims)\n            return b.num_dims - n_dims;\n        for (var i = 0; i < n_dims; i++)\n            if (nth_dim(i) != b.nth_dim(i))\n                return (nth_dim(i) < b.nth_dim(i)) ? -1 : 1;\n        switch (kind) {\n            case 0:\n            case 1:\n            case 10:\n            case 11:\n                var x, y;\n                for (var i = 0; i < data.length; i++) {\n                    x = data[i];\n                    y = b.data[i];\n\n                    //first array\n                    if (x < y)\n                        return -1;\n                    if (x > y)\n                        return 1;\n                    if (x != y) {\n                        if (x != y) {\n                            if (!total)\n                                return NaN;\n                            if (x == x)\n                                return 1;\n                            if (y == y)\n                                return -1;\n                        }\n                    }\n                    if (data2) {\n                        //second array\n                        x = data2[i];\n                        y = b.data2[i];\n                        if (x < y)\n                            return -1;\n                        if (x > y)\n                            return 1;\n                        if (x != y) {\n                            if (x != y) {\n                                if (!total)\n                                    return NaN;\n                                if (x == x)\n                                    return 1;\n                                if (y == y)\n                                    return -1;\n                            }\n                        }\n                    }\n                }\n                ;\n                break;\n\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 8:\n            case 9:\n            case 12:\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] < b.data[i])\n                        return -1;\n                    if (data[i] > b.data[i])\n                        return 1;\n                }\n                ;\n                break;\n\n            case 7:\n                for (var i = 0; i < data.length; i++) {\n                    if (data2[i] < b.data2[i])\n                        return -1;\n                    if (data2[i] > b.data2[i])\n                        return 1;\n                    if (data[i] < b.data[i])\n                        return -1;\n                    if (data[i] > b.data[i])\n                        return 1;\n                }\n                ;\n                break;\n        }\n        return 0;\n    }\n\n    return {\n        data: data,\n        data2: data2,\n        data_type: data_type,\n        num_dims: n_dims,\n        nth_dim: nth_dim,\n        kind: kind,\n        layout: layout,\n        size: size,\n        sub: sub,\n        slice: slice,\n        blit: blit,\n        fill: fill,\n        reshape: reshape,\n        get: get,\n        get1: get1,\n        set: set,\n        set1: set1,\n        compare: compare\n    };\n}\n\n//Provides: caml_ba_create\n//Requires: caml_ba_create_from\n//Requires: caml_js_from_array\n//Requires: caml_ba_views\n//Requires: caml_ba_init_views\n//Requires: caml_invalid_argument\n//Requires: caml_ba_get_size\nfunction caml_ba_create(kind, layout, dims_ml) {\n    // Initialize TypedArray views\n    caml_ba_init_views();\n\n    // set up dimensions and calculate size\n    var dims = caml_js_from_array(dims_ml);\n\n    //var n_dims = dims.length;\n    var size = caml_ba_get_size(dims);\n\n    // Allocate TypedArray\n    var view = caml_ba_views[0][kind];\n    if (!view)\n        caml_invalid_argument(\"Bigarray.create: unsupported kind\");\n    var data = new view(size);\n\n    // 2nd TypedArray for int64, complex32 and complex64\n    var data_type = caml_ba_views[1][kind];\n    var data2 = null;\n    if (data_type != 0 /* General */) {\n        data2 = new view(size);\n    }\n\n    return caml_ba_create_from(data, data2, data_type, kind, layout, dims);\n}\n\n//Provides: caml_ba_kind\nfunction caml_ba_kind(ba) {\n    return ba.kind;\n}\n\n//Provides: caml_ba_layout\nfunction caml_ba_layout(ba) {\n    return ba.layout;\n}\n\n//Provides: caml_ba_num_dims\nfunction caml_ba_num_dims(ba, _dim) {\n    return ba.num_dims;\n}\n\n//Provides: caml_ba_dim\nfunction caml_ba_dim(ba, dim) {\n    return ba.nth_dim(dim);\n}\n\n//Provides: caml_ba_dim_1\nfunction caml_ba_dim_1(ba) {\n    return ba.nth_dim(0);\n}\n\n//Provides: caml_ba_dim_2\nfunction caml_ba_dim_2(ba) {\n    return ba.nth_dim(1);\n}\n\n//Provides: caml_ba_dim_3\nfunction caml_ba_dim_3(ba) {\n    return ba.nth_dim(2);\n}\n\n//Provides: caml_ba_get_generic\n//Requires: caml_js_from_array\nfunction caml_ba_get_generic(ba, index) {\n    return ba.get(caml_js_from_array(index));\n}\n\n//Provides: caml_ba_uint8_get16\nfunction caml_ba_uint8_get16(ba, i0) {\n    var b1 = ba.get1(i0);\n    var b2 = ba.get1(i0+1) << 8;\n    return (b1 | b2);\n}\n\n//Provides: caml_ba_uint8_get32\nfunction caml_ba_uint8_get32(ba, i0) {\n    var b1 = ba.get1(i0);\n    var b2 = ba.get1(i0+1) << 8;\n    var b3 = ba.get1(i0+2) << 16;\n    var b4 = ba.get1(i0+3) << 24;\n    return (b1 | b2 | b3 | b4);\n}\n\n//Provides: caml_ba_uint8_get64\nfunction caml_ba_uint8_get64(ba, i0) {\n    var b1 = ba.get1(i0);\n    var b2 = ba.get1(i0+1) << 8;\n    var b3 = ba.get1(i0+2) << 16;\n    var b4 = ba.get1(i0+3);\n    var b5 = ba.get1(i0+4) << 8;\n    var b6 = ba.get1(i0+5) << 16;\n    var b7 = ba.get1(i0+6);\n    var b8 = ba.get1(i0+7) << 8;\n    return [255, b1 | b2 | b3, b4 | b5 | b6, b7 | b8 ];\n}\n\n//Provides: caml_ba_get_1\nfunction caml_ba_get_1(ba, i0) {\n    return ba.get1(i0);\n}\n\n//Provides: caml_ba_get_2\nfunction caml_ba_get_2(ba, i0, i1) {\n    return ba.get([i0, i1]);\n}\n\n//Provides: caml_ba_get_3\nfunction caml_ba_get_3(ba, i0, i1, i2) {\n    return ba.get([i0, i1, i2]);\n}\n\n//Provides: caml_ba_set_generic\n//Requires: caml_js_from_array\nfunction caml_ba_set_generic(ba, index, v) {\n    return ba.set(caml_js_from_array(index), v);\n}\n\n//Provides: caml_ba_uint8_set16\nfunction caml_ba_uint8_set16(ba, i0, v) {\n    ba.set1(i0, v & 0xff);\n    ba.set1(i0+1, (v >>> 8) & 0xff);\n    return 0;\n}\n\n//Provides: caml_ba_uint8_set32\nfunction caml_ba_uint8_set32(ba, i0, v) {\n    ba.set1(i0, v & 0xff);\n    ba.set1(i0+1, (v >>> 8) & 0xff);\n    ba.set1(i0+2, (v >>> 16) & 0xff);\n    ba.set1(i0+3, (v >>> 24) & 0xff);\n    return 0;\n}\n\n//Provides: caml_ba_uint8_set64\nfunction caml_ba_uint8_set64(ba, i0, v) {\n    ba.set1(i0, v[1] & 0xff);\n    ba.set1(i0+1, (v[1] >> 8) & 0xff);\n    ba.set1(i0+2, v[1] >> 16);\n    ba.set1(i0+3, v[2] & 0xff);\n    ba.set1(i0+4, (v[2] >> 8) & 0xff);\n    ba.set1(i0+5, v[2] >> 16);\n    ba.set1(i0+6, v[3] & 0xff);\n    ba.set1(i0+7, v[3] >> 8);\n    return 0;\n}\n\n//Provides: caml_ba_set_1\nfunction caml_ba_set_1(ba, i0, v) {\n    return ba.set1(i0, v);\n}\n\n//Provides: caml_ba_set_2\nfunction caml_ba_set_2(ba, i0, i1, v) {\n    return ba.set([i0, i1], v);\n}\n\n//Provides: caml_ba_set_3\nfunction caml_ba_set_3(ba, i0, i1, i2, v) {\n    return ba.set([i0, i1, i2], v);\n}\n\n//Provides: caml_ba_blit\nfunction caml_ba_blit(src, dst) {\n    dst.blit(src);\n    return 0;\n}\n\n//Provides: caml_ba_fill\nfunction caml_ba_fill(ba, init) {\n    ba.fill(init);\n    return 0;\n}\n\n//Provides: caml_ba_sub\nfunction caml_ba_sub(ba, ofs, len) {\n    return ba.sub(ofs, len);\n}\n\n//Provides: caml_ba_slice\n//Requires: caml_js_from_array\nfunction caml_ba_slice(ba, vind) {\n    return ba.slice(caml_js_from_array(vind));\n}\n\n//Provides: caml_ba_reshape\n//Requires: caml_js_from_array\nfunction caml_ba_reshape(ba, vind) {\n    return ba.reshape(caml_js_from_array(vind));\n}\n",
  "///////// BIGSTRING\n//Provides: bigstring_alloc\n//Requires: caml_ba_create\nfunction bigstring_alloc(_,size){\n  return caml_ba_create(12, 0, [0,size]);\n}\n\n//Provides: bigstring_destroy_stub\nfunction bigstring_destroy_stub(_v) {\n  return 0; // noop\n}\n\n//Provides: bigstring_blit_bigstring_string_stub\n//Requires: caml_string_set, caml_ba_get_1\nfunction bigstring_blit_bigstring_string_stub(v_bstr, v_src_pos, v_str, v_dst_pos, v_len){\n  for (var i = 0; i < v_len; i++) caml_string_set(v_str,v_dst_pos + i,caml_ba_get_1(v_bstr,v_src_pos + i));\n  return 0;\n}\n\n//Provides: caml_blit_bigstring_to_string\n//Requires: bigstring_blit_bigstring_string_stub\nvar caml_blit_bigstring_to_string = bigstring_blit_bigstring_string_stub\n\n//Provides: bigstring_blit_string_bigstring_stub\n//Requires: caml_string_get, caml_ba_set_1\nfunction bigstring_blit_string_bigstring_stub(v_str, v_src_pos, v_bstr, v_dst_pos, v_len){\n  for (var i = 0; i < v_len; i++) caml_ba_set_1(v_bstr,v_dst_pos + i,caml_string_get(v_str,v_src_pos + i));\n  return 0;\n}\n\n//Provides: caml_blit_string_to_bigstring\n//Requires: bigstring_blit_string_bigstring_stub\nvar caml_blit_string_to_bigstring = bigstring_blit_string_bigstring_stub\n\n//Provides: bigstring_blit_stub\n//Requires: caml_ba_get_1, caml_ba_set_1\nfunction bigstring_blit_stub(s1, i1, s2, i2, len){\n  for (var i = 0; i < len; i++) caml_ba_set_1(s2,i2 + i,caml_ba_get_1(s1,i1 + i));\n  return 0;\n}\n\n//Provides: bigstring_memcmp_stub\n//Requires: caml_ba_get_1\nfunction bigstring_memcmp_stub(v_s1, v_s1_pos, v_s2, v_s2_pos, v_len){\n  for (var i = 0; i < v_len; i++) {\n    var a = caml_ba_get_1(v_s1,v_s1_pos + i);\n    var b = caml_ba_get_1(v_s2,v_s2_pos + i);\n    if (a < b) return -1;\n    if (a > b) return 1;\n  }\n  return 0;\n}\n\n//Provides: bigstring_find\n//Requires: caml_ba_get_1\nfunction bigstring_find(bs, chr, pos, len){\n  while(len > 0){\n    if(caml_ba_get_1(bs,pos) == chr) return pos;\n    pos++;\n    len--;\n  }\n  return -1;\n}\n\n//Provides: bigstring_to_array_buffer mutable\nfunction bigstring_to_array_buffer(bs) {\n  return bs.data.buffer\n}\n\n//Provides: bigstring_of_array_buffer mutable\n//Requires: caml_ba_create_from\nfunction bigstring_of_array_buffer(ab) {\n  var ta = new joo_global_object.Uint8Array(ab);\n  return caml_ba_create_from(ta, null, 0, 12, 0, [ta.length])\n}\n\n//Provides: bigstring_marshal_data_size_stub mutable\n//Requires: caml_failwith, caml_ba_uint8_get32\nfunction bigstring_marshal_data_size_stub (s, ofs) {\n  if (caml_ba_uint8_get32(s, ofs) != (0x8495A6BE|0))\n    caml_failwith(\"Marshal.data_size: bad object\");\n  return (caml_ba_uint8_get32(s, ofs + 4));\n}\n\n//Provides: bigstring_unmarshal_stub mutable\n//Requires: BigStringReader, caml_input_value_from_reader\nfunction bigstring_unmarshal_stub(s,ofs) {\n  var reader = new BigStringReader (s, typeof ofs==\"number\"?ofs:ofs[0]);\n  return caml_input_value_from_reader(reader, ofs)\n}\n\n\n//Provides: bigstring_marshal_stub mutable\n//Requires: caml_output_val, bigstring_alloc, caml_ba_set_1\nfunction bigstring_marshal_stub (v, _fl) {\n  /* ignores flags... */\n  var arr = caml_output_val (v);\n  var bs  = bigstring_alloc(0,arr.length);\n  for(var i = 0; i < arr.length; i++){\n    caml_ba_set_1(bs, i, arr[i]);\n  }\n  return bs;\n}\n\n//Provides: bigstring_marshal_blit_stub\n//Requires: caml_output_val, caml_failwith, caml_ba_set_1\nfunction bigstring_marshal_blit_stub (s, ofs, len, v, _fl) {\n  /* ignores flags... */\n  var t = caml_output_val (v);\n  if (t.length > len) caml_failwith (\"Marshal.to_buffer: buffer overflow\");\n  for(var i = 0; i < t.length; i++){\n    caml_ba_set_1(s, (i + ofs), t[i]);\n  }\n  return t.length;\n}\n",
  "// Js_of_ocaml library\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Jslib\n\n//Provides: caml_js_pure_expr const\nfunction caml_js_pure_expr (f) { return f(); }\n\n//Provides: caml_js_set (mutable, const, const)\nfunction caml_js_set(o,f,v) { o[f]=v;return 0}\n//Provides: caml_js_get mutable (const, const)\nfunction caml_js_get(o,f) { return o[f]; }\n//Provides: caml_js_delete (mutable, const)\nfunction caml_js_delete(o,f) { delete o[f]; return 0}\n\n//Provides: caml_js_instanceof (const, const)\nfunction caml_js_instanceof(o,c) { return o instanceof c; }\n\n//Provides: caml_js_typeof (const)\nfunction caml_js_typeof(o) { return typeof o; }\n\n//Provides: caml_js_on_ie const\nfunction caml_js_on_ie () {\n  var ua =\n    joo_global_object.navigator?joo_global_object.navigator.userAgent:\"\";\n  return ua.indexOf(\"MSIE\") != -1 && ua.indexOf(\"Opera\") != 0;\n}\n\n//Provides: caml_js_html_escape const (const)\nvar caml_js_regexps = { amp:/&/g, lt:/</g, quot:/\\\"/g, all:/[&<\\\"]/ };\nfunction caml_js_html_escape (s) {\n  if (!caml_js_regexps.all.test(s)) return s;\n  return s.replace(caml_js_regexps.amp, \"&amp;\")\n          .replace(caml_js_regexps.lt, \"&lt;\")\n          .replace(caml_js_regexps.quot, \"&quot;\");\n}\n\n//Provides: caml_js_html_entities const (const)\nfunction caml_js_html_entities(s) {\n    var str, temp = document.createElement('p');\n    temp.innerHTML= s;\n    str= temp.textContent || temp.innerText;\n    temp=null;\n    return str;\n}\n\n/////////// Debugging console\n//Provides: caml_js_get_console const\nfunction caml_js_get_console () {\n  var c = joo_global_object.console?joo_global_object.console:{};\n  var m = [\"log\", \"debug\", \"info\", \"warn\", \"error\", \"assert\", \"dir\", \"dirxml\",\n           \"trace\", \"group\", \"groupCollapsed\", \"groupEnd\", \"time\", \"timeEnd\"];\n  function f () {}\n  for (var i = 0; i < m.length; i++) if (!c[m[i]]) c[m[i]]=f;\n  return c;\n}\n\n//Provides:caml_trampoline\nfunction caml_trampoline(res) {\n  var c = 1;\n  while(res && res.joo_tramp){\n    res = res.joo_tramp.apply(null, res.joo_args);\n    c++;\n  }\n  //if(c>10) joo_global_object.console.log(\"trampoline \", c, \"times\")\n  return res;\n}\n\n//Provides:caml_trampoline_return\nfunction caml_trampoline_return(f,args) {\n  return {joo_tramp:f,joo_args:args};\n}\n\n//Provides: js_print_stdout (const)\nfunction js_print_stdout(s) {\n  var g = joo_global_object;\n  if (g.process && g.process.stdout && g.process.stdout.write) {\n    g.process.stdout.write(s)\n  } else {\n  // Do not output the last \\n if present\n  // as console logging display a newline at the end\n  if(s.charCodeAt(s.length - 1) == 10)\n    s = s.substr(0,s.length - 1 );\n  var v = g.console;\n  v  && v.log && v.log(s);\n  }\n}\n//Provides: js_print_stderr (const)\nfunction js_print_stderr(s) {\n  var g = joo_global_object;\n  if (g.process && g.process.stdout && g.process.stdout.write) {\n    g.process.stderr.write(s)\n  } else {\n  // Do not output the last \\n if present\n  // as console logging display a newline at the end\n  if(s.charCodeAt(s.length - 1) == 10)\n    s = s.substr(0,s.length - 1 );\n  var v = g.console;\n  v && v.error && v.error(s);\n  }\n}\n",
  "// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_marshal_constants\nvar caml_marshal_constants = {\n  PREFIX_SMALL_BLOCK:         0x80,\n  PREFIX_SMALL_INT:           0x40,\n  PREFIX_SMALL_STRING:        0x20,\n  CODE_INT8:                  0x00,\n  CODE_INT16:                 0x01,\n  CODE_INT32:                 0x02,\n  CODE_INT64:                 0x03,\n  CODE_SHARED8:               0x04,\n  CODE_SHARED16:              0x05,\n  CODE_SHARED32:              0x06,\n  CODE_BLOCK32:               0x08,\n  CODE_BLOCK64:               0x13,\n  CODE_STRING8:               0x09,\n  CODE_STRING32:              0x0A,\n  CODE_DOUBLE_BIG:            0x0B,\n  CODE_DOUBLE_LITTLE:         0x0C,\n  CODE_DOUBLE_ARRAY8_BIG:     0x0D,\n  CODE_DOUBLE_ARRAY8_LITTLE:  0x0E,\n  CODE_DOUBLE_ARRAY32_BIG:    0x0F,\n  CODE_DOUBLE_ARRAY32_LITTLE: 0x07,\n  CODE_CODEPOINTER:           0x10,\n  CODE_INFIXPOINTER:          0x11,\n  CODE_CUSTOM:                0x12\n}\n\n\n//Provides: MlStringReader\n//Requires: caml_new_string, caml_bytes_of_string\nfunction MlStringReader (s, i) { this.s = caml_bytes_of_string(s); this.i = i; }\nMlStringReader.prototype = {\n  read8u:function () { return this.s.charCodeAt(this.i++); },\n  read8s:function () { return this.s.charCodeAt(this.i++) << 24 >> 24; },\n  read16u:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 2;\n    return (s.charCodeAt(i) << 8) | s.charCodeAt(i + 1)\n  },\n  read16s:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 2;\n    return (s.charCodeAt(i) << 24 >> 16) | s.charCodeAt(i + 1);\n  },\n  read32u:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 4;\n    return ((s.charCodeAt(i) << 24) | (s.charCodeAt(i+1) << 16) |\n            (s.charCodeAt(i+2) << 8) | s.charCodeAt(i+3)) >>> 0;\n  },\n  read32s:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 4;\n    return (s.charCodeAt(i) << 24) | (s.charCodeAt(i+1) << 16) |\n      (s.charCodeAt(i+2) << 8) | s.charCodeAt(i+3);\n  },\n  readstr:function (len) {\n    var i = this.i;\n    this.i = i + len;\n    return caml_new_string(this.s.substring(i, i + len));\n  }\n}\n\n//Provides: BigStringReader\n//Requires: caml_string_of_array, caml_ba_get_1\nfunction BigStringReader (bs, i) { this.s = bs; this.i = i; }\nBigStringReader.prototype = {\n  read8u:function () { return caml_ba_get_1(this.s,this.i++); },\n  read8s:function () { return caml_ba_get_1(this.s,this.i++) << 24 >> 24; },\n  read16u:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 2;\n    return (caml_ba_get_1(s,i) << 8) | caml_ba_get_1(s,i + 1)\n  },\n  read16s:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 2;\n    return (caml_ba_get_1(s,i) << 24 >> 16) | caml_ba_get_1(s,i + 1);\n  },\n  read32u:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 4;\n    return (caml_ba_get_1((s,i) << 24) | (caml_ba_get_1(s,i+1) << 16) |\n            (caml_ba_get_1(s,i+2) << 8) | caml_ba_get_1(s,i+3)) >>> 0;\n  },\n  read32s:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 4;\n    return (caml_ba_get_1(s,i) << 24) | (caml_ba_get_1(s,i+1) << 16) |\n      (caml_ba_get_1(s,i+2) << 8) | caml_ba_get_1(s,i+3);\n  },\n  readstr:function (len) {\n    var i = this.i;\n    var arr = new Array(len)\n    for(var j = 0; j < len; j++){\n      arr[j] = caml_ba_get_1(this.s, i+j);\n    }\n    this.i = i + len;\n    return caml_string_of_array(arr);\n  }\n}\n\n\n\n//Provides: caml_float_of_bytes\n//Requires: caml_int64_float_of_bits, caml_int64_of_bytes\nfunction caml_float_of_bytes (a) {\n  return caml_int64_float_of_bits (caml_int64_of_bytes (a));\n}\n\n//Provides: caml_input_value_from_string mutable\n//Requires: MlStringReader, caml_input_value_from_reader\nfunction caml_input_value_from_string(s,ofs) {\n  var reader = new MlStringReader (s, typeof ofs==\"number\"?ofs:ofs[0]);\n  return caml_input_value_from_reader(reader, ofs)\n}\n\n//Provides: caml_input_value_from_reader mutable\n//Requires: caml_failwith\n//Requires: caml_float_of_bytes, caml_int64_of_bytes\n\nfunction caml_input_value_from_reader(reader, ofs) {\n  var _magic = reader.read32u ()\n  var _block_len = reader.read32u ();\n  var num_objects = reader.read32u ();\n  var _size_32 = reader.read32u ();\n  var _size_64 = reader.read32u ();\n  var stack = [];\n  var intern_obj_table = (num_objects > 0)?[]:null;\n  var obj_counter = 0;\n  function intern_rec () {\n    var code = reader.read8u ();\n    if (code >= 0x40 /*cst.PREFIX_SMALL_INT*/) {\n      if (code >= 0x80 /*cst.PREFIX_SMALL_BLOCK*/) {\n        var tag = code & 0xF;\n        var size = (code >> 4) & 0x7;\n        var v = [tag];\n        if (size == 0) return v;\n        if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n        stack.push(v, size);\n        return v;\n      } else\n        return (code & 0x3F);\n    } else {\n      if (code >= 0x20/*cst.PREFIX_SMALL_STRING */) {\n        var len = code & 0x1F;\n        var v = reader.readstr (len);\n        if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n        return v;\n      } else {\n        switch(code) {\n        case 0x00: //cst.CODE_INT8:\n          return reader.read8s ();\n        case 0x01: //cst.CODE_INT16:\n          return reader.read16s ();\n        case 0x02: //cst.CODE_INT32:\n          return reader.read32s ();\n        case 0x03: //cst.CODE_INT64:\n          caml_failwith(\"input_value: integer too large\");\n          break;\n        case 0x04: //cst.CODE_SHARED8:\n          var offset = reader.read8u ();\n          return intern_obj_table[obj_counter - offset];\n        case 0x05: //cst.CODE_SHARED16:\n          var offset = reader.read16u ();\n          return intern_obj_table[obj_counter - offset];\n        case 0x06: //cst.CODE_SHARED32:\n          var offset = reader.read32u ();\n          return intern_obj_table[obj_counter - offset];\n        case 0x08: //cst.CODE_BLOCK32:\n          var header = reader.read32u ();\n          var tag = header & 0xFF;\n          var size = header >> 10;\n          var v = [tag];\n          if (size == 0) return v;\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          stack.push(v, size);\n          return v;\n        case 0x13: //cst.CODE_BLOCK64:\n          caml_failwith (\"input_value: data block too large\");\n          break;\n        case 0x09: //cst.CODE_STRING8:\n          var len = reader.read8u();\n          var v = reader.readstr (len);\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          return v;\n        case 0x0A: //cst.CODE_STRING32:\n          var len = reader.read32u();\n          var v = reader.readstr (len);\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          return v;\n        case 0x0C: //cst.CODE_DOUBLE_LITTLE:\n          var t = new Array(8);;\n          for (var i = 0;i < 8;i++) t[7 - i] = reader.read8u ();\n          var v = caml_float_of_bytes (t);\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          return v;\n        case 0x0B: //cst.CODE_DOUBLE_BIG:\n          var t = new Array(8);;\n          for (var i = 0;i < 8;i++) t[i] = reader.read8u ();\n          var v = caml_float_of_bytes (t);\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          return v;\n        case 0x0E: //cst.CODE_DOUBLE_ARRAY8_LITTLE:\n          var len = reader.read8u();\n          var v = new Array(len+1);\n          v[0] = 254;\n          var t = new Array(8);;\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          for (var i = 1;i <= len;i++) {\n            for (var j = 0;j < 8;j++) t[7 - j] = reader.read8u();\n            v[i] = caml_float_of_bytes (t);\n          }\n          return v;\n        case 0x0D: //cst.CODE_DOUBLE_ARRAY8_BIG:\n          var len = reader.read8u();\n          var v = new Array(len+1);\n          v[0] = 254;\n          var t = new Array(8);;\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          for (var i = 1;i <= len;i++) {\n            for (var j = 0;j < 8;j++) t[j] = reader.read8u();\n            v [i] = caml_float_of_bytes (t);\n          }\n          return v;\n        case 0x07: //cst.CODE_DOUBLE_ARRAY32_LITTLE:\n          var len = reader.read32u();\n          var v = new Array(len+1);\n          v[0] = 254;\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          var t = new Array(8);;\n          for (var i = 1;i <= len;i++) {\n            for (var j = 0;j < 8;j++) t[7 - j] = reader.read8u();\n            v[i] = caml_float_of_bytes (t);\n          }\n          return v;\n        case 0x0F: //cst.CODE_DOUBLE_ARRAY32_BIG:\n          var len = reader.read32u();\n          var v = new Array(len+1);\n          v[0] = 254;\n          var t = new Array(8);;\n          for (var i = 1;i <= len;i++) {\n            for (var j = 0;j < 8;j++) t[j] = reader.read8u();\n            v [i] = caml_float_of_bytes (t);\n          }\n          return v;\n        case 0x10: //cst.CODE_CODEPOINTER:\n        case 0x11: //cst.CODE_INFIXPOINTER:\n          caml_failwith (\"input_value: code pointer\");\n          break;\n        case 0x12: //cst.CODE_CUSTOM:\n          var c, s = \"\";\n          while ((c = reader.read8u ()) != 0) s += String.fromCharCode (c);\n          switch(s) {\n          case \"_j\":\n            // Int64\n            var t = new Array(8);;\n            for (var j = 0;j < 8;j++) t[j] = reader.read8u();\n            var v = caml_int64_of_bytes (t);\n            if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n            return v;\n          case \"_i\":\n            // Int32\n            var v = reader.read32s ();\n            if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n            return v;\n          case \"_n\":\n            // Nativeint\n            switch (reader.read8u ()) {\n            case 1:\n              var v = reader.read32s ();\n              if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n              return v;\n            case 2:\n              caml_failwith(\"input_value: native integer value too large\");\n            default:\n              caml_failwith(\"input_value: ill-formed native integer\");\n            }\n          default:\n            caml_failwith(\"input_value: unknown custom block identifier\");\n          }\n        default:\n          caml_failwith (\"input_value: ill-formed message\");\n        }\n      }\n    }\n  }\n  var res = intern_rec ();\n  while (stack.length > 0) {\n    var size = stack.pop();\n    var v = stack.pop();\n    var d = v.length;\n    if (d < size) stack.push(v, size);\n    v[d] = intern_rec ();\n  }\n  if (typeof ofs!=\"number\") ofs[0] = reader.i;\n  return res;\n}\n\n//Provides: caml_marshal_data_size mutable\n//Requires: caml_failwith, caml_string_unsafe_get\nfunction caml_marshal_data_size (s, ofs) {\n  function get32(s,i) {\n    return (caml_string_unsafe_get(s, i) << 24) |\n           (caml_string_unsafe_get(s, i + 1) << 16) |\n           (caml_string_unsafe_get(s, i + 2) << 8) |\n            caml_string_unsafe_get(s, i + 3);\n  }\n  if (get32(s, ofs) != (0x8495A6BE|0))\n    caml_failwith(\"Marshal.data_size: bad object\");\n  return (get32(s, ofs + 4));\n}\n\n//Provides: caml_output_val\n//Requires: caml_int64_to_bytes, caml_failwith\n//Requires: caml_int64_bits_of_float\n//Requires: MlString, caml_ml_string_length, caml_string_unsafe_get\nvar caml_output_val = function (){\n  function Writer () { this.chunk = []; }\n  Writer.prototype = {\n    chunk_idx:20, block_len:0, obj_counter:0, size_32:0, size_64:0,\n    write:function (size, value) {\n      for (var i = size - 8;i >= 0;i -= 8)\n        this.chunk[this.chunk_idx++] = (value >> i) & 0xFF;\n    },\n    write_code:function (size, code, value) {\n      this.chunk[this.chunk_idx++] = code;\n      for (var i = size - 8;i >= 0;i -= 8)\n        this.chunk[this.chunk_idx++] = (value >> i) & 0xFF;\n    },\n    finalize:function () {\n      this.block_len = this.chunk_idx - 20;\n      this.chunk_idx = 0;\n      this.write (32, 0x8495A6BE);\n      this.write (32, this.block_len);\n      this.write (32, this.obj_counter);\n      this.write (32, this.size_32);\n      this.write (32, this.size_64);\n      return this.chunk;\n    }\n  }\n  return function (v) {\n    var writer = new Writer ();\n    var stack = [];\n    function extern_rec (v) {\n      if (v instanceof Array && v[0] === (v[0]|0)) {\n        if (v[0] == 255) {\n          // Int64\n          writer.write (8, 0x12 /*cst.CODE_CUSTOM*/);\n          for (var i = 0; i < 3; i++) writer.write (8, \"_j\\0\".charCodeAt(i));\n          var b = caml_int64_to_bytes (v);\n          for (var i = 0; i < 8; i++) writer.write (8, b[i]);\n          writer.size_32 += 4;\n          writer.size_64 += 3;\n          return;\n        }\n        if (v[0] == 251) {\n          caml_failwith(\"output_value: abstract value (Abstract)\");\n        }\n        if (v[0] < 16 && v.length - 1 < 8)\n          writer.write (8, 0x80 /*cst.PREFIX_SMALL_BLOCK*/ + v[0] + ((v.length - 1)<<4));\n        else\n          writer.write_code(32, 0x08 /*cst.CODE_BLOCK32*/, ((v.length-1) << 10) | v[0]);\n        writer.size_32 += v.length;\n        writer.size_64 += v.length;\n        if (v.length > 1) stack.push (v, 1);\n      } else if (v instanceof MlString) {\n        var len = caml_ml_string_length(v);\n        if (len < 0x20)\n          writer.write (8, 0x20 /*cst.PREFIX_SMALL_STRING*/ + len);\n        else if (len < 0x100)\n          writer.write_code (8, 0x09/*cst.CODE_STRING8*/, len);\n        else\n          writer.write_code (32, 0x0A /*cst.CODE_STRING32*/, len);\n        for (var i = 0;i < len;i++)\n          writer.write (8, caml_string_unsafe_get(v,i));\n        writer.size_32 += 1 + (((len + 4) / 4)|0);\n        writer.size_64 += 1 + (((len + 8) / 8)|0);\n      } else {\n        if (v != (v|0)){\n          var type_of_v = typeof v;\n//\n// If a float happens to be an integer it is serialized as an integer\n// (Js_of_ocaml cannot tell whether the type of an integer number is\n// float or integer.) This can result in unexpected crashes when\n// unmarshalling using the standard runtime. It seems better to\n// systematically fail on marshalling.\n//\n//          if(type_of_v != \"number\")\n          caml_failwith(\"output_value: abstract value (\"+type_of_v+\")\");\n//          var t = caml_int64_to_bytes(caml_int64_bits_of_float(v));\n//          writer.write (8, 0x0B /*cst.CODE_DOUBLE_BIG*/);\n//          for(var i = 0; i<8; i++){writer.write(8,t[i])}\n        }\n        else if (v >= 0 && v < 0x40) {\n          writer.write (8, 0X40 /*cst.PREFIX_SMALL_INT*/ + v);\n        } else {\n          if (v >= -(1 << 7) && v < (1 << 7))\n            writer.write_code(8, 0x00 /*cst.CODE_INT8*/, v);\n          else if (v >= -(1 << 15) && v < (1 << 15))\n            writer.write_code(16, 0x01 /*cst.CODE_INT16*/, v);\n          else\n            writer.write_code(32, 0x02 /*cst.CODE_INT32*/, v);\n        }\n      }\n    }\n    extern_rec (v);\n    while (stack.length > 0) {\n      var i = stack.pop ();\n      var v = stack.pop ();\n      if (i + 1 < v.length) stack.push (v, i + 1);\n      extern_rec (v[i]);\n    }\n    writer.finalize ();\n    return writer.chunk;\n  }\n} ();\n\n//Provides: caml_output_value_to_string mutable\n//Requires: caml_output_val, caml_string_of_array\nfunction caml_output_value_to_string (v, _fl) {\n  /* ignores flags... */\n  return caml_string_of_array (caml_output_val (v));\n}\n\n//Provides: caml_output_value_to_buffer\n//Requires: caml_output_val, caml_failwith, caml_blit_string\nfunction caml_output_value_to_buffer (s, ofs, len, v, _fl) {\n  /* ignores flags... */\n  var t = caml_output_val (v);\n  if (t.length > len) caml_failwith (\"Marshal.to_buffer: buffer overflow\");\n  caml_blit_string(t, 0, s, ofs, t.length);\n  return 0;\n}\n",
  "// Js_of_ocaml library\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Jslib: code specific to Js_of_ocaml\n\n//Provides: caml_js_from_bool const (const)\nfunction caml_js_from_bool(x) { return !!x; }\n//Provides: caml_js_to_bool const (const)\nfunction caml_js_to_bool(x) { return +x; }\n//Provides: caml_js_from_float const (const)\nfunction caml_js_from_float(x) { return x; }\n//Provides: caml_js_to_float const (const)\nfunction caml_js_to_float(x) { return x; }\n//Provides: caml_js_from_string mutable (const)\n//Requires: MlString\nfunction caml_js_from_string(s) { return s.toString(); }\n//Provides: caml_js_from_array mutable (shallow)\n//Requires: raw_array_sub\nfunction caml_js_from_array(a) { return raw_array_sub(a,1,a.length-1); }\n//Provides: caml_js_to_array mutable (shallow)\n//Requires: raw_array_cons\nfunction caml_js_to_array(a) { return raw_array_cons(a,0); }\n\n//Provides: caml_js_var mutable (const)\n//Requires: js_print_stderr\n//Requires: MlString\nfunction caml_js_var(x) {\n  var x = x.toString();\n  //Checks that x has the form ident[.ident]*\n  if(!x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/)){\n    js_print_stderr(\"caml_js_var: \\\"\" + x + \"\\\" is not a valid JavaScript variable. continuing ..\");\n    //joo_global_object.console.error(\"Js.Unsafe.eval_string\")\n  }\n  return eval(x);\n}\n//Provides: caml_js_call (const, mutable, shallow)\n//Requires: caml_js_from_array\nfunction caml_js_call(f, o, args) { return f.apply(o, caml_js_from_array(args)); }\n//Provides: caml_js_fun_call (const, shallow)\n//Requires: caml_js_from_array\nfunction caml_js_fun_call(f, args) { return f.apply(null, caml_js_from_array(args)); }\n//Provides: caml_js_meth_call (mutable, const, shallow)\n//Requires: MlString\n//Requires: caml_js_from_array\nfunction caml_js_meth_call(o, f, args) {\n  return o[f.toString()].apply(o, caml_js_from_array(args));\n}\n//Provides: caml_js_new (const, shallow)\n//Requires: caml_js_from_array\nfunction caml_js_new(c, a) {\n  switch (a.length) {\n  case 1: return new c;\n  case 2: return new c (a[1]);\n  case 3: return new c (a[1],a[2]);\n  case 4: return new c (a[1],a[2],a[3]);\n  case 5: return new c (a[1],a[2],a[3],a[4]);\n  case 6: return new c (a[1],a[2],a[3],a[4],a[5]);\n  case 7: return new c (a[1],a[2],a[3],a[4],a[5],a[6]);\n  case 8: return new c (a[1],a[2],a[3],a[4],a[5],a[6], a[7]);\n  }\n  function F() { return c.apply(this, caml_js_from_array(a)); }\n  F.prototype = c.prototype;\n  return new F;\n}\n//Provides: caml_js_wrap_callback const (const)\n//Requires: caml_call_gen,raw_array_copy\nfunction caml_js_wrap_callback(f) {\n  return function () {\n    if(arguments.length > 0){\n      return caml_call_gen(f, raw_array_copy(arguments));\n    } else {\n      return caml_call_gen(f, [undefined]);\n    }\n  }\n}\n//Provides: caml_js_wrap_meth_callback const (const)\n//Requires: caml_call_gen,raw_array_cons\nfunction caml_js_wrap_meth_callback(f) {\n  return function () {\n    return caml_call_gen(f,raw_array_cons(arguments,this));\n  }\n}\n//Provides: caml_js_wrap_meth_callback_unsafe const (const)\n//Requires: caml_call_gen,raw_array_cons\nfunction caml_js_wrap_meth_callback_unsafe(f) {\n  return function () { f.apply(null, raw_array_cons(arguments,this)); }\n}\n//Provides: caml_js_equals mutable (const, const)\nfunction caml_js_equals (x, y) { return +(x == y); }\n//Provides: caml_js_to_byte_string const\n//Requires: caml_new_string\nfunction caml_js_to_byte_string (s) {return caml_new_string (s);}\n\n//Provides: caml_js_eval_string (const)\n//Requires: MlString\nfunction caml_js_eval_string (s) {return eval(s.toString());}\n\n//Provides: caml_js_expr (const)\n//Requires: js_print_stderr\n//Requires: MlString\nfunction caml_js_expr(s) {\n  js_print_stderr(\"caml_js_expr: fallback to runtime evaluation\");\n  return eval(s.toString());}\n\n//Provides: caml_pure_js_expr const (const)\n//Requires: js_print_stderr\n//Requires: MlString\nfunction caml_pure_js_expr (s){\n  js_print_stderr(\"caml_pure_js_expr: fallback to runtime evaluation\");\n  return eval(s.toString());}\n\n//Provides: caml_js_object (object_literal)\n//Requires: MlString\nfunction caml_js_object (a) {\n  var o = {};\n  for (var i = 1; i < a.length; i++) {\n    var p = a[i];\n    o[p[1].toString()] = p[2];\n  }\n  return o;\n}\n\n\n//Provides: caml_js_export_var\nfunction caml_js_export_var (){\n  if(typeof module !== 'undefined' && module && module.exports)\n    return module.exports\n  else\n    return joo_global_object;\n}\n",
  "// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Io\n\n//Provides: caml_sys_close\n//Requires: caml_global_data\nfunction caml_sys_close(fd) {\n  delete caml_global_data.fds[fd];\n  return 0;\n}\n\n//Provides: caml_sys_open\n//Requires: MlString, caml_raise_sys_error, caml_global_data,caml_sys_file_exists\n//Requires: caml_fs_register,caml_make_path,caml_fs_content\n//Requires: caml_raise_no_such_file,caml_sys_is_directory\n//Requires: caml_create_string,MlFile,caml_ml_string_length\nfunction caml_sys_open_internal(idx,file,flags) {\n  if(caml_global_data.fds === undefined) caml_global_data.fds = new Array();\n  flags=flags?flags:{};\n  var info = {};\n  info.file = file;\n  info.offset = flags.append?caml_ml_string_length(file.data):0;\n  info.flags = flags;\n  caml_global_data.fds[idx] = info;\n  caml_global_data.fd_last_idx = idx;\n  return idx;\n}\nfunction caml_sys_open (name, flags, _perms) {\n  var f = {};\n  while(flags){\n    switch(flags[1]){\n    case 0: f.rdonly = 1;break;\n    case 1: f.wronly = 1;break;\n    case 2: f.append = 1;break;\n    case 3: f.create = 1;break;\n    case 4: f.truncate = 1;break;\n    case 5: f.excl = 1; break;\n    case 6: f.binary = 1;break;\n    case 7: f.text = 1;break;\n    case 8: f.nonblock = 1;break;\n    }\n    flags=flags[2];\n  }\n  var name2 = name.toString();\n  var path = caml_make_path(name);\n  if(f.rdonly && f.wronly)\n    caml_raise_sys_error(name2 + \" : flags Open_rdonly and Open_wronly are not compatible\");\n  if(f.text && f.binary)\n    caml_raise_sys_error(name2 + \" : flags Open_text and Open_binary are not compatible\");\n  if (caml_sys_file_exists(name)) {\n    if (caml_sys_is_directory(name)) caml_raise_sys_error(name2 + \" : is a directory\");\n    if (f.create && f.excl) caml_raise_sys_error(name2 + \" : file already exists\");\n    var idx = caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;\n    var file = caml_fs_content(path);\n    if(f.truncate) file.truncate();\n    return caml_sys_open_internal (idx+1,file,f);\n  } else if (f.create) {\n    var idx = caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;\n    caml_fs_register(name,caml_create_string(0));\n    var file = caml_fs_content(path);\n    return caml_sys_open_internal (idx+1,file,f);\n  }\n  else caml_raise_no_such_file (name);\n}\ncaml_sys_open_internal(0,new MlFile(caml_create_string(0))); //stdin\ncaml_sys_open_internal(1,new MlFile(caml_create_string(0))); //stdout\ncaml_sys_open_internal(2,new MlFile(caml_create_string(0))); //stderr\n\n\n// ocaml Channels\n\n//Provides: caml_ml_set_channel_name\nfunction caml_ml_set_channel_name() {\n  return 0\n}\n\n//Provides: caml_ml_out_channels\nvar caml_ml_out_channels = new Array();\n\n//Provides: caml_ml_out_channels_list\n//Requires: caml_ml_out_channels\nfunction caml_ml_out_channels_list () {\n  var l = 0;\n  for(var c in caml_ml_out_channels){\n    if(caml_ml_out_channels[c].opened)\n      l=[0,caml_ml_out_channels[c],l];\n  }\n  return l;\n}\n\n\n//Provides: caml_ml_open_descriptor_out\n//Requires: js_print_stderr, js_print_stdout, caml_ml_out_channels, caml_global_data,caml_sys_open\n//Requires: caml_raise_sys_error,caml_new_string\n//Requires: caml_create_string, caml_blit_string,caml_ml_string_length\nfunction caml_std_output(chan,s){\n  var str = caml_new_string(s);\n  var slen = caml_ml_string_length(str);\n  var clen = caml_ml_string_length(chan.file.data);\n  var offset = chan.offset;\n  if(offset + slen >= clen) {\n    var new_str = caml_create_string (offset + slen);\n    caml_blit_string(chan.file.data, 0, new_str, 0, clen);\n    caml_blit_string(str, 0, new_str, offset, slen);\n    chan.file.data = new_str;\n  }\n  chan.offset += slen;\n  chan.file.modified();\n  return 0;\n}\n\nfunction caml_ml_open_descriptor_out (fd) {\n  var output;\n  switch(fd){\n    case 1: output=js_print_stdout;break;\n    case 2: output=js_print_stderr;break;\n    default: output=caml_std_output;\n  }\n  var data = caml_global_data.fds[fd];\n  if(data.flags.rdonly) caml_raise_sys_error(\"fd \"+ fd + \" is readonly\");\n  var channel = {\n    file:data.file,\n    offset:data.offset,\n    fd:fd,\n    opened:true,\n\n    buffer:\"\",\n    output : output\n  };\n  caml_ml_out_channels[channel.fd]=channel;\n  return channel;\n}\n\n//Provides: caml_ml_open_descriptor_in\n//Requires: caml_global_data,caml_sys_open,caml_raise_sys_error\nfunction caml_ml_open_descriptor_in (fd)  {\n  var data = caml_global_data.fds[fd];\n  if(data.flags.wronly) caml_raise_sys_error(\"fd \"+ fd + \" is writeonly\");\n\n  return {\n    file:data.file,\n    offset:data.offset,\n    fd:fd,\n    opened:true,\n    refill:null\n  };\n}\n\n\n//Provides: caml_ml_set_binary_mode\n//Requires: caml_global_data\nfunction caml_ml_set_binary_mode(chan,mode){\n  var data = caml_global_data.fds[chan.fd];\n  data.flags.text = !mode\n  data.flags.binary = mode\n  return 0;\n}\n\n//Input from in_channel\n\n//Provides: caml_ml_close_channel\n//Requires: caml_ml_flush, caml_ml_out_channels\n//Requires: caml_sys_close\nfunction caml_ml_close_channel (channel) {\n    caml_ml_flush(channel);\n    channel.opened = false;\n    delete caml_ml_out_channels[channel.fd];\n    caml_sys_close(channel.fd)\n    return 0;\n}\n\n//Provides: caml_ml_channel_size\n//Requires: caml_ml_string_length\nfunction caml_ml_channel_size(chan) {\n  return caml_ml_string_length(chan.file.data);\n}\n\n//Provides: caml_ml_channel_size_64\n//Requires: caml_ml_channel_size,caml_int64_of_float,caml_ml_string_length\nfunction caml_ml_channel_size_64(chan) {\n  return caml_int64_of_float(caml_ml_string_length(chan.file.data));\n}\n\n//Provides: caml_ml_set_channel_output\nfunction caml_ml_set_channel_output(chan,f) {\n  chan.output = f;\n  return 0;\n}\n\n//Provides: caml_ml_set_channel_refill\nfunction caml_ml_set_channel_refill(chan,f) {\n  chan.refill = f;\n  return 0;\n}\n\n//Provides: caml_ml_refill_input\n//Requires: caml_ml_string_length, caml_create_string, caml_blit_string\nfunction caml_ml_refill_input (chan) {\n  var str = chan.refill();\n  var str_len = caml_ml_string_length(str);\n  if (str_len == 0) chan.refill = null;\n  var old_len = caml_ml_string_length(chan.file.data) - chan.offset;\n  if (old_len == 0) {\n    chan.file.data = str;\n  } else {\n    var new_data = caml_create_string(old_len + str_len);\n    caml_blit_string(chan.file.data, chan.offset, new_data, 0, old_len);\n    caml_blit_string(str, 0, new_data, old_len, str_len);\n    chan.file.data = new_data;\n  }\n  chan.offset = 0;\n  return str_len;\n}\n\n//Provides: caml_ml_may_refill_input\n//Requires: caml_ml_string_length, caml_ml_refill_input\nfunction caml_ml_may_refill_input (chan) {\n  if (chan.refill == null) return;\n  if (caml_ml_string_length(chan.file.data) != chan.offset) return;\n  caml_ml_refill_input (chan);\n}\n\n//Provides: caml_ml_input\n//Requires: caml_blit_string, caml_string_of_array, caml_ml_string_length\n//Requires: caml_ml_refill_input\nfunction caml_ml_input (chan, s, i, l) {\n  var l2 = caml_ml_string_length(chan.file.data) - chan.offset;\n  if (l2 == 0 && chan.refill != null) l2 = caml_ml_refill_input(chan);\n  if (l2 < l) l = l2;\n  caml_blit_string(chan.file.data, chan.offset, s, i, l);\n  chan.offset += l;\n  return l;\n}\n\n//Provides: caml_fs_file_content\n//Requires: caml_string_of_array, caml_fs_content, caml_make_path, MlFile\n//Requires: caml_raise_not_found, unix_time\nfunction caml_fs_file_content(name) {\n  var path = caml_make_path(name);\n  var f = caml_fs_content(path);\n  if(f instanceof MlFile){\n    var now = unix_time();\n    f.atime = now;\n    return f.data;\n  }\n  caml_raise_not_found();\n}\n\n//Provides: caml_input_value\n//Requires: caml_marshal_data_size, caml_input_value_from_string, caml_string_of_array\nfunction caml_input_value (chan) {\n  var str = chan.file.data;\n  var offset = [chan.offset];\n  var _len = caml_marshal_data_size (str, offset[0]);\n  var res = caml_input_value_from_string(str, offset);\n  chan.offset = offset[0];\n  return res;\n}\n\n//Provides: caml_ml_input_char\n//Requires: caml_raise_end_of_file, caml_array_bound_error\n//Requires: caml_ml_string_length, caml_string_get, caml_ml_may_refill_input\nfunction caml_ml_input_char (chan) {\n  caml_ml_may_refill_input(chan);\n  if (chan.offset >= caml_ml_string_length(chan.file.data))\n    caml_raise_end_of_file();\n  var c = caml_string_get(chan.file.data, chan.offset);\n  chan.offset++;\n  return c;\n}\n\n//Provides: caml_ml_input_int\n//Requires: caml_raise_end_of_file\n//Requires: caml_ml_string_length, caml_string_unsafe_get, caml_ml_refill_input\nfunction caml_ml_input_int (chan) {\n  var s = chan.file.data, o = chan.offset;\n  while ((o + 3) >= caml_ml_string_length(s)) {\n    var l = caml_ml_refill_input(chan);\n    if (l == 0) caml_raise_end_of_file();\n    s = chan.file.data;\n    o = chan.offset;\n  }\n  var r = (caml_string_unsafe_get(s,o) << 24) | (caml_string_unsafe_get(s,o+1) << 16) | (caml_string_unsafe_get(s,o+2) << 8) | (caml_string_unsafe_get(s,o+3));\n  chan.offset+=4;\n  return r;\n}\n\n//Provides: caml_ml_seek_in\n//Requires: caml_raise_sys_error\nfunction caml_ml_seek_in(chan,pos){\n  if (chan.refill != null) caml_raise_sys_error(\"Illegal seek\");\n  chan.offset = pos;\n  return 0;\n}\n\n//Provides: caml_ml_seek_in_64\n//Requires: caml_int64_to_float, caml_raise_sys_error\nfunction caml_ml_seek_in_64(chan,pos){\n  if (chan.refill != null) caml_raise_sys_error(\"Illegal seek\");\n  chan.offset = caml_int64_to_float(pos);\n  return 0;\n}\n\n//Provides: caml_ml_pos_in\nfunction caml_ml_pos_in(chan) {return chan.offset}\n\n//Provides: caml_ml_pos_in_64\n//Requires: caml_int64_of_float\nfunction caml_ml_pos_in_64(chan) {return caml_int64_of_float(chan.offset)}\n\n//Provides: caml_ml_input_scan_line\n//Requires: caml_array_bound_error, caml_ml_string_length, caml_string_get\n//Requires: caml_ml_may_refill_input\nfunction caml_ml_input_scan_line(chan){\n  caml_ml_may_refill_input(chan);\n  var p = chan.offset;\n  var s = chan.file.data;\n  var len = caml_ml_string_length(s);\n  if(p >= len) { return 0;}\n  while(true) {\n    if(p >= len) return - (p - chan.offset);\n    if(caml_string_get(s, p) == 10) return p - chan.offset + 1;\n    p++;\n  }\n}\n\n//Provides: caml_ml_flush\n//Requires: caml_raise_sys_error\nfunction caml_ml_flush (oc) {\n    if(! oc.opened) caml_raise_sys_error(\"Cannot flush a closed channel\");\n    if(oc.buffer == \"\") return 0;\n    if(oc.output) {\n      switch(oc.output.length){\n      case 2: oc.output(oc,oc.buffer);break;\n      default: oc.output(oc.buffer)\n      };\n    }\n    oc.buffer = \"\";\n    return 0;\n}\n\n//output to out_channel\n\n//Provides: caml_ml_output\n//Requires: caml_ml_flush,caml_ml_string_length\n//Requires: caml_create_string, caml_blit_string, caml_raise_sys_error\nfunction caml_ml_output (oc,buffer,offset,len) {\n    if(! oc.opened) caml_raise_sys_error(\"Cannot output to a closed channel\");\n    var string;\n    if(offset == 0 && caml_ml_string_length(buffer) == len)\n        string = buffer;\n    else {\n        string = caml_create_string(len);\n        caml_blit_string(buffer,offset,string,0,len);\n    }\n    var jsstring = string.toString();\n    var id = jsstring.lastIndexOf(\"\\n\");\n    if(id < 0)\n        oc.buffer+=jsstring;\n    else {\n        oc.buffer+=jsstring.substr(0,id+1);\n        caml_ml_flush (oc);\n        oc.buffer += jsstring.substr(id+1);\n    }\n    return 0;\n}\n//Provides: caml_ml_output_char\n//Requires: caml_ml_output\n//Requires: caml_new_string\nfunction caml_ml_output_char (oc,c) {\n    var s = caml_new_string(String.fromCharCode(c));\n    caml_ml_output(oc,s,0,1);\n    return 0;\n}\n\n//Provides: caml_output_value\n//Requires: caml_output_value_to_string, caml_ml_output,caml_ml_string_length\nfunction caml_output_value (chan,v,_flags) {\n  var s = caml_output_value_to_string(v);\n  caml_ml_output(chan,s,0,caml_ml_string_length(s));\n  return 0;\n}\n\n\n//Provides: caml_ml_seek_out\nfunction caml_ml_seek_out(chan,pos){\n  chan.offset = pos;\n  return 0;\n}\n\n//Provides: caml_ml_seek_out_64\n//Requires: caml_int64_to_float\nfunction caml_ml_seek_out_64(chan,pos){\n  chan.offset = caml_int64_to_float(pos);\n  return 0;\n}\n\n//Provides: caml_ml_pos_out\nfunction caml_ml_pos_out(chan) {return chan.offset}\n\n//Provides: caml_ml_pos_out_64\n//Requires: caml_int64_of_float\nfunction caml_ml_pos_out_64(chan) {\n  return caml_int64_of_float (chan.offset);\n}\n\n//Provides: caml_ml_output_int\n//Requires: caml_ml_output\n//Requires: caml_string_of_array\nfunction caml_ml_output_int (oc,i) {\n  var arr = [(i>>24) & 0xFF,(i>>16) & 0xFF,(i>>8) & 0xFF,i & 0xFF ];\n  var s = caml_string_of_array(arr);\n  caml_ml_output(oc,s,0,4);\n  return 0\n}\n",
  "\n\n//Provides: caml_gc_minor\nfunction caml_gc_minor(){ return 0}\n//Provides: caml_gc_major\nfunction caml_gc_major(){ return 0}\n//Provides: caml_gc_full_major\nfunction caml_gc_full_major(){ return 0}\n//Provides: caml_gc_compaction\nfunction caml_gc_compaction(){ return 0}\n//Provides: caml_gc_counters\nfunction caml_gc_counters() { return [254,0,0,0] }\n//Provides: caml_gc_quick_stat\nfunction caml_gc_quick_stat(){\n  return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n}\n//Provides: caml_gc_stat\nfunction caml_gc_stat() {\n  return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n}\n\n//Provides: caml_gc_set\nfunction caml_gc_set(_control) {\n  return 0;\n}\n\n//Provides: caml_gc_get\nfunction caml_gc_get(){\n  return [0,0,0,0,0,0,0,0,0]\n}\n",
  "/***********************************************************************/\n/*                                                                     */\n/*                           Objective Caml                            */\n/*                                                                     */\n/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         */\n/*                                                                     */\n/*  Copyright 1996 Institut National de Recherche en Informatique et   */\n/*  en Automatique.  All rights reserved.  This file is distributed    */\n/*  under the terms of the GNU Library General Public License, with    */\n/*  the special exception on linking described in file ../LICENSE.     */\n/*                                                                     */\n/***********************************************************************/\n\n/* $Id: parsing.c 8983 2008-08-06 09:38:25Z xleroy $ */\n\n/* The PDA automaton for parsers generated by camlyacc */\n\n/* The pushdown automata */\n\n//Provides: caml_parse_engine\n//Requires: caml_lex_array\nfunction caml_parse_engine(tables, env, cmd, arg)\n{\n  var ERRCODE = 256;\n\n  //var START = 0;\n  //var TOKEN_READ = 1;\n  //var STACKS_GROWN_1 = 2;\n  //var STACKS_GROWN_2 = 3;\n  //var SEMANTIC_ACTION_COMPUTED = 4;\n  //var ERROR_DETECTED = 5;\n  var loop = 6;\n  var testshift = 7;\n  var shift = 8;\n  var shift_recover = 9;\n  var reduce = 10;\n\n  var READ_TOKEN = 0;\n  var RAISE_PARSE_ERROR = 1;\n  var GROW_STACKS_1 = 2;\n  var GROW_STACKS_2 = 3;\n  var COMPUTE_SEMANTIC_ACTION = 4;\n  var CALL_ERROR_FUNCTION = 5;\n\n  var env_s_stack = 1;\n  var env_v_stack = 2;\n  var env_symb_start_stack = 3;\n  var env_symb_end_stack = 4;\n  var env_stacksize = 5;\n  var env_stackbase = 6;\n  var env_curr_char = 7;\n  var env_lval = 8;\n  var env_symb_start = 9;\n  var env_symb_end = 10;\n  var env_asp = 11;\n  var env_rule_len = 12;\n  var env_rule_number = 13;\n  var env_sp = 14;\n  var env_state = 15;\n  var env_errflag = 16;\n\n  // var _tbl_actions = 1;\n  var tbl_transl_const = 2;\n  var tbl_transl_block = 3;\n  var tbl_lhs = 4;\n  var tbl_len = 5;\n  var tbl_defred = 6;\n  var tbl_dgoto = 7;\n  var tbl_sindex = 8;\n  var tbl_rindex = 9;\n  var tbl_gindex = 10;\n  var tbl_tablesize = 11;\n  var tbl_table = 12;\n  var tbl_check = 13;\n  // var _tbl_error_function = 14;\n  // var _tbl_names_const = 15;\n  // var _tbl_names_block = 16;\n\n  if (!tables.dgoto) {\n    tables.defred = caml_lex_array (tables[tbl_defred]);\n    tables.sindex = caml_lex_array (tables[tbl_sindex]);\n    tables.check  = caml_lex_array (tables[tbl_check]);\n    tables.rindex = caml_lex_array (tables[tbl_rindex]);\n    tables.table  = caml_lex_array (tables[tbl_table]);\n    tables.len    = caml_lex_array (tables[tbl_len]);\n    tables.lhs    = caml_lex_array (tables[tbl_lhs]);\n    tables.gindex = caml_lex_array (tables[tbl_gindex]);\n    tables.dgoto  = caml_lex_array (tables[tbl_dgoto]);\n  }\n\n  var res = 0, n, n1, n2, state1;\n\n  // RESTORE\n  var sp = env[env_sp];\n  var state = env[env_state];\n  var errflag = env[env_errflag];\n\n  exit:for (;;) {\n    switch(cmd) {\n    case 0://START:\n      state = 0;\n      errflag = 0;\n      // Fall through\n\n    case 6://loop:\n      n = tables.defred[state];\n      if (n != 0) { cmd = reduce; break; }\n      if (env[env_curr_char] >= 0) { cmd = testshift; break; }\n      res = READ_TOKEN;\n      break exit;\n                                  /* The ML code calls the lexer and updates */\n                                  /* symb_start and symb_end */\n    case 1://TOKEN_READ:\n      if (arg instanceof Array) {\n        env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];\n        env[env_lval] = arg[1];\n      } else {\n        env[env_curr_char] = tables[tbl_transl_const][arg + 1];\n        env[env_lval] = 0;\n      }\n      // Fall through\n\n    case 7://testshift:\n      n1 = tables.sindex[state];\n      n2 = n1 + env[env_curr_char];\n      if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] &&\n          tables.check[n2] == env[env_curr_char]) {\n        cmd = shift; break;\n      }\n      n1 = tables.rindex[state];\n      n2 = n1 + env[env_curr_char];\n      if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] &&\n          tables.check[n2] == env[env_curr_char]) {\n        n = tables.table[n2];\n        cmd = reduce; break;\n      }\n      if (errflag <= 0) {\n        res = CALL_ERROR_FUNCTION;\n        break exit;\n      }\n      // Fall through\n                                  /* The ML code calls the error function */\n    case 5://ERROR_DETECTED:\n      if (errflag < 3) {\n        errflag = 3;\n        for (;;) {\n          state1 = env[env_s_stack][sp + 1];\n          n1 = tables.sindex[state1];\n          n2 = n1 + ERRCODE;\n          if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] &&\n              tables.check[n2] == ERRCODE) {\n            cmd = shift_recover; break;\n          } else {\n            if (sp <= env[env_stackbase]) return RAISE_PARSE_ERROR;\n                                    /* The ML code raises Parse_error */\n            sp--;\n          }\n        }\n      } else {\n        if (env[env_curr_char] == 0) return RAISE_PARSE_ERROR;\n                                    /* The ML code raises Parse_error */\n        env[env_curr_char] = -1;\n        cmd = loop; break;\n      }\n      // Fall through\n    case 8://shift:\n      env[env_curr_char] = -1;\n      if (errflag > 0) errflag--;\n      // Fall through\n    case 9://shift_recover:\n      state = tables.table[n2];\n      sp++;\n      if (sp >= env[env_stacksize]) {\n        res = GROW_STACKS_1;\n        break exit;\n      }\n      // Fall through\n                                   /* The ML code resizes the stacks */\n    case 2://STACKS_GROWN_1:\n      env[env_s_stack][sp + 1] = state;\n      env[env_v_stack][sp + 1] = env[env_lval];\n      env[env_symb_start_stack][sp + 1] = env[env_symb_start];\n      env[env_symb_end_stack][sp + 1] = env[env_symb_end];\n      cmd = loop;\n      break;\n\n    case 10://reduce:\n      var m = tables.len[n];\n      env[env_asp] = sp;\n      env[env_rule_number] = n;\n      env[env_rule_len] = m;\n      sp = sp - m + 1;\n      m = tables.lhs[n];\n      state1 = env[env_s_stack][sp];\n      n1 = tables.gindex[m];\n      n2 = n1 + state1;\n      if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] &&\n          tables.check[n2] == state1)\n        state = tables.table[n2];\n      else\n        state = tables.dgoto[m];\n      if (sp >= env[env_stacksize]) {\n        res = GROW_STACKS_2;\n        break exit;\n      }\n      // Fall through\n                                  /* The ML code resizes the stacks */\n    case 3://STACKS_GROWN_2:\n      res = COMPUTE_SEMANTIC_ACTION;\n      break exit;\n                                  /* The ML code calls the semantic action */\n    case 4://SEMANTIC_ACTION_COMPUTED:\n      env[env_s_stack][sp + 1] = state;\n      env[env_v_stack][sp + 1] = arg;\n      var asp = env[env_asp];\n      env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];\n      if (sp > asp) {\n        /* This is an epsilon production. Take symb_start equal to symb_end. */\n        env[env_symb_start_stack][sp + 1] = env[env_symb_end_stack][asp + 1];\n      }\n      cmd = loop; break;\n                                  /* Should not happen */\n    default:\n      return RAISE_PARSE_ERROR;\n    }\n  }\n  // SAVE\n  env[env_sp] = sp;\n  env[env_state] = state;\n  env[env_errflag] = errflag;\n  return res;\n}\n\n//Provides: caml_set_parser_trace const\n//Dummy function!\nfunction caml_set_parser_trace() { return 0; }\n",
  "// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_CamlinternalMod_init_mod\n//Requires: caml_raise_with_arg, caml_global_data\nfunction caml_CamlinternalMod_init_mod(loc,shape) {\n  function undef_module (_x) {\n    caml_raise_with_arg(caml_global_data.Undefined_recursive_module, loc);\n  }\n  function loop (shape,struct,idx){\n    if(typeof shape === \"number\")\n      switch(shape){\n      case 0://function\n        struct[idx]={fun:undef_module};\n        break;\n      case 1://lazy\n        struct[idx]=[246, undef_module];\n        break;\n      default://case 2://class\n        struct[idx]=[];\n      }\n    else\n      switch(shape[0]){\n      case 0://module\n        struct[idx] = [0];\n        for(var i=1;i<shape[1].length;i++)\n          loop(shape[1][i],struct[idx],i);\n        break;\n      default://case 1://Value\n        struct[idx] = shape[1];\n      }\n  }\n  var res = [];\n  loop(shape,res,0);\n  return res[0]\n}\n//Provides: caml_CamlinternalMod_update_mod\n//Requires: caml_update_dummy\nfunction caml_CamlinternalMod_update_mod(shape,real,x) {\n  if(typeof shape === \"number\")\n    switch(shape){\n    case 0://function\n      real.fun = x;\n      break;\n    case 1://lazy\n    default://case 2://class\n      caml_update_dummy(real,x);\n    }\n  else\n    switch(shape[0]){\n    case 0://module\n      for(var i=1;i<shape[1].length;i++)\n        caml_CamlinternalMod_update_mod(shape[1][i],real[i],x[i]);\n      break;\n    //case 1://Value\n    default:\n    };\n  return 0\n}\n",
  "/***********************************************************************/\n/*                                                                     */\n/*                           Objective Caml                            */\n/*                                                                     */\n/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         */\n/*                                                                     */\n/*  Copyright 1996 Institut National de Recherche en Informatique et   */\n/*  en Automatique.  All rights reserved.  This file is distributed    */\n/*  under the terms of the GNU Library General Public License, with    */\n/*  the special exception on linking described in file ../LICENSE.     */\n/*                                                                     */\n/***********************************************************************/\n\n/* $Id: lexing.c 6045 2004-01-01 16:42:43Z doligez $ */\n\n/* The table-driven automaton for lexers generated by camllex. */\n\n//Provides: caml_lex_array\n//Requires: caml_bytes_of_string\nfunction caml_lex_array(s) {\n  s = caml_bytes_of_string(s);\n  var l = s.length / 2;\n  var a = new Array(l);\n  for (var i = 0; i < l; i++)\n    a[i] = (s.charCodeAt(2 * i) | (s.charCodeAt(2 * i + 1) << 8)) << 16 >> 16;\n  return a;\n}\n\n//Provides: caml_lex_engine\n//Requires: caml_failwith, caml_lex_array, caml_array_of_string\nfunction caml_lex_engine(tbl, start_state, lexbuf) {\n  var lex_buffer = 2;\n  var lex_buffer_len = 3;\n  var lex_start_pos = 5;\n  var lex_curr_pos = 6;\n  var lex_last_pos = 7;\n  var lex_last_action = 8;\n  var lex_eof_reached = 9;\n  var lex_base = 1;\n  var lex_backtrk = 2;\n  var lex_default = 3;\n  var lex_trans = 4;\n  var lex_check = 5;\n\n  if (!tbl.lex_default) {\n    tbl.lex_base =    caml_lex_array (tbl[lex_base]);\n    tbl.lex_backtrk = caml_lex_array (tbl[lex_backtrk]);\n    tbl.lex_check =   caml_lex_array (tbl[lex_check]);\n    tbl.lex_trans =   caml_lex_array (tbl[lex_trans]);\n    tbl.lex_default = caml_lex_array (tbl[lex_default]);\n  }\n\n  var c, state = start_state;\n\n  var buffer = caml_array_of_string(lexbuf[lex_buffer]);\n\n  if (state >= 0) {\n    /* First entry */\n    lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];\n    lexbuf[lex_last_action] = -1;\n  } else {\n    /* Reentry after refill */\n    state = -state - 1;\n  }\n  for(;;) {\n    /* Lookup base address or action number for current state */\n    var base = tbl.lex_base[state];\n    if (base < 0) return -base-1;\n    /* See if it's a backtrack point */\n    var backtrk = tbl.lex_backtrk[state];\n    if (backtrk >= 0) {\n      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];\n      lexbuf[lex_last_action] = backtrk;\n    }\n    /* See if we need a refill */\n    if (lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len]){\n      if (lexbuf[lex_eof_reached] == 0)\n        return -state - 1;\n      else\n        c = 256;\n    }else{\n      /* Read next input char */\n      c = buffer[lexbuf[lex_curr_pos]];\n      lexbuf[lex_curr_pos] ++;\n    }\n    /* Determine next state */\n    if (tbl.lex_check[base + c] == state)\n      state = tbl.lex_trans[base + c];\n    else\n      state = tbl.lex_default[state];\n    /* If no transition on this char, return to last backtrack point */\n    if (state < 0) {\n      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];\n      if (lexbuf[lex_last_action] == -1)\n        caml_failwith(\"lexing: empty token\");\n      else\n        return lexbuf[lex_last_action];\n    }else{\n      /* Erase the EOF condition only if the EOF pseudo-character was\n         consumed by the automaton (i.e. there was no backtrack above)\n       */\n      if (c == 256) lexbuf[lex_eof_reached] = 0;\n    }\n  }\n}\n\n/***********************************************/\n/* New lexer engine, with memory of positions  */\n/***********************************************/\n\n//Provides: caml_new_lex_engine\n//Requires: caml_failwith, caml_lex_array\n//Requires: caml_bytes_of_string, caml_array_of_string\nfunction caml_lex_run_mem(s, i, mem, curr_pos) {\n  for (;;) {\n    var dst = s.charCodeAt(i); i++;\n    if (dst == 0xff) return;\n    var src = s.charCodeAt(i); i++;\n    if (src == 0xff)\n      mem [dst + 1] = curr_pos;\n    else\n      mem [dst + 1] = mem [src + 1];\n  }\n}\n\nfunction caml_lex_run_tag(s, i, mem) {\n  for (;;) {\n    var dst = s.charCodeAt(i); i++;\n    if (dst == 0xff) return ;\n    var src = s.charCodeAt(i); i++;\n    if (src == 0xff)\n      mem [dst + 1] = -1;\n    else\n      mem [dst + 1] = mem [src + 1];\n  }\n}\n\nfunction caml_new_lex_engine(tbl, start_state, lexbuf) {\n  var lex_buffer = 2;\n  var lex_buffer_len = 3;\n  var lex_start_pos = 5;\n  var lex_curr_pos = 6;\n  var lex_last_pos = 7;\n  var lex_last_action = 8;\n  var lex_eof_reached = 9;\n  var lex_mem = 10;\n  var lex_base = 1;\n  var lex_backtrk = 2;\n  var lex_default = 3;\n  var lex_trans = 4;\n  var lex_check = 5;\n  var lex_base_code = 6;\n  var lex_backtrk_code = 7;\n  var lex_default_code = 8;\n  var lex_trans_code = 9;\n  var lex_check_code = 10;\n  var lex_code = 11;\n\n  if (!tbl.lex_default) {\n    tbl.lex_base =    caml_lex_array (tbl[lex_base]);\n    tbl.lex_backtrk = caml_lex_array (tbl[lex_backtrk]);\n    tbl.lex_check =   caml_lex_array (tbl[lex_check]);\n    tbl.lex_trans =   caml_lex_array (tbl[lex_trans]);\n    tbl.lex_default = caml_lex_array (tbl[lex_default]);\n  }\n  if (!tbl.lex_default_code) {\n    tbl.lex_base_code =    caml_lex_array (tbl[lex_base_code]);\n    tbl.lex_backtrk_code = caml_lex_array (tbl[lex_backtrk_code]);\n    tbl.lex_check_code =   caml_lex_array (tbl[lex_check_code]);\n    tbl.lex_trans_code =   caml_lex_array (tbl[lex_trans_code]);\n    tbl.lex_default_code = caml_lex_array (tbl[lex_default_code]);\n  }\n  if (tbl.lex_code == null) tbl.lex_code = caml_bytes_of_string(tbl[lex_code]);\n\n  var c, state = start_state;\n\n  var buffer = caml_array_of_string(lexbuf[lex_buffer]);\n\n  if (state >= 0) {\n    /* First entry */\n    lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];\n    lexbuf[lex_last_action] = -1;\n  } else {\n    /* Reentry after refill */\n    state = -state - 1;\n  }\n  for(;;) {\n    /* Lookup base address or action number for current state */\n    var base = tbl.lex_base[state];\n    if (base < 0) {\n      var pc_off = tbl.lex_base_code[state];\n      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);\n      return -base-1;\n    }\n    /* See if it's a backtrack point */\n    var backtrk = tbl.lex_backtrk[state];\n    if (backtrk >= 0) {\n      var pc_off = tbl.lex_backtrk_code[state];\n      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);\n      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];\n      lexbuf[lex_last_action] = backtrk;\n    }\n    /* See if we need a refill */\n    if (lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len]){\n      if (lexbuf[lex_eof_reached] == 0)\n        return -state - 1;\n      else\n        c = 256;\n    }else{\n      /* Read next input char */\n      c = buffer[lexbuf[lex_curr_pos]];\n      lexbuf[lex_curr_pos] ++;\n    }\n    /* Determine next state */\n    var pstate = state ;\n    if (tbl.lex_check[base + c] == state)\n      state = tbl.lex_trans[base + c];\n    else\n      state = tbl.lex_default[state];\n    /* If no transition on this char, return to last backtrack point */\n    if (state < 0) {\n      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];\n      if (lexbuf[lex_last_action] == -1)\n        caml_failwith(\"lexing: empty token\");\n      else\n        return lexbuf[lex_last_action];\n    }else{\n      /* If some transition, get and perform memory moves */\n      var base_code = tbl.lex_base_code[pstate], pc_off;\n      if (tbl.lex_check_code[base_code + c] == pstate)\n        pc_off = tbl.lex_trans_code[base_code + c];\n      else\n        pc_off = tbl.lex_default_code[pstate];\n      if (pc_off > 0)\n        caml_lex_run_mem\n          (tbl.lex_code, pc_off, lexbuf[lex_mem], lexbuf[lex_curr_pos]);\n      /* Erase the EOF condition only if the EOF pseudo-character was\n         consumed by the automaton (i.e. there was no backtrack above)\n       */\n      if (c == 256) lexbuf[lex_eof_reached] = 0;\n    }\n  }\n}\n\n",
  null,
  "// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n\n//Provides: caml_md5_chan\n//Requires: caml_md5_string, caml_string_of_array,caml_ml_string_length\nfunction caml_md5_chan(chan,len){\n  if(len<0){\n    len=caml_ml_string_length(chan.file.data) - chan.offset;\n  }\n  return caml_md5_string(chan.file.data,chan.offset,len);\n}\n\n//Provides: caml_md5_string\n//Requires: caml_string_of_array, caml_convert_string_to_bytes\nvar caml_md5_string =\nfunction () {\n  function add (x, y) { return (x + y) | 0; }\n  function xx(q,a,b,x,s,t) {\n    a = add(add(a, q), add(x, t));\n    return add((a << s) | (a >>> (32 - s)), b);\n  }\n  function ff(a,b,c,d,x,s,t) {\n    return xx((b & c) | ((~b) & d), a, b, x, s, t);\n  }\n  function gg(a,b,c,d,x,s,t) {\n    return xx((b & d) | (c & (~d)), a, b, x, s, t);\n  }\n  function hh(a,b,c,d,x,s,t) { return xx(b ^ c ^ d, a, b, x, s, t); }\n  function ii(a,b,c,d,x,s,t) { return xx(c ^ (b | (~d)), a, b, x, s, t); }\n\n  function md5(buffer, length) {\n    var i = length;\n    buffer[i >> 2] |= 0x80 << (8 * (i & 3));\n    for (i = (i & ~0x3) + 8;(i & 0x3F) < 60 ;i += 4)\n      buffer[(i >> 2) - 1] = 0;\n    buffer[(i >> 2) -1] = length << 3;\n    buffer[i >> 2] = (length >> 29) & 0x1FFFFFFF;\n\n    var w = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476];\n\n    for(i = 0; i < buffer.length; i += 16) {\n      var a = w[0], b = w[1], c = w[2], d = w[3];\n\n      a = ff(a, b, c, d, buffer[i+ 0], 7, 0xD76AA478);\n      d = ff(d, a, b, c, buffer[i+ 1], 12, 0xE8C7B756);\n      c = ff(c, d, a, b, buffer[i+ 2], 17, 0x242070DB);\n      b = ff(b, c, d, a, buffer[i+ 3], 22, 0xC1BDCEEE);\n      a = ff(a, b, c, d, buffer[i+ 4], 7, 0xF57C0FAF);\n      d = ff(d, a, b, c, buffer[i+ 5], 12, 0x4787C62A);\n      c = ff(c, d, a, b, buffer[i+ 6], 17, 0xA8304613);\n      b = ff(b, c, d, a, buffer[i+ 7], 22, 0xFD469501);\n      a = ff(a, b, c, d, buffer[i+ 8], 7, 0x698098D8);\n      d = ff(d, a, b, c, buffer[i+ 9], 12, 0x8B44F7AF);\n      c = ff(c, d, a, b, buffer[i+10], 17, 0xFFFF5BB1);\n      b = ff(b, c, d, a, buffer[i+11], 22, 0x895CD7BE);\n      a = ff(a, b, c, d, buffer[i+12], 7, 0x6B901122);\n      d = ff(d, a, b, c, buffer[i+13], 12, 0xFD987193);\n      c = ff(c, d, a, b, buffer[i+14], 17, 0xA679438E);\n      b = ff(b, c, d, a, buffer[i+15], 22, 0x49B40821);\n\n      a = gg(a, b, c, d, buffer[i+ 1], 5, 0xF61E2562);\n      d = gg(d, a, b, c, buffer[i+ 6], 9, 0xC040B340);\n      c = gg(c, d, a, b, buffer[i+11], 14, 0x265E5A51);\n      b = gg(b, c, d, a, buffer[i+ 0], 20, 0xE9B6C7AA);\n      a = gg(a, b, c, d, buffer[i+ 5], 5, 0xD62F105D);\n      d = gg(d, a, b, c, buffer[i+10], 9, 0x02441453);\n      c = gg(c, d, a, b, buffer[i+15], 14, 0xD8A1E681);\n      b = gg(b, c, d, a, buffer[i+ 4], 20, 0xE7D3FBC8);\n      a = gg(a, b, c, d, buffer[i+ 9], 5, 0x21E1CDE6);\n      d = gg(d, a, b, c, buffer[i+14], 9, 0xC33707D6);\n      c = gg(c, d, a, b, buffer[i+ 3], 14, 0xF4D50D87);\n      b = gg(b, c, d, a, buffer[i+ 8], 20, 0x455A14ED);\n      a = gg(a, b, c, d, buffer[i+13], 5, 0xA9E3E905);\n      d = gg(d, a, b, c, buffer[i+ 2], 9, 0xFCEFA3F8);\n      c = gg(c, d, a, b, buffer[i+ 7], 14, 0x676F02D9);\n      b = gg(b, c, d, a, buffer[i+12], 20, 0x8D2A4C8A);\n\n      a = hh(a, b, c, d, buffer[i+ 5], 4, 0xFFFA3942);\n      d = hh(d, a, b, c, buffer[i+ 8], 11, 0x8771F681);\n      c = hh(c, d, a, b, buffer[i+11], 16, 0x6D9D6122);\n      b = hh(b, c, d, a, buffer[i+14], 23, 0xFDE5380C);\n      a = hh(a, b, c, d, buffer[i+ 1], 4, 0xA4BEEA44);\n      d = hh(d, a, b, c, buffer[i+ 4], 11, 0x4BDECFA9);\n      c = hh(c, d, a, b, buffer[i+ 7], 16, 0xF6BB4B60);\n      b = hh(b, c, d, a, buffer[i+10], 23, 0xBEBFBC70);\n      a = hh(a, b, c, d, buffer[i+13], 4, 0x289B7EC6);\n      d = hh(d, a, b, c, buffer[i+ 0], 11, 0xEAA127FA);\n      c = hh(c, d, a, b, buffer[i+ 3], 16, 0xD4EF3085);\n      b = hh(b, c, d, a, buffer[i+ 6], 23, 0x04881D05);\n      a = hh(a, b, c, d, buffer[i+ 9], 4, 0xD9D4D039);\n      d = hh(d, a, b, c, buffer[i+12], 11, 0xE6DB99E5);\n      c = hh(c, d, a, b, buffer[i+15], 16, 0x1FA27CF8);\n      b = hh(b, c, d, a, buffer[i+ 2], 23, 0xC4AC5665);\n\n      a = ii(a, b, c, d, buffer[i+ 0], 6, 0xF4292244);\n      d = ii(d, a, b, c, buffer[i+ 7], 10, 0x432AFF97);\n      c = ii(c, d, a, b, buffer[i+14], 15, 0xAB9423A7);\n      b = ii(b, c, d, a, buffer[i+ 5], 21, 0xFC93A039);\n      a = ii(a, b, c, d, buffer[i+12], 6, 0x655B59C3);\n      d = ii(d, a, b, c, buffer[i+ 3], 10, 0x8F0CCC92);\n      c = ii(c, d, a, b, buffer[i+10], 15, 0xFFEFF47D);\n      b = ii(b, c, d, a, buffer[i+ 1], 21, 0x85845DD1);\n      a = ii(a, b, c, d, buffer[i+ 8], 6, 0x6FA87E4F);\n      d = ii(d, a, b, c, buffer[i+15], 10, 0xFE2CE6E0);\n      c = ii(c, d, a, b, buffer[i+ 6], 15, 0xA3014314);\n      b = ii(b, c, d, a, buffer[i+13], 21, 0x4E0811A1);\n      a = ii(a, b, c, d, buffer[i+ 4], 6, 0xF7537E82);\n      d = ii(d, a, b, c, buffer[i+11], 10, 0xBD3AF235);\n      c = ii(c, d, a, b, buffer[i+ 2], 15, 0x2AD7D2BB);\n      b = ii(b, c, d, a, buffer[i+ 9], 21, 0xEB86D391);\n\n      w[0] = add(a, w[0]);\n      w[1] = add(b, w[1]);\n      w[2] = add(c, w[2]);\n      w[3] = add(d, w[3]);\n    }\n\n    var t = new Array(16);\n    for (var i = 0; i < 4; i++)\n      for (var j = 0; j < 4; j++)\n        t[i * 4 + j] = (w[i] >> (8 * j)) & 0xFF;\n    return t;\n  }\n\n  return function (s, ofs, len) {\n    // FIX: maybe we should perform the computation by chunk of 64 bytes\n    // as in http://www.myersdaily.org/joseph/javascript/md5.js\n    var buf = [];\n    switch (s.t & 6) {\n    default:\n      caml_convert_string_to_bytes(s);\n    case 0: /* BYTES */\n      var b = s.c;\n      for (var i = 0; i < len; i+=4) {\n        var j = i + ofs;\n        buf[i>>2] =\n          b.charCodeAt(j) | (b.charCodeAt(j+1) << 8) |\n          (b.charCodeAt(j+2) << 16) | (b.charCodeAt(j+3) << 24);\n      }\n      for (; i < len; i++) buf[i>>2] |= b.charCodeAt(i + ofs) << (8 * (i & 3));\n      break;\n    case 4: /* ARRAY */\n      var a = s.c;\n      for (var i = 0; i < len; i+=4) {\n        var j = i + ofs;\n        buf[i>>2] = a[j] | (a[j+1] << 8) | (a[j+2] << 16) | (a[j+3] << 24);\n      }\n      for (; i < len; i++) buf[i>>2] |= a[i + ofs] << (8 * (i & 3));\n    }\n    return caml_string_of_array(md5(buf, len));\n  }\n} ();\n",
  "/* Open for operators */\nlet start () => {\n  open Helpers;\n  let module Node = Nodejs.Bindings_utils;\n  let express = Node.require_module \"express\";\n  let app = express |>> [||];\n  let http = Node.m (Node.require_module \"http\") \"Server\" [|!!app|];\n  let absolutePath = \"/Users/sansouci/Desktop/tapknight\";\n  ignore @@ Node.m app \"use\" [|Node.m express \"static\" [|putStr absolutePath|]|];\n  ignore @@\n  Node.m\n    app\n    \"get\"\n    [|\n      putStr \"/\",\n      !!\n        !@(\n          fun req res next =>\n            Node.m\n              res\n              \"sendFile\"\n              [|putStr \"index.html\", Js.Unsafe.obj [|(\"root\", putStr absolutePath)|]|]\n        )\n    |];\n  let socketio = Node.require_module \"socket.io\";\n  let io = socketio |>> [|http|];\n  let otherDudes: ref (list Client.dudeT) = ref [];\n  ignore @@\n  Node.m\n    io\n    \"on\"\n    [|\n      putStr \"connection\",\n      !!\n        !@(\n          fun socket => {\n            print_endline \"A user connected!\";\n            ignore @@\n            Node.m\n              socket\n              \"on\"\n              [|\n                putStr \"disconnect\",\n                !!\n                  !@(\n                    fun () => {\n                      print_endline \"Some dude called\";\n                      let dude: Client.dudeT = Js.Unsafe.get socket \"dude\";\n                      otherDudes :=\n                        List.filter (fun (value: Client.dudeT) => value.id != dude.id) !otherDudes\n                    }\n                  )\n              |]\n              ignore @@\n            Node.m\n              socket\n              \"on\"\n              [|\n                putStr \"action\",\n                !!\n                  !@(\n                    fun (x: Clientsocket.actionT 'a) => {\n                      switch x.typ {\n                      | \"new-dude-arrived\" =>\n                        print_endline \"new-dude-arrived\";\n                        let dude: Client.dudeT = x.packet;\n                        /* Shove the dude inside the socket for disconnect event. Deal with it. */\n                        Js.Unsafe.set socket \"dude\" dude;\n                        otherDudes := !otherDudes @ [dude]\n                      | _ => ()\n                      };\n                      Node.m (Js.Unsafe.get socket \"broadcast\") \"emit\" [|putStr \"action\", !!x|]\n                    }\n                  )\n              |];\n            List.map\n              (\n                fun otherDude =>\n                  Node.m\n                    socket\n                    \"emit\"\n                    [|\n                      putStr \"action\",\n                      !!Clientsocket.{typ: \"new-dude-arrived\", packet: otherDude}\n                    |]\n              )\n              !otherDudes\n          }\n        )\n    |];\n  ignore @@\n  Node.m\n    http\n    \"listen\"\n    [|!!3000, !!(Js.wrap_meth_callback (fun () => print_endline \"asdljhdashkasdhjk\"))|];\n  ()\n};\n",
  "(***********************************************************************)\n(*                                                                     *)\n(*                                OCaml                                *)\n(*                                                                     *)\n(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)\n(*                                                                     *)\n(*  Copyright 1996 Institut National de Recherche en Informatique et   *)\n(*  en Automatique.  All rights reserved.  This file is distributed    *)\n(*  under the terms of the GNU Library General Public License, with    *)\n(*  the special exception on linking described in file ../LICENSE.     *)\n(*                                                                     *)\n(***********************************************************************)\n\n(* type 'a option = None | Some of 'a *)\n\n(* Exceptions *)\n\nexternal register_named_value : string -> 'a -> unit\n                              = \"caml_register_named_value\"\n\nlet () =\n  (* for asmrun/fail.c *)\n  register_named_value \"Pervasives.array_bound_error\"\n    (Invalid_argument \"index out of bounds\")\n\n\nexternal raise : exn -> 'a = \"%raise\"\nexternal raise_notrace : exn -> 'a = \"%raise_notrace\"\n\nlet failwith s = raise(Failure s)\nlet invalid_arg s = raise(Invalid_argument s)\n\nexception Exit\n\n(* Composition operators *)\n\nexternal ( |> ) : 'a -> ('a -> 'b) -> 'b = \"%revapply\"\nexternal ( @@ ) : ('a -> 'b) -> 'a -> 'b = \"%apply\"\n\n(* Debugging *)\n\nexternal __LOC__ : string = \"%loc_LOC\"\nexternal __FILE__ : string = \"%loc_FILE\"\nexternal __LINE__ : int = \"%loc_LINE\"\nexternal __MODULE__ : string = \"%loc_MODULE\"\nexternal __POS__ : string * int * int * int = \"%loc_POS\"\n\nexternal __LOC_OF__ : 'a -> string * 'a = \"%loc_LOC\"\nexternal __LINE_OF__ : 'a -> int * 'a = \"%loc_LINE\"\nexternal __POS_OF__ : 'a -> (string * int * int * int) * 'a = \"%loc_POS\"\n\n(* Comparisons *)\n\nexternal ( = ) : 'a -> 'a -> bool = \"%equal\"\nexternal ( <> ) : 'a -> 'a -> bool = \"%notequal\"\nexternal ( < ) : 'a -> 'a -> bool = \"%lessthan\"\nexternal ( > ) : 'a -> 'a -> bool = \"%greaterthan\"\nexternal ( <= ) : 'a -> 'a -> bool = \"%lessequal\"\nexternal ( >= ) : 'a -> 'a -> bool = \"%greaterequal\"\nexternal compare : 'a -> 'a -> int = \"%compare\"\n\nlet min x y = if x <= y then x else y\nlet max x y = if x >= y then x else y\n\nexternal ( == ) : 'a -> 'a -> bool = \"%eq\"\nexternal ( != ) : 'a -> 'a -> bool = \"%noteq\"\n\n(* Boolean operations *)\n\nexternal not : bool -> bool = \"%boolnot\"\nexternal ( & ) : bool -> bool -> bool = \"%sequand\"\nexternal ( && ) : bool -> bool -> bool = \"%sequand\"\nexternal ( or ) : bool -> bool -> bool = \"%sequor\"\nexternal ( || ) : bool -> bool -> bool = \"%sequor\"\n\n(* Integer operations *)\n\nexternal ( ~- ) : int -> int = \"%negint\"\nexternal ( ~+ ) : int -> int = \"%identity\"\nexternal succ : int -> int = \"%succint\"\nexternal pred : int -> int = \"%predint\"\nexternal ( + ) : int -> int -> int = \"%addint\"\nexternal ( - ) : int -> int -> int = \"%subint\"\nexternal ( * ) : int -> int -> int = \"%mulint\"\nexternal ( / ) : int -> int -> int = \"%divint\"\nexternal ( mod ) : int -> int -> int = \"%modint\"\n\nlet abs x = if x >= 0 then x else -x\n\nexternal ( land ) : int -> int -> int = \"%andint\"\nexternal ( lor ) : int -> int -> int = \"%orint\"\nexternal ( lxor ) : int -> int -> int = \"%xorint\"\n\nlet lnot x = x lxor (-1)\n\nexternal ( lsl ) : int -> int -> int = \"%lslint\"\nexternal ( lsr ) : int -> int -> int = \"%lsrint\"\nexternal ( asr ) : int -> int -> int = \"%asrint\"\n\nlet max_int = (-1) lsr 1\nlet min_int = max_int + 1\n\n(* Floating-point operations *)\n\nexternal ( ~-. ) : float -> float = \"%negfloat\"\nexternal ( ~+. ) : float -> float = \"%identity\"\nexternal ( +. ) : float -> float -> float = \"%addfloat\"\nexternal ( -. ) : float -> float -> float = \"%subfloat\"\nexternal ( *. ) : float -> float -> float = \"%mulfloat\"\nexternal ( /. ) : float -> float -> float = \"%divfloat\"\nexternal ( ** ) : float -> float -> float = \"caml_power_float\" \"pow\" \"float\"\nexternal exp : float -> float = \"caml_exp_float\" \"exp\" \"float\"\nexternal expm1 : float -> float = \"caml_expm1_float\" \"caml_expm1\" \"float\"\nexternal acos : float -> float = \"caml_acos_float\" \"acos\" \"float\"\nexternal asin : float -> float = \"caml_asin_float\" \"asin\" \"float\"\nexternal atan : float -> float = \"caml_atan_float\" \"atan\" \"float\"\nexternal atan2 : float -> float -> float = \"caml_atan2_float\" \"atan2\" \"float\"\nexternal hypot : float -> float -> float\n               = \"caml_hypot_float\" \"caml_hypot\" \"float\"\nexternal cos : float -> float = \"caml_cos_float\" \"cos\" \"float\"\nexternal cosh : float -> float = \"caml_cosh_float\" \"cosh\" \"float\"\nexternal log : float -> float = \"caml_log_float\" \"log\" \"float\"\nexternal log10 : float -> float = \"caml_log10_float\" \"log10\" \"float\"\nexternal log1p : float -> float = \"caml_log1p_float\" \"caml_log1p\" \"float\"\nexternal sin : float -> float = \"caml_sin_float\" \"sin\" \"float\"\nexternal sinh : float -> float = \"caml_sinh_float\" \"sinh\" \"float\"\nexternal sqrt : float -> float = \"caml_sqrt_float\" \"sqrt\" \"float\"\nexternal tan : float -> float = \"caml_tan_float\" \"tan\" \"float\"\nexternal tanh : float -> float = \"caml_tanh_float\" \"tanh\" \"float\"\nexternal ceil : float -> float = \"caml_ceil_float\" \"ceil\" \"float\"\nexternal floor : float -> float = \"caml_floor_float\" \"floor\" \"float\"\nexternal abs_float : float -> float = \"%absfloat\"\nexternal copysign : float -> float -> float\n                  = \"caml_copysign_float\" \"caml_copysign\" \"float\"\nexternal mod_float : float -> float -> float = \"caml_fmod_float\" \"fmod\" \"float\"\nexternal frexp : float -> float * int = \"caml_frexp_float\"\nexternal ldexp : float -> int -> float = \"caml_ldexp_float\"\nexternal modf : float -> float * float = \"caml_modf_float\"\nexternal float : int -> float = \"%floatofint\"\nexternal float_of_int : int -> float = \"%floatofint\"\nexternal truncate : float -> int = \"%intoffloat\"\nexternal int_of_float : float -> int = \"%intoffloat\"\nexternal float_of_bits : int64 -> float = \"caml_int64_float_of_bits\"\nlet infinity =\n  float_of_bits 0x7F_F0_00_00_00_00_00_00L\nlet neg_infinity =\n  float_of_bits 0xFF_F0_00_00_00_00_00_00L\nlet nan =\n  float_of_bits 0x7F_F0_00_00_00_00_00_01L\nlet max_float =\n  float_of_bits 0x7F_EF_FF_FF_FF_FF_FF_FFL\nlet min_float =\n  float_of_bits 0x00_10_00_00_00_00_00_00L\nlet epsilon_float =\n  float_of_bits 0x3C_B0_00_00_00_00_00_00L\n\ntype fpclass =\n    FP_normal\n  | FP_subnormal\n  | FP_zero\n  | FP_infinite\n  | FP_nan\nexternal classify_float : float -> fpclass = \"caml_classify_float\"\n\n(* String and byte sequence operations -- more in modules String and Bytes *)\n\nexternal string_length : string -> int = \"%string_length\"\nexternal bytes_length : bytes -> int = \"%string_length\"\nexternal bytes_create : int -> bytes = \"caml_create_string\"\nexternal string_blit : string -> int -> bytes -> int -> int -> unit\n                     = \"caml_blit_string\" \"noalloc\"\nexternal bytes_blit : bytes -> int -> bytes -> int -> int -> unit\n                        = \"caml_blit_string\" \"noalloc\"\nexternal bytes_unsafe_to_string : bytes -> string = \"%identity\"\nexternal bytes_unsafe_of_string : string -> bytes = \"%identity\"\n\nlet ( ^ ) s1 s2 =\n  let l1 = string_length s1 and l2 = string_length s2 in\n  let s = bytes_create (l1 + l2) in\n  string_blit s1 0 s 0 l1;\n  string_blit s2 0 s l1 l2;\n  bytes_unsafe_to_string s\n\n(* Character operations -- more in module Char *)\n\nexternal int_of_char : char -> int = \"%identity\"\nexternal unsafe_char_of_int : int -> char = \"%identity\"\nlet char_of_int n =\n  if n < 0 || n > 255 then invalid_arg \"char_of_int\" else unsafe_char_of_int n\n\n(* Unit operations *)\n\nexternal ignore : 'a -> unit = \"%ignore\"\n\n(* Pair operations *)\n\nexternal fst : 'a * 'b -> 'a = \"%field0\"\nexternal snd : 'a * 'b -> 'b = \"%field1\"\n\n(* References *)\n\ntype 'a ref = { mutable contents : 'a }\nexternal ref : 'a -> 'a ref = \"%makemutable\"\nexternal ( ! ) : 'a ref -> 'a = \"%field0\"\nexternal ( := ) : 'a ref -> 'a -> unit = \"%setfield0\"\nexternal incr : int ref -> unit = \"%incr\"\nexternal decr : int ref -> unit = \"%decr\"\n\n(* String conversion functions *)\n\nexternal format_int : string -> int -> string = \"caml_format_int\"\nexternal format_float : string -> float -> string = \"caml_format_float\"\n\nlet string_of_bool b =\n  if b then \"true\" else \"false\"\nlet bool_of_string = function\n  | \"true\" -> true\n  | \"false\" -> false\n  | _ -> invalid_arg \"bool_of_string\"\n\nlet string_of_int n =\n  format_int \"%d\" n\n\nexternal int_of_string : string -> int = \"caml_int_of_string\"\nexternal string_get : string -> int -> char = \"%string_safe_get\"\n\nlet valid_float_lexem s =\n  let l = string_length s in\n  let rec loop i =\n    if i >= l then s ^ \".\" else\n    match string_get s i with\n    | '0' .. '9' | '-' -> loop (i + 1)\n    | _ -> s\n  in\n  loop 0\n;;\n\nlet string_of_float f = valid_float_lexem (format_float \"%.12g\" f);;\n\nexternal float_of_string : string -> float = \"caml_float_of_string\"\n\n(* List operations -- more in module List *)\n\nlet rec ( @ ) l1 l2 =\n  match l1 with\n    [] -> l2\n  | hd :: tl -> hd :: (tl @ l2)\n\n(* I/O operations *)\n\ntype in_channel\ntype out_channel\n\nexternal open_descriptor_out : int -> out_channel\n                             = \"caml_ml_open_descriptor_out\"\nexternal open_descriptor_in : int -> in_channel = \"caml_ml_open_descriptor_in\"\n\nlet stdin = open_descriptor_in 0\nlet stdout = open_descriptor_out 1\nlet stderr = open_descriptor_out 2\n\n(* General output functions *)\n\ntype open_flag =\n    Open_rdonly | Open_wronly | Open_append\n  | Open_creat | Open_trunc | Open_excl\n  | Open_binary | Open_text | Open_nonblock\n\nexternal open_desc : string -> open_flag list -> int -> int = \"caml_sys_open\"\n\nlet open_out_gen mode perm name =\n  open_descriptor_out(open_desc name mode perm)\n\nlet open_out name =\n  open_out_gen [Open_wronly; Open_creat; Open_trunc; Open_text] 0o666 name\n\nlet open_out_bin name =\n  open_out_gen [Open_wronly; Open_creat; Open_trunc; Open_binary] 0o666 name\n\nexternal flush : out_channel -> unit = \"caml_ml_flush\"\n\nexternal out_channels_list : unit -> out_channel list\n                           = \"caml_ml_out_channels_list\"\n\nlet flush_all () =\n  let rec iter = function\n      [] -> ()\n    | a :: l -> (try flush a with _ -> ()); iter l\n  in iter (out_channels_list ())\n\nexternal unsafe_output : out_channel -> bytes -> int -> int -> unit\n                       = \"caml_ml_output\"\nexternal unsafe_output_string : out_channel -> string -> int -> int -> unit\n                              = \"caml_ml_output\"\n\nexternal output_char : out_channel -> char -> unit = \"caml_ml_output_char\"\n\nlet output_bytes oc s =\n  unsafe_output oc s 0 (bytes_length s)\n\nlet output_string oc s =\n  unsafe_output_string oc s 0 (string_length s)\n\nlet output oc s ofs len =\n  if ofs < 0 || len < 0 || ofs > bytes_length s - len\n  then invalid_arg \"output\"\n  else unsafe_output oc s ofs len\n\nlet output_substring oc s ofs len =\n  if ofs < 0 || len < 0 || ofs > string_length s - len\n  then invalid_arg \"output_substring\"\n  else unsafe_output_string oc s ofs len\n\nexternal output_byte : out_channel -> int -> unit = \"caml_ml_output_char\"\nexternal output_binary_int : out_channel -> int -> unit = \"caml_ml_output_int\"\n\nexternal marshal_to_channel : out_channel -> 'a -> unit list -> unit\n     = \"caml_output_value\"\nlet output_value chan v = marshal_to_channel chan v []\n\nexternal seek_out : out_channel -> int -> unit = \"caml_ml_seek_out\"\nexternal pos_out : out_channel -> int = \"caml_ml_pos_out\"\nexternal out_channel_length : out_channel -> int = \"caml_ml_channel_size\"\nexternal close_out_channel : out_channel -> unit = \"caml_ml_close_channel\"\nlet close_out oc = flush oc; close_out_channel oc\nlet close_out_noerr oc =\n  (try flush oc with _ -> ());\n  (try close_out_channel oc with _ -> ())\nexternal set_binary_mode_out : out_channel -> bool -> unit\n                             = \"caml_ml_set_binary_mode\"\n\n(* General input functions *)\n\nlet open_in_gen mode perm name =\n  open_descriptor_in(open_desc name mode perm)\n\nlet open_in name =\n  open_in_gen [Open_rdonly; Open_text] 0 name\n\nlet open_in_bin name =\n  open_in_gen [Open_rdonly; Open_binary] 0 name\n\nexternal input_char : in_channel -> char = \"caml_ml_input_char\"\n\nexternal unsafe_input : in_channel -> bytes -> int -> int -> int\n                      = \"caml_ml_input\"\n\nlet input ic s ofs len =\n  if ofs < 0 || len < 0 || ofs > bytes_length s - len\n  then invalid_arg \"input\"\n  else unsafe_input ic s ofs len\n\nlet rec unsafe_really_input ic s ofs len =\n  if len <= 0 then () else begin\n    let r = unsafe_input ic s ofs len in\n    if r = 0\n    then raise End_of_file\n    else unsafe_really_input ic s (ofs + r) (len - r)\n  end\n\nlet really_input ic s ofs len =\n  if ofs < 0 || len < 0 || ofs > bytes_length s - len\n  then invalid_arg \"really_input\"\n  else unsafe_really_input ic s ofs len\n\nlet really_input_string ic len =\n  let s = bytes_create len in\n  really_input ic s 0 len;\n  bytes_unsafe_to_string s\n\nexternal input_scan_line : in_channel -> int = \"caml_ml_input_scan_line\"\n\nlet input_line chan =\n  let rec build_result buf pos = function\n    [] -> buf\n  | hd :: tl ->\n      let len = bytes_length hd in\n      bytes_blit hd 0 buf (pos - len) len;\n      build_result buf (pos - len) tl in\n  let rec scan accu len =\n    let n = input_scan_line chan in\n    if n = 0 then begin                   (* n = 0: we are at EOF *)\n      match accu with\n        [] -> raise End_of_file\n      | _  -> build_result (bytes_create len) len accu\n    end else if n > 0 then begin          (* n > 0: newline found in buffer *)\n      let res = bytes_create (n - 1) in\n      ignore (unsafe_input chan res 0 (n - 1));\n      ignore (input_char chan);           (* skip the newline *)\n      match accu with\n        [] -> res\n      |  _ -> let len = len + n - 1 in\n              build_result (bytes_create len) len (res :: accu)\n    end else begin                        (* n < 0: newline not found *)\n      let beg = bytes_create (-n) in\n      ignore(unsafe_input chan beg 0 (-n));\n      scan (beg :: accu) (len - n)\n    end\n  in bytes_unsafe_to_string (scan [] 0)\n\nexternal input_byte : in_channel -> int = \"caml_ml_input_char\"\nexternal input_binary_int : in_channel -> int = \"caml_ml_input_int\"\nexternal input_value : in_channel -> 'a = \"caml_input_value\"\nexternal seek_in : in_channel -> int -> unit = \"caml_ml_seek_in\"\nexternal pos_in : in_channel -> int = \"caml_ml_pos_in\"\nexternal in_channel_length : in_channel -> int = \"caml_ml_channel_size\"\nexternal close_in : in_channel -> unit = \"caml_ml_close_channel\"\nlet close_in_noerr ic = (try close_in ic with _ -> ());;\nexternal set_binary_mode_in : in_channel -> bool -> unit\n                            = \"caml_ml_set_binary_mode\"\n\n(* Output functions on standard output *)\n\nlet print_char c = output_char stdout c\nlet print_string s = output_string stdout s\nlet print_bytes s = output_bytes stdout s\nlet print_int i = output_string stdout (string_of_int i)\nlet print_float f = output_string stdout (string_of_float f)\nlet print_endline s =\n  output_string stdout s; output_char stdout '\\n'; flush stdout\nlet print_newline () = output_char stdout '\\n'; flush stdout\n\n(* Output functions on standard error *)\n\nlet prerr_char c = output_char stderr c\nlet prerr_string s = output_string stderr s\nlet prerr_bytes s = output_bytes stderr s\nlet prerr_int i = output_string stderr (string_of_int i)\nlet prerr_float f = output_string stderr (string_of_float f)\nlet prerr_endline s =\n  output_string stderr s; output_char stderr '\\n'; flush stderr\nlet prerr_newline () = output_char stderr '\\n'; flush stderr\n\n(* Input functions on standard input *)\n\nlet read_line () = flush stdout; input_line stdin\nlet read_int () = int_of_string(read_line())\nlet read_float () = float_of_string(read_line())\n\n(* Operations on large files *)\n\nmodule LargeFile =\n  struct\n    external seek_out : out_channel -> int64 -> unit = \"caml_ml_seek_out_64\"\n    external pos_out : out_channel -> int64 = \"caml_ml_pos_out_64\"\n    external out_channel_length : out_channel -> int64\n                                = \"caml_ml_channel_size_64\"\n    external seek_in : in_channel -> int64 -> unit = \"caml_ml_seek_in_64\"\n    external pos_in : in_channel -> int64 = \"caml_ml_pos_in_64\"\n    external in_channel_length : in_channel -> int64 = \"caml_ml_channel_size_64\"\n  end\n\n(* Formats *)\n\ntype ('a, 'b, 'c, 'd, 'e, 'f) format6\n   = ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.format6\n   = Format of ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.fmt\n               * string\n\ntype ('a, 'b, 'c, 'd) format4 = ('a, 'b, 'c, 'c, 'c, 'd) format6\n\ntype ('a, 'b, 'c) format = ('a, 'b, 'c, 'c) format4\n\nlet string_of_format (Format (fmt, str)) = str\n\nexternal format_of_string :\n ('a, 'b, 'c, 'd, 'e, 'f) format6 ->\n ('a, 'b, 'c, 'd, 'e, 'f) format6 = \"%identity\"\n\nlet (^^) (Format (fmt1, str1)) (Format (fmt2, str2)) =\n  Format (CamlinternalFormatBasics.concat_fmt fmt1 fmt2,\n          str1 ^ \"%,\" ^ str2)\n\n(* Miscellaneous *)\n\nexternal sys_exit : int -> 'a = \"caml_sys_exit\"\n\nlet exit_function = ref flush_all\n\nlet at_exit f =\n  let g = !exit_function in\n  exit_function := (fun () -> f(); g())\n\nlet do_at_exit () = (!exit_function) ()\n\nlet exit retcode =\n  do_at_exit ();\n  sys_exit retcode\n\nlet _ = register_named_value \"Pervasives.do_at_exit\" do_at_exit\n",
  "(***********************************************************************)\n(*                                                                     *)\n(*                           OCaml                                     *)\n(*                                                                     *)\n(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)\n(*                                                                     *)\n(*  Copyright 1996 Institut National de Recherche en Informatique et   *)\n(*  en Automatique.  All rights reserved.  This file is distributed    *)\n(*  under the terms of the GNU Library General Public License, with    *)\n(*  the special exception on linking described in file ../LICENSE.     *)\n(*                                                                     *)\n(***********************************************************************)\n\n(* Array operations *)\n\nexternal length : 'a array -> int = \"%array_length\"\nexternal get: 'a array -> int -> 'a = \"%array_safe_get\"\nexternal set: 'a array -> int -> 'a -> unit = \"%array_safe_set\"\nexternal unsafe_get: 'a array -> int -> 'a = \"%array_unsafe_get\"\nexternal unsafe_set: 'a array -> int -> 'a -> unit = \"%array_unsafe_set\"\nexternal make: int -> 'a -> 'a array = \"caml_make_vect\"\nexternal create: int -> 'a -> 'a array = \"caml_make_vect\"\nexternal unsafe_sub : 'a array -> int -> int -> 'a array = \"caml_array_sub\"\nexternal append_prim : 'a array -> 'a array -> 'a array = \"caml_array_append\"\nexternal concat : 'a array list -> 'a array = \"caml_array_concat\"\nexternal unsafe_blit :\n  'a array -> int -> 'a array -> int -> int -> unit = \"caml_array_blit\"\nexternal make_float: int -> float array = \"caml_make_float_vect\"\n\nlet init l f =\n  if l = 0 then [||] else\n  if l < 0 then invalid_arg \"Array.init\"\n  (* See #6575. We could also check for maximum array size, but this depends\n     on whether we create a float array or a regular one... *)\n  else\n   let res = create l (f 0) in\n   for i = 1 to pred l do\n     unsafe_set res i (f i)\n   done;\n   res\n\nlet make_matrix sx sy init =\n  let res = create sx [||] in\n  for x = 0 to pred sx do\n    unsafe_set res x (create sy init)\n  done;\n  res\n\nlet create_matrix = make_matrix\n\nlet copy a =\n  let l = length a in if l = 0 then [||] else unsafe_sub a 0 l\n\nlet append a1 a2 =\n  let l1 = length a1 in\n  if l1 = 0 then copy a2\n  else if length a2 = 0 then unsafe_sub a1 0 l1\n  else append_prim a1 a2\n\nlet sub a ofs len =\n  if len < 0 || ofs > length a - len\n  then invalid_arg \"Array.sub\"\n  else unsafe_sub a ofs len\n\nlet fill a ofs len v =\n  if ofs < 0 || len < 0 || ofs > length a - len\n  then invalid_arg \"Array.fill\"\n  else for i = ofs to ofs + len - 1 do unsafe_set a i v done\n\nlet blit a1 ofs1 a2 ofs2 len =\n  if len < 0 || ofs1 < 0 || ofs1 > length a1 - len\n             || ofs2 < 0 || ofs2 > length a2 - len\n  then invalid_arg \"Array.blit\"\n  else unsafe_blit a1 ofs1 a2 ofs2 len\n\nlet iter f a =\n  for i = 0 to length a - 1 do f(unsafe_get a i) done\n\nlet map f a =\n  let l = length a in\n  if l = 0 then [||] else begin\n    let r = create l (f(unsafe_get a 0)) in\n    for i = 1 to l - 1 do\n      unsafe_set r i (f(unsafe_get a i))\n    done;\n    r\n  end\n\nlet iteri f a =\n  for i = 0 to length a - 1 do f i (unsafe_get a i) done\n\nlet mapi f a =\n  let l = length a in\n  if l = 0 then [||] else begin\n    let r = create l (f 0 (unsafe_get a 0)) in\n    for i = 1 to l - 1 do\n      unsafe_set r i (f i (unsafe_get a i))\n    done;\n    r\n  end\n\nlet to_list a =\n  let rec tolist i res =\n    if i < 0 then res else tolist (i - 1) (unsafe_get a i :: res) in\n  tolist (length a - 1) []\n\n(* Cannot use List.length here because the List module depends on Array. *)\nlet rec list_length accu = function\n  | [] -> accu\n  | h::t -> list_length (succ accu) t\n;;\n\nlet of_list = function\n    [] -> [||]\n  | hd::tl as l ->\n      let a = create (list_length 0 l) hd in\n      let rec fill i = function\n          [] -> a\n        | hd::tl -> unsafe_set a i hd; fill (i+1) tl in\n      fill 1 tl\n\nlet fold_left f x a =\n  let r = ref x in\n  for i = 0 to length a - 1 do\n    r := f !r (unsafe_get a i)\n  done;\n  !r\n\nlet fold_right f a x =\n  let r = ref x in\n  for i = length a - 1 downto 0 do\n    r := f (unsafe_get a i) !r\n  done;\n  !r\n\nexception Bottom of int;;\nlet sort cmp a =\n  let maxson l i =\n    let i31 = i+i+i+1 in\n    let x = ref i31 in\n    if i31+2 < l then begin\n      if cmp (get a i31) (get a (i31+1)) < 0 then x := i31+1;\n      if cmp (get a !x) (get a (i31+2)) < 0 then x := i31+2;\n      !x\n    end else\n      if i31+1 < l && cmp (get a i31) (get a (i31+1)) < 0\n      then i31+1\n      else if i31 < l then i31 else raise (Bottom i)\n  in\n  let rec trickledown l i e =\n    let j = maxson l i in\n    if cmp (get a j) e > 0 then begin\n      set a i (get a j);\n      trickledown l j e;\n    end else begin\n      set a i e;\n    end;\n  in\n  let trickle l i e = try trickledown l i e with Bottom i -> set a i e in\n  let rec bubbledown l i =\n    let j = maxson l i in\n    set a i (get a j);\n    bubbledown l j\n  in\n  let bubble l i = try bubbledown l i with Bottom i -> i in\n  let rec trickleup i e =\n    let father = (i - 1) / 3 in\n    assert (i <> father);\n    if cmp (get a father) e < 0 then begin\n      set a i (get a father);\n      if father > 0 then trickleup father e else set a 0 e;\n    end else begin\n      set a i e;\n    end;\n  in\n  let l = length a in\n  for i = (l + 1) / 3 - 1 downto 0 do trickle l i (get a i); done;\n  for i = l - 1 downto 2 do\n    let e = (get a i) in\n    set a i (get a 0);\n    trickleup (bubble i 0) e;\n  done;\n  if l > 1 then (let e = (get a 1) in set a 1 (get a 0); set a 0 e);\n;;\n\nlet cutoff = 5;;\nlet stable_sort cmp a =\n  let merge src1ofs src1len src2 src2ofs src2len dst dstofs =\n    let src1r = src1ofs + src1len and src2r = src2ofs + src2len in\n    let rec loop i1 s1 i2 s2 d =\n      if cmp s1 s2 <= 0 then begin\n        set dst d s1;\n        let i1 = i1 + 1 in\n        if i1 < src1r then\n          loop i1 (get a i1) i2 s2 (d + 1)\n        else\n          blit src2 i2 dst (d + 1) (src2r - i2)\n      end else begin\n        set dst d s2;\n        let i2 = i2 + 1 in\n        if i2 < src2r then\n          loop i1 s1 i2 (get src2 i2) (d + 1)\n        else\n          blit a i1 dst (d + 1) (src1r - i1)\n      end\n    in loop src1ofs (get a src1ofs) src2ofs (get src2 src2ofs) dstofs;\n  in\n  let isortto srcofs dst dstofs len =\n    for i = 0 to len - 1 do\n      let e = (get a (srcofs + i)) in\n      let j = ref (dstofs + i - 1) in\n      while (!j >= dstofs && cmp (get dst !j) e > 0) do\n        set dst (!j + 1) (get dst !j);\n        decr j;\n      done;\n      set dst (!j + 1) e;\n    done;\n  in\n  let rec sortto srcofs dst dstofs len =\n    if len <= cutoff then isortto srcofs dst dstofs len else begin\n      let l1 = len / 2 in\n      let l2 = len - l1 in\n      sortto (srcofs + l1) dst (dstofs + l1) l2;\n      sortto srcofs a (srcofs + l2) l1;\n      merge (srcofs + l2) l1 dst (dstofs + l1) l2 dst dstofs;\n    end;\n  in\n  let l = length a in\n  if l <= cutoff then isortto 0 a 0 l else begin\n    let l1 = l / 2 in\n    let l2 = l - l1 in\n    let t = make l2 (get a 0) in\n    sortto l1 t 0 l2;\n    sortto 0 a l2 l1;\n    merge l2 l1 t 0 l2 a 0;\n  end;\n;;\n\nlet fast_sort = stable_sort;;\n",
  "(***********************************************************************)\n(*                                                                     *)\n(*                                OCaml                                *)\n(*                                                                     *)\n(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)\n(*                                                                     *)\n(*  Copyright 1996 Institut National de Recherche en Informatique et   *)\n(*  en Automatique.  All rights reserved.  This file is distributed    *)\n(*  under the terms of the GNU Library General Public License, with    *)\n(*  the special exception on linking described in file ../LICENSE.     *)\n(*                                                                     *)\n(***********************************************************************)\n\n(* List operations *)\n\nlet rec length_aux len = function\n    [] -> len\n  | a::l -> length_aux (len + 1) l\n\nlet length l = length_aux 0 l\n\nlet hd = function\n    [] -> failwith \"hd\"\n  | a::l -> a\n\nlet tl = function\n    [] -> failwith \"tl\"\n  | a::l -> l\n\nlet nth l n =\n  if n < 0 then invalid_arg \"List.nth\" else\n  let rec nth_aux l n =\n    match l with\n    | [] -> failwith \"nth\"\n    | a::l -> if n = 0 then a else nth_aux l (n-1)\n  in nth_aux l n\n\nlet append = (@)\n\nlet rec rev_append l1 l2 =\n  match l1 with\n    [] -> l2\n  | a :: l -> rev_append l (a :: l2)\n\nlet rev l = rev_append l []\n\nlet rec flatten = function\n    [] -> []\n  | l::r -> l @ flatten r\n\nlet concat = flatten\n\nlet rec map f = function\n    [] -> []\n  | a::l -> let r = f a in r :: map f l\n\nlet rec mapi i f = function\n    [] -> []\n  | a::l -> let r = f i a in r :: mapi (i + 1) f l\n\nlet mapi f l = mapi 0 f l\n\nlet rev_map f l =\n  let rec rmap_f accu = function\n    | [] -> accu\n    | a::l -> rmap_f (f a :: accu) l\n  in\n  rmap_f [] l\n;;\n\nlet rec iter f = function\n    [] -> ()\n  | a::l -> f a; iter f l\n\nlet rec iteri i f = function\n    [] -> ()\n  | a::l -> f i a; iteri (i + 1) f l\n\nlet iteri f l = iteri 0 f l\n\nlet rec fold_left f accu l =\n  match l with\n    [] -> accu\n  | a::l -> fold_left f (f accu a) l\n\nlet rec fold_right f l accu =\n  match l with\n    [] -> accu\n  | a::l -> f a (fold_right f l accu)\n\nlet rec map2 f l1 l2 =\n  match (l1, l2) with\n    ([], []) -> []\n  | (a1::l1, a2::l2) -> let r = f a1 a2 in r :: map2 f l1 l2\n  | (_, _) -> invalid_arg \"List.map2\"\n\nlet rev_map2 f l1 l2 =\n  let rec rmap2_f accu l1 l2 =\n    match (l1, l2) with\n    | ([], []) -> accu\n    | (a1::l1, a2::l2) -> rmap2_f (f a1 a2 :: accu) l1 l2\n    | (_, _) -> invalid_arg \"List.rev_map2\"\n  in\n  rmap2_f [] l1 l2\n;;\n\nlet rec iter2 f l1 l2 =\n  match (l1, l2) with\n    ([], []) -> ()\n  | (a1::l1, a2::l2) -> f a1 a2; iter2 f l1 l2\n  | (_, _) -> invalid_arg \"List.iter2\"\n\nlet rec fold_left2 f accu l1 l2 =\n  match (l1, l2) with\n    ([], []) -> accu\n  | (a1::l1, a2::l2) -> fold_left2 f (f accu a1 a2) l1 l2\n  | (_, _) -> invalid_arg \"List.fold_left2\"\n\nlet rec fold_right2 f l1 l2 accu =\n  match (l1, l2) with\n    ([], []) -> accu\n  | (a1::l1, a2::l2) -> f a1 a2 (fold_right2 f l1 l2 accu)\n  | (_, _) -> invalid_arg \"List.fold_right2\"\n\nlet rec for_all p = function\n    [] -> true\n  | a::l -> p a && for_all p l\n\nlet rec exists p = function\n    [] -> false\n  | a::l -> p a || exists p l\n\nlet rec for_all2 p l1 l2 =\n  match (l1, l2) with\n    ([], []) -> true\n  | (a1::l1, a2::l2) -> p a1 a2 && for_all2 p l1 l2\n  | (_, _) -> invalid_arg \"List.for_all2\"\n\nlet rec exists2 p l1 l2 =\n  match (l1, l2) with\n    ([], []) -> false\n  | (a1::l1, a2::l2) -> p a1 a2 || exists2 p l1 l2\n  | (_, _) -> invalid_arg \"List.exists2\"\n\nlet rec mem x = function\n    [] -> false\n  | a::l -> compare a x = 0 || mem x l\n\nlet rec memq x = function\n    [] -> false\n  | a::l -> a == x || memq x l\n\nlet rec assoc x = function\n    [] -> raise Not_found\n  | (a,b)::l -> if compare a x = 0 then b else assoc x l\n\nlet rec assq x = function\n    [] -> raise Not_found\n  | (a,b)::l -> if a == x then b else assq x l\n\nlet rec mem_assoc x = function\n  | [] -> false\n  | (a, b) :: l -> compare a x = 0 || mem_assoc x l\n\nlet rec mem_assq x = function\n  | [] -> false\n  | (a, b) :: l -> a == x || mem_assq x l\n\nlet rec remove_assoc x = function\n  | [] -> []\n  | (a, b as pair) :: l ->\n      if compare a x = 0 then l else pair :: remove_assoc x l\n\nlet rec remove_assq x = function\n  | [] -> []\n  | (a, b as pair) :: l -> if a == x then l else pair :: remove_assq x l\n\nlet rec find p = function\n  | [] -> raise Not_found\n  | x :: l -> if p x then x else find p l\n\nlet find_all p =\n  let rec find accu = function\n  | [] -> rev accu\n  | x :: l -> if p x then find (x :: accu) l else find accu l in\n  find []\n\nlet filter = find_all\n\nlet partition p l =\n  let rec part yes no = function\n  | [] -> (rev yes, rev no)\n  | x :: l -> if p x then part (x :: yes) no l else part yes (x :: no) l in\n  part [] [] l\n\nlet rec split = function\n    [] -> ([], [])\n  | (x,y)::l ->\n      let (rx, ry) = split l in (x::rx, y::ry)\n\nlet rec combine l1 l2 =\n  match (l1, l2) with\n    ([], []) -> []\n  | (a1::l1, a2::l2) -> (a1, a2) :: combine l1 l2\n  | (_, _) -> invalid_arg \"List.combine\"\n\n(** sorting *)\n\nlet rec merge cmp l1 l2 =\n  match l1, l2 with\n  | [], l2 -> l2\n  | l1, [] -> l1\n  | h1 :: t1, h2 :: t2 ->\n      if cmp h1 h2 <= 0\n      then h1 :: merge cmp t1 l2\n      else h2 :: merge cmp l1 t2\n;;\n\nlet rec chop k l =\n  if k = 0 then l else begin\n    match l with\n    | x::t -> chop (k-1) t\n    | _ -> assert false\n  end\n;;\n\nlet stable_sort cmp l =\n  let rec rev_merge l1 l2 accu =\n    match l1, l2 with\n    | [], l2 -> rev_append l2 accu\n    | l1, [] -> rev_append l1 accu\n    | h1::t1, h2::t2 ->\n        if cmp h1 h2 <= 0\n        then rev_merge t1 l2 (h1::accu)\n        else rev_merge l1 t2 (h2::accu)\n  in\n  let rec rev_merge_rev l1 l2 accu =\n    match l1, l2 with\n    | [], l2 -> rev_append l2 accu\n    | l1, [] -> rev_append l1 accu\n    | h1::t1, h2::t2 ->\n        if cmp h1 h2 > 0\n        then rev_merge_rev t1 l2 (h1::accu)\n        else rev_merge_rev l1 t2 (h2::accu)\n  in\n  let rec sort n l =\n    match n, l with\n    | 2, x1 :: x2 :: _ ->\n       if cmp x1 x2 <= 0 then [x1; x2] else [x2; x1]\n    | 3, x1 :: x2 :: x3 :: _ ->\n       if cmp x1 x2 <= 0 then begin\n         if cmp x2 x3 <= 0 then [x1; x2; x3]\n         else if cmp x1 x3 <= 0 then [x1; x3; x2]\n         else [x3; x1; x2]\n       end else begin\n         if cmp x1 x3 <= 0 then [x2; x1; x3]\n         else if cmp x2 x3 <= 0 then [x2; x3; x1]\n         else [x3; x2; x1]\n       end\n    | n, l ->\n       let n1 = n asr 1 in\n       let n2 = n - n1 in\n       let l2 = chop n1 l in\n       let s1 = rev_sort n1 l in\n       let s2 = rev_sort n2 l2 in\n       rev_merge_rev s1 s2 []\n  and rev_sort n l =\n    match n, l with\n    | 2, x1 :: x2 :: _ ->\n       if cmp x1 x2 > 0 then [x1; x2] else [x2; x1]\n    | 3, x1 :: x2 :: x3 :: _ ->\n       if cmp x1 x2 > 0 then begin\n         if cmp x2 x3 > 0 then [x1; x2; x3]\n         else if cmp x1 x3 > 0 then [x1; x3; x2]\n         else [x3; x1; x2]\n       end else begin\n         if cmp x1 x3 > 0 then [x2; x1; x3]\n         else if cmp x2 x3 > 0 then [x2; x3; x1]\n         else [x3; x2; x1]\n       end\n    | n, l ->\n       let n1 = n asr 1 in\n       let n2 = n - n1 in\n       let l2 = chop n1 l in\n       let s1 = sort n1 l in\n       let s2 = sort n2 l2 in\n       rev_merge s1 s2 []\n  in\n  let len = length l in\n  if len < 2 then l else sort len l\n;;\n\nlet sort = stable_sort;;\nlet fast_sort = stable_sort;;\n\n(* Note: on a list of length between about 100000 (depending on the minor\n   heap size and the type of the list) and Sys.max_array_size, it is\n   actually faster to use the following, but it might also use more memory\n   because the argument list cannot be deallocated incrementally.\n\n   Also, there seems to be a bug in this code or in the\n   implementation of obj_truncate.\n\nexternal obj_truncate : 'a array -> int -> unit = \"caml_obj_truncate\"\n\nlet array_to_list_in_place a =\n  let l = Array.length a in\n  let rec loop accu n p =\n    if p <= 0 then accu else begin\n      if p = n then begin\n        obj_truncate a p;\n        loop (a.(p-1) :: accu) (n-1000) (p-1)\n      end else begin\n        loop (a.(p-1) :: accu) n (p-1)\n      end\n    end\n  in\n  loop [] (l-1000) l\n;;\n\nlet stable_sort cmp l =\n  let a = Array.of_list l in\n  Array.stable_sort cmp a;\n  array_to_list_in_place a\n;;\n*)\n\n\n(** sorting + removing duplicates *)\n\nlet sort_uniq cmp l =\n  let rec rev_merge l1 l2 accu =\n    match l1, l2 with\n    | [], l2 -> rev_append l2 accu\n    | l1, [] -> rev_append l1 accu\n    | h1::t1, h2::t2 ->\n        let c = cmp h1 h2 in\n        if c = 0 then rev_merge t1 t2 (h1::accu)\n        else if c < 0\n        then rev_merge t1 l2 (h1::accu)\n        else rev_merge l1 t2 (h2::accu)\n  in\n  let rec rev_merge_rev l1 l2 accu =\n    match l1, l2 with\n    | [], l2 -> rev_append l2 accu\n    | l1, [] -> rev_append l1 accu\n    | h1::t1, h2::t2 ->\n        let c = cmp h1 h2 in\n        if c = 0 then rev_merge_rev t1 t2 (h1::accu)\n        else if c > 0\n        then rev_merge_rev t1 l2 (h1::accu)\n        else rev_merge_rev l1 t2 (h2::accu)\n  in\n  let rec sort n l =\n    match n, l with\n    | 2, x1 :: x2 :: _ ->\n       let c = cmp x1 x2 in\n       if c = 0 then [x1]\n       else if c < 0 then [x1; x2] else [x2; x1]\n    | 3, x1 :: x2 :: x3 :: _ ->\n       let c = cmp x1 x2 in\n       if c = 0 then begin\n         let c = cmp x2 x3 in\n         if c = 0 then [x2]\n         else if c < 0 then [x2; x3] else [x3; x2]\n       end else if c < 0 then begin\n         let c = cmp x2 x3 in\n         if c = 0 then [x1; x2]\n         else if c < 0 then [x1; x2; x3]\n         else let c = cmp x1 x3 in\n         if c = 0 then [x1; x2]\n         else if c < 0 then [x1; x3; x2]\n         else [x3; x1; x2]\n       end else begin\n         let c = cmp x1 x3 in\n         if c = 0 then [x2; x1]\n         else if c < 0 then [x2; x1; x3]\n         else let c = cmp x2 x3 in\n         if c = 0 then [x2; x1]\n         else if c < 0 then [x2; x3; x1]\n         else [x3; x2; x1]\n       end\n    | n, l ->\n       let n1 = n asr 1 in\n       let n2 = n - n1 in\n       let l2 = chop n1 l in\n       let s1 = rev_sort n1 l in\n       let s2 = rev_sort n2 l2 in\n       rev_merge_rev s1 s2 []\n  and rev_sort n l =\n    match n, l with\n    | 2, x1 :: x2 :: _ ->\n       let c = cmp x1 x2 in\n       if c = 0 then [x1]\n       else if c > 0 then [x1; x2] else [x2; x1]\n    | 3, x1 :: x2 :: x3 :: _ ->\n       let c = cmp x1 x2 in\n       if c = 0 then begin\n         let c = cmp x2 x3 in\n         if c = 0 then [x2]\n         else if c > 0 then [x2; x3] else [x3; x2]\n       end else if c > 0 then begin\n         let c = cmp x2 x3 in\n         if c = 0 then [x1; x2]\n         else if c > 0 then [x1; x2; x3]\n         else let c = cmp x1 x3 in\n         if c = 0 then [x1; x2]\n         else if c > 0 then [x1; x3; x2]\n         else [x3; x1; x2]\n       end else begin\n         let c = cmp x1 x3 in\n         if c = 0 then [x2; x1]\n         else if c > 0 then [x2; x1; x3]\n         else let c = cmp x2 x3 in\n         if c = 0 then [x2; x1]\n         else if c > 0 then [x2; x3; x1]\n         else [x3; x2; x1]\n       end\n    | n, l ->\n       let n1 = n asr 1 in\n       let n2 = n - n1 in\n       let l2 = chop n1 l in\n       let s1 = sort n1 l in\n       let s2 = sort n2 l2 in\n       rev_merge s1 s2 []\n  in\n  let len = length l in\n  if len < 2 then l else sort len l\n;;\n",
  "(***********************************************************************)\n(*                                                                     *)\n(*                                OCaml                                *)\n(*                                                                     *)\n(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)\n(*                                                                     *)\n(*  Copyright 1996 Institut National de Recherche en Informatique et   *)\n(*  en Automatique.  All rights reserved.  This file is distributed    *)\n(*  under the terms of the GNU Library General Public License, with    *)\n(*  the special exception on linking described in file ../LICENSE.     *)\n(*                                                                     *)\n(***********************************************************************)\n\n(* WARNING: sys.ml is generated from sys.mlp.  DO NOT EDIT sys.ml or\n   your changes will be lost.\n*)\n\n(* System interface *)\n\nexternal get_config: unit -> string * int * bool = \"caml_sys_get_config\"\nexternal get_argv: unit -> string * string array = \"caml_sys_get_argv\"\nexternal big_endian : unit -> bool = \"%big_endian\"\nexternal word_size : unit -> int = \"%word_size\"\nexternal unix : unit -> bool = \"%ostype_unix\"\nexternal win32 : unit -> bool = \"%ostype_win32\"\nexternal cygwin : unit -> bool = \"%ostype_cygwin\"\n\nlet (executable_name, argv) = get_argv()\nlet (os_type, _, _) = get_config()\nlet big_endian = big_endian ()\nlet word_size = word_size ()\nlet unix = unix ()\nlet win32 = win32 ()\nlet cygwin = cygwin ()\nlet max_array_length = (1 lsl (word_size - 10)) - 1;;\nlet max_string_length = word_size / 8 * max_array_length - 1;;\n\nexternal file_exists: string -> bool = \"caml_sys_file_exists\"\nexternal is_directory : string -> bool = \"caml_sys_is_directory\"\nexternal remove: string -> unit = \"caml_sys_remove\"\nexternal rename : string -> string -> unit = \"caml_sys_rename\"\nexternal getenv: string -> string = \"caml_sys_getenv\"\nexternal command: string -> int = \"caml_sys_system_command\"\nexternal time: unit -> float = \"caml_sys_time\"\nexternal chdir: string -> unit = \"caml_sys_chdir\"\nexternal getcwd: unit -> string = \"caml_sys_getcwd\"\nexternal readdir : string -> string array = \"caml_sys_read_directory\"\n\nlet interactive = ref false\n\ntype signal_behavior =\n    Signal_default\n  | Signal_ignore\n  | Signal_handle of (int -> unit)\n\nexternal signal : int -> signal_behavior -> signal_behavior\n                = \"caml_install_signal_handler\"\n\nlet set_signal sig_num sig_beh = ignore(signal sig_num sig_beh)\n\nlet sigabrt = -1\nlet sigalrm = -2\nlet sigfpe = -3\nlet sighup = -4\nlet sigill = -5\nlet sigint = -6\nlet sigkill = -7\nlet sigpipe = -8\nlet sigquit = -9\nlet sigsegv = -10\nlet sigterm = -11\nlet sigusr1 = -12\nlet sigusr2 = -13\nlet sigchld = -14\nlet sigcont = -15\nlet sigstop = -16\nlet sigtstp = -17\nlet sigttin = -18\nlet sigttou = -19\nlet sigvtalrm = -20\nlet sigprof = -21\n\nexception Break\n\nlet catch_break on =\n  if on then\n    set_signal sigint (Signal_handle(fun _ -> raise Break))\n  else\n    set_signal sigint Signal_default\n\n\n(* The version string is found in file ../VERSION *)\n\nlet ocaml_version = \"4.02.3\";;\n",
  "(***********************************************************************)\n(*                                                                     *)\n(*                                OCaml                                *)\n(*                                                                     *)\n(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)\n(*                                                                     *)\n(*  Copyright 1996 Institut National de Recherche en Informatique et   *)\n(*  en Automatique.  All rights reserved.  This file is distributed    *)\n(*  under the terms of the GNU Library General Public License, with    *)\n(*  the special exception on linking described in file ../LICENSE.     *)\n(*                                                                     *)\n(***********************************************************************)\n\nmodule type OrderedType =\n  sig\n    type t\n    val compare: t -> t -> int\n  end\n\nmodule type S =\n  sig\n    type key\n    type +'a t\n    val empty: 'a t\n    val is_empty: 'a t -> bool\n    val mem:  key -> 'a t -> bool\n    val add: key -> 'a -> 'a t -> 'a t\n    val singleton: key -> 'a -> 'a t\n    val remove: key -> 'a t -> 'a t\n    val merge:\n          (key -> 'a option -> 'b option -> 'c option) -> 'a t -> 'b t -> 'c t\n    val compare: ('a -> 'a -> int) -> 'a t -> 'a t -> int\n    val equal: ('a -> 'a -> bool) -> 'a t -> 'a t -> bool\n    val iter: (key -> 'a -> unit) -> 'a t -> unit\n    val fold: (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b\n    val for_all: (key -> 'a -> bool) -> 'a t -> bool\n    val exists: (key -> 'a -> bool) -> 'a t -> bool\n    val filter: (key -> 'a -> bool) -> 'a t -> 'a t\n    val partition: (key -> 'a -> bool) -> 'a t -> 'a t * 'a t\n    val cardinal: 'a t -> int\n    val bindings: 'a t -> (key * 'a) list\n    val min_binding: 'a t -> (key * 'a)\n    val max_binding: 'a t -> (key * 'a)\n    val choose: 'a t -> (key * 'a)\n    val split: key -> 'a t -> 'a t * 'a option * 'a t\n    val find: key -> 'a t -> 'a\n    val map: ('a -> 'b) -> 'a t -> 'b t\n    val mapi: (key -> 'a -> 'b) -> 'a t -> 'b t\n  end\n\nmodule Make(Ord: OrderedType) = struct\n\n    type key = Ord.t\n\n    type 'a t =\n        Empty\n      | Node of 'a t * key * 'a * 'a t * int\n\n    let height = function\n        Empty -> 0\n      | Node(_,_,_,_,h) -> h\n\n    let create l x d r =\n      let hl = height l and hr = height r in\n      Node(l, x, d, r, (if hl >= hr then hl + 1 else hr + 1))\n\n    let singleton x d = Node(Empty, x, d, Empty, 1)\n\n    let bal l x d r =\n      let hl = match l with Empty -> 0 | Node(_,_,_,_,h) -> h in\n      let hr = match r with Empty -> 0 | Node(_,_,_,_,h) -> h in\n      if hl > hr + 2 then begin\n        match l with\n          Empty -> invalid_arg \"Map.bal\"\n        | Node(ll, lv, ld, lr, _) ->\n            if height ll >= height lr then\n              create ll lv ld (create lr x d r)\n            else begin\n              match lr with\n                Empty -> invalid_arg \"Map.bal\"\n              | Node(lrl, lrv, lrd, lrr, _)->\n                  create (create ll lv ld lrl) lrv lrd (create lrr x d r)\n            end\n      end else if hr > hl + 2 then begin\n        match r with\n          Empty -> invalid_arg \"Map.bal\"\n        | Node(rl, rv, rd, rr, _) ->\n            if height rr >= height rl then\n              create (create l x d rl) rv rd rr\n            else begin\n              match rl with\n                Empty -> invalid_arg \"Map.bal\"\n              | Node(rll, rlv, rld, rlr, _) ->\n                  create (create l x d rll) rlv rld (create rlr rv rd rr)\n            end\n      end else\n        Node(l, x, d, r, (if hl >= hr then hl + 1 else hr + 1))\n\n    let empty = Empty\n\n    let is_empty = function Empty -> true | _ -> false\n\n    let rec add x data = function\n        Empty ->\n          Node(Empty, x, data, Empty, 1)\n      | Node(l, v, d, r, h) ->\n          let c = Ord.compare x v in\n          if c = 0 then\n            Node(l, x, data, r, h)\n          else if c < 0 then\n            bal (add x data l) v d r\n          else\n            bal l v d (add x data r)\n\n    let rec find x = function\n        Empty ->\n          raise Not_found\n      | Node(l, v, d, r, _) ->\n          let c = Ord.compare x v in\n          if c = 0 then d\n          else find x (if c < 0 then l else r)\n\n    let rec mem x = function\n        Empty ->\n          false\n      | Node(l, v, d, r, _) ->\n          let c = Ord.compare x v in\n          c = 0 || mem x (if c < 0 then l else r)\n\n    let rec min_binding = function\n        Empty -> raise Not_found\n      | Node(Empty, x, d, r, _) -> (x, d)\n      | Node(l, x, d, r, _) -> min_binding l\n\n    let rec max_binding = function\n        Empty -> raise Not_found\n      | Node(l, x, d, Empty, _) -> (x, d)\n      | Node(l, x, d, r, _) -> max_binding r\n\n    let rec remove_min_binding = function\n        Empty -> invalid_arg \"Map.remove_min_elt\"\n      | Node(Empty, x, d, r, _) -> r\n      | Node(l, x, d, r, _) -> bal (remove_min_binding l) x d r\n\n    let merge t1 t2 =\n      match (t1, t2) with\n        (Empty, t) -> t\n      | (t, Empty) -> t\n      | (_, _) ->\n          let (x, d) = min_binding t2 in\n          bal t1 x d (remove_min_binding t2)\n\n    let rec remove x = function\n        Empty ->\n          Empty\n      | Node(l, v, d, r, h) ->\n          let c = Ord.compare x v in\n          if c = 0 then\n            merge l r\n          else if c < 0 then\n            bal (remove x l) v d r\n          else\n            bal l v d (remove x r)\n\n    let rec iter f = function\n        Empty -> ()\n      | Node(l, v, d, r, _) ->\n          iter f l; f v d; iter f r\n\n    let rec map f = function\n        Empty ->\n          Empty\n      | Node(l, v, d, r, h) ->\n          let l' = map f l in\n          let d' = f d in\n          let r' = map f r in\n          Node(l', v, d', r', h)\n\n    let rec mapi f = function\n        Empty ->\n          Empty\n      | Node(l, v, d, r, h) ->\n          let l' = mapi f l in\n          let d' = f v d in\n          let r' = mapi f r in\n          Node(l', v, d', r', h)\n\n    let rec fold f m accu =\n      match m with\n        Empty -> accu\n      | Node(l, v, d, r, _) ->\n          fold f r (f v d (fold f l accu))\n\n    let rec for_all p = function\n        Empty -> true\n      | Node(l, v, d, r, _) -> p v d && for_all p l && for_all p r\n\n    let rec exists p = function\n        Empty -> false\n      | Node(l, v, d, r, _) -> p v d || exists p l || exists p r\n\n    (* Beware: those two functions assume that the added k is *strictly*\n       smaller (or bigger) than all the present keys in the tree; it\n       does not test for equality with the current min (or max) key.\n\n       Indeed, they are only used during the \"join\" operation which\n       respects this precondition.\n    *)\n\n    let rec add_min_binding k v = function\n      | Empty -> singleton k v\n      | Node (l, x, d, r, h) ->\n        bal (add_min_binding k v l) x d r\n\n    let rec add_max_binding k v = function\n      | Empty -> singleton k v\n      | Node (l, x, d, r, h) ->\n        bal l x d (add_max_binding k v r)\n\n    (* Same as create and bal, but no assumptions are made on the\n       relative heights of l and r. *)\n\n    let rec join l v d r =\n      match (l, r) with\n        (Empty, _) -> add_min_binding v d r\n      | (_, Empty) -> add_max_binding v d l\n      | (Node(ll, lv, ld, lr, lh), Node(rl, rv, rd, rr, rh)) ->\n          if lh > rh + 2 then bal ll lv ld (join lr v d r) else\n          if rh > lh + 2 then bal (join l v d rl) rv rd rr else\n          create l v d r\n\n    (* Merge two trees l and r into one.\n       All elements of l must precede the elements of r.\n       No assumption on the heights of l and r. *)\n\n    let concat t1 t2 =\n      match (t1, t2) with\n        (Empty, t) -> t\n      | (t, Empty) -> t\n      | (_, _) ->\n          let (x, d) = min_binding t2 in\n          join t1 x d (remove_min_binding t2)\n\n    let concat_or_join t1 v d t2 =\n      match d with\n      | Some d -> join t1 v d t2\n      | None -> concat t1 t2\n\n    let rec split x = function\n        Empty ->\n          (Empty, None, Empty)\n      | Node(l, v, d, r, _) ->\n          let c = Ord.compare x v in\n          if c = 0 then (l, Some d, r)\n          else if c < 0 then\n            let (ll, pres, rl) = split x l in (ll, pres, join rl v d r)\n          else\n            let (lr, pres, rr) = split x r in (join l v d lr, pres, rr)\n\n    let rec merge f s1 s2 =\n      match (s1, s2) with\n        (Empty, Empty) -> Empty\n      | (Node (l1, v1, d1, r1, h1), _) when h1 >= height s2 ->\n          let (l2, d2, r2) = split v1 s2 in\n          concat_or_join (merge f l1 l2) v1 (f v1 (Some d1) d2) (merge f r1 r2)\n      | (_, Node (l2, v2, d2, r2, h2)) ->\n          let (l1, d1, r1) = split v2 s1 in\n          concat_or_join (merge f l1 l2) v2 (f v2 d1 (Some d2)) (merge f r1 r2)\n      | _ ->\n          assert false\n\n    let rec filter p = function\n        Empty -> Empty\n      | Node(l, v, d, r, _) ->\n          (* call [p] in the expected left-to-right order *)\n          let l' = filter p l in\n          let pvd = p v d in\n          let r' = filter p r in\n          if pvd then join l' v d r' else concat l' r'\n\n    let rec partition p = function\n        Empty -> (Empty, Empty)\n      | Node(l, v, d, r, _) ->\n          (* call [p] in the expected left-to-right order *)\n          let (lt, lf) = partition p l in\n          let pvd = p v d in\n          let (rt, rf) = partition p r in\n          if pvd\n          then (join lt v d rt, concat lf rf)\n          else (concat lt rt, join lf v d rf)\n\n    type 'a enumeration = End | More of key * 'a * 'a t * 'a enumeration\n\n    let rec cons_enum m e =\n      match m with\n        Empty -> e\n      | Node(l, v, d, r, _) -> cons_enum l (More(v, d, r, e))\n\n    let compare cmp m1 m2 =\n      let rec compare_aux e1 e2 =\n          match (e1, e2) with\n          (End, End) -> 0\n        | (End, _)  -> -1\n        | (_, End) -> 1\n        | (More(v1, d1, r1, e1), More(v2, d2, r2, e2)) ->\n            let c = Ord.compare v1 v2 in\n            if c <> 0 then c else\n            let c = cmp d1 d2 in\n            if c <> 0 then c else\n            compare_aux (cons_enum r1 e1) (cons_enum r2 e2)\n      in compare_aux (cons_enum m1 End) (cons_enum m2 End)\n\n    let equal cmp m1 m2 =\n      let rec equal_aux e1 e2 =\n          match (e1, e2) with\n          (End, End) -> true\n        | (End, _)  -> false\n        | (_, End) -> false\n        | (More(v1, d1, r1, e1), More(v2, d2, r2, e2)) ->\n            Ord.compare v1 v2 = 0 && cmp d1 d2 &&\n            equal_aux (cons_enum r1 e1) (cons_enum r2 e2)\n      in equal_aux (cons_enum m1 End) (cons_enum m2 End)\n\n    let rec cardinal = function\n        Empty -> 0\n      | Node(l, _, _, r, _) -> cardinal l + 1 + cardinal r\n\n    let rec bindings_aux accu = function\n        Empty -> accu\n      | Node(l, v, d, r, _) -> bindings_aux ((v, d) :: bindings_aux accu r) l\n\n    let bindings s =\n      bindings_aux [] s\n\n    let choose = min_binding\n\nend\n",
  "(***********************************************************************)\n(*                                                                     *)\n(*                                OCaml                                *)\n(*                                                                     *)\n(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)\n(*                                                                     *)\n(*  Copyright 1996 Institut National de Recherche en Informatique et   *)\n(*  en Automatique.  All rights reserved.  This file is distributed    *)\n(*  under the terms of the GNU Library General Public License, with    *)\n(*  the special exception on linking described in file ../LICENSE.     *)\n(*                                                                     *)\n(***********************************************************************)\n\nopen Printf;;\n\nlet printers = ref []\n\nlet locfmt = format_of_string \"File \\\"%s\\\", line %d, characters %d-%d: %s\";;\n\nlet field x i =\n  let f = Obj.field x i in\n  if not (Obj.is_block f) then\n    sprintf \"%d\" (Obj.magic f : int)           (* can also be a char *)\n  else if Obj.tag f = Obj.string_tag then\n    sprintf \"%S\" (Obj.magic f : string)\n  else if Obj.tag f = Obj.double_tag then\n    string_of_float (Obj.magic f : float)\n  else\n    \"_\"\n;;\nlet rec other_fields x i =\n  if i >= Obj.size x then \"\"\n  else sprintf \", %s%s\" (field x i) (other_fields x (i+1))\n;;\nlet fields x =\n  match Obj.size x with\n  | 0 -> \"\"\n  | 1 -> \"\"\n  | 2 -> sprintf \"(%s)\" (field x 1)\n  | n -> sprintf \"(%s%s)\" (field x 1) (other_fields x 2)\n;;\n\nlet to_string x =\n  let rec conv = function\n    | hd :: tl ->\n        (match try hd x with _ -> None with\n        | Some s -> s\n        | None -> conv tl)\n    | [] ->\n        match x with\n        | Out_of_memory -> \"Out of memory\"\n        | Stack_overflow -> \"Stack overflow\"\n        | Match_failure(file, line, char) ->\n            sprintf locfmt file line char (char+5) \"Pattern matching failed\"\n        | Assert_failure(file, line, char) ->\n            sprintf locfmt file line char (char+6) \"Assertion failed\"\n        | Undefined_recursive_module(file, line, char) ->\n            sprintf locfmt file line char (char+6) \"Undefined recursive module\"\n        | _ ->\n            let x = Obj.repr x in\n            if Obj.tag x <> 0 then\n              (Obj.magic (Obj.field x 0) : string)\n            else\n              let constructor =\n                (Obj.magic (Obj.field (Obj.field x 0) 0) : string) in\n              constructor ^ (fields x) in\n  conv !printers\n\nlet print fct arg =\n  try\n    fct arg\n  with x ->\n    eprintf \"Uncaught exception: %s\\n\" (to_string x);\n    flush stderr;\n    raise x\n\nlet catch fct arg =\n  try\n    fct arg\n  with x ->\n    flush stdout;\n    eprintf \"Uncaught exception: %s\\n\" (to_string x);\n    exit 2\n\ntype raw_backtrace_slot\ntype raw_backtrace = raw_backtrace_slot array\n\nexternal get_raw_backtrace:\n  unit -> raw_backtrace = \"caml_get_exception_raw_backtrace\"\n\ntype backtrace_slot =\n  | Known_location of bool   (* is_raise *)\n                    * string (* filename *)\n                    * int    (* line number *)\n                    * int    (* start char *)\n                    * int    (* end char *)\n  | Unknown_location of bool (*is_raise*)\n\n(* to avoid warning *)\nlet _ = [Known_location (false, \"\", 0, 0, 0); Unknown_location false]\n\nexternal convert_raw_backtrace_slot:\n  raw_backtrace_slot -> backtrace_slot = \"caml_convert_raw_backtrace_slot\"\n\nlet convert_raw_backtrace rbckt =\n  try Some (Array.map convert_raw_backtrace_slot rbckt)\n  with Failure _ -> None\n\nlet format_backtrace_slot pos slot =\n  let info is_raise =\n    if is_raise then\n      if pos = 0 then \"Raised at\" else \"Re-raised at\"\n    else\n      if pos = 0 then \"Raised by primitive operation at\" else \"Called from\"\n  in\n  match slot with\n  | Unknown_location true -> (* compiler-inserted re-raise, skipped *) None\n  | Unknown_location false ->\n      Some (sprintf \"%s unknown location\" (info false))\n  | Known_location(is_raise, filename, lineno, startchar, endchar) ->\n      Some (sprintf \"%s file \\\"%s\\\", line %d, characters %d-%d\"\n              (info is_raise) filename lineno startchar endchar)\n\nlet print_exception_backtrace outchan backtrace =\n  match backtrace with\n  | None ->\n      fprintf outchan\n        \"(Program not linked with -g, cannot print stack backtrace)\\n\"\n  | Some a ->\n      for i = 0 to Array.length a - 1 do\n        match format_backtrace_slot i a.(i) with\n          | None -> ()\n          | Some str -> fprintf outchan \"%s\\n\" str\n      done\n\nlet print_raw_backtrace outchan raw_backtrace =\n  print_exception_backtrace outchan (convert_raw_backtrace raw_backtrace)\n\n(* confusingly named: prints the global current backtrace *)\nlet print_backtrace outchan =\n  print_raw_backtrace outchan (get_raw_backtrace ())\n\nlet backtrace_to_string backtrace =\n  match backtrace with\n  | None ->\n     \"(Program not linked with -g, cannot print stack backtrace)\\n\"\n  | Some a ->\n      let b = Buffer.create 1024 in\n      for i = 0 to Array.length a - 1 do\n        match format_backtrace_slot i a.(i) with\n          | None -> ()\n          | Some str -> bprintf b \"%s\\n\" str\n      done;\n      Buffer.contents b\n\nlet raw_backtrace_to_string raw_backtrace =\n  backtrace_to_string (convert_raw_backtrace raw_backtrace)\n\nlet backtrace_slot_is_raise = function\n  | Known_location(is_raise, _, _, _, _) -> is_raise\n  | Unknown_location(is_raise) -> is_raise\n\ntype location = {\n  filename : string;\n  line_number : int;\n  start_char : int;\n  end_char : int;\n}\n\nlet backtrace_slot_location = function\n  | Unknown_location _ -> None\n  | Known_location(_is_raise, filename, line_number,\n                   start_char, end_char) ->\n    Some {\n      filename;\n      line_number;\n      start_char;\n      end_char;\n    }\n\nlet backtrace_slots raw_backtrace =\n  (* The documentation of this function guarantees that Some is\n     returned only if a part of the trace is usable. This gives us\n     a bit more work than just convert_raw_backtrace, but it makes the\n     API more user-friendly -- otherwise most users would have to\n     reimplement the \"Program not linked with -g, sorry\" logic\n     themselves. *)\n  match convert_raw_backtrace raw_backtrace with\n    | None -> None\n    | Some backtrace ->\n      let usable_slot = function\n        | Unknown_location _ -> false\n        | Known_location _ -> true in\n      let rec exists_usable = function\n        | (-1) -> false\n        | i -> usable_slot backtrace.(i) || exists_usable (i - 1) in\n      if exists_usable (Array.length backtrace - 1)\n      then Some backtrace\n      else None\n\nmodule Slot = struct\n  type t = backtrace_slot\n  let format = format_backtrace_slot\n  let is_raise = backtrace_slot_is_raise\n  let location = backtrace_slot_location\nend\n\nlet raw_backtrace_length bckt = Array.length bckt\nlet get_raw_backtrace_slot bckt i = Array.get bckt i\n\n(* confusingly named:\n   returns the *string* corresponding to the global current backtrace *)\nlet get_backtrace () =\n  backtrace_to_string (convert_raw_backtrace (get_raw_backtrace ()))\n\nexternal record_backtrace: bool -> unit = \"caml_record_backtrace\"\nexternal backtrace_status: unit -> bool = \"caml_backtrace_status\"\n\nlet register_printer fn =\n  printers := fn :: !printers\n\nexternal get_callstack: int -> raw_backtrace = \"caml_get_current_callstack\"\n\nlet exn_slot x =\n  let x = Obj.repr x in\n  if Obj.tag x = 0 then Obj.field x 0 else x\n\nlet exn_slot_id x =\n  let slot = exn_slot x in\n  (Obj.obj (Obj.field slot 1) : int)\n\nlet exn_slot_name x =\n  let slot = exn_slot x in\n  (Obj.obj (Obj.field slot 0) : string)\n\n\nlet uncaught_exception_handler = ref None\n\nlet set_uncaught_exception_handler fn = uncaught_exception_handler := Some fn\n\nlet empty_backtrace : raw_backtrace = Obj.obj (Obj.new_block Obj.abstract_tag 0)\n\nlet try_get_raw_backtrace () =\n  try\n    get_raw_backtrace ()\n  with _ (* Out_of_memory? *) ->\n    empty_backtrace\n\nlet handle_uncaught_exception' exn debugger_in_use =\n  try\n    (* Get the backtrace now, in case one of the [at_exit] function\n       destroys it. *)\n    let raw_backtrace =\n      if debugger_in_use (* Same test as in [byterun/printexc.c] *) then\n        empty_backtrace\n      else\n        try_get_raw_backtrace ()\n    in\n    (try Pervasives.do_at_exit () with _ -> ());\n    match !uncaught_exception_handler with\n    | None ->\n        eprintf \"Fatal error: exception %s\\n\" (to_string exn);\n        print_raw_backtrace stderr raw_backtrace;\n        flush stderr\n    | Some handler ->\n        try\n          handler exn raw_backtrace\n        with exn' ->\n          let raw_backtrace' = try_get_raw_backtrace () in\n          eprintf \"Fatal error: exception %s\\n\" (to_string exn);\n          print_raw_backtrace stderr raw_backtrace;\n          eprintf \"Fatal error in uncaught exception handler: exception %s\\n\"\n            (to_string exn');\n          print_raw_backtrace stderr raw_backtrace';\n          flush stderr\n  with\n    | Out_of_memory ->\n        prerr_endline\n          \"Fatal error: out of memory in uncaught exception handler\"\n\n(* This function is called by [caml_fatal_uncaught_exception] in\n   [byterun/printexc.c] which expects no exception is raised. *)\nlet handle_uncaught_exception exn debugger_in_use =\n  try\n    handle_uncaught_exception' exn debugger_in_use\n  with _ ->\n    (* There is not much we can do at this point *)\n    ()\n\nexternal register_named_value : string -> 'a -> unit\n  = \"caml_register_named_value\"\n\nlet () =\n  register_named_value \"Printexc.handle_uncaught_exception\"\n    handle_uncaught_exception\n",
  "(***********************************************************************)\n(*                                                                     *)\n(*                                OCaml                                *)\n(*                                                                     *)\n(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)\n(*                                                                     *)\n(*  Copyright 1996 Institut National de Recherche en Informatique et   *)\n(*  en Automatique.  All rights reserved.  This file is distributed    *)\n(*  under the terms of the GNU Library General Public License, with    *)\n(*  the special exception on linking described in file ../LICENSE.     *)\n(*                                                                     *)\n(***********************************************************************)\n\n(* Registering OCaml values with the C runtime for later callbacks *)\n\nexternal register_named_value : string -> Obj.t -> unit\n                              = \"caml_register_named_value\"\n\nlet register name v =\n  register_named_value name (Obj.repr v)\n\nlet register_exception name (exn : exn) =\n  let exn = Obj.repr exn in\n  let slot = if Obj.tag exn = Obj.object_tag then exn else Obj.field exn 0 in\n  register_named_value name slot\n",
  "(***********************************************************************)\n(*                                                                     *)\n(*                                OCaml                                *)\n(*                                                                     *)\n(*         Jerome Vouillon, projet Cristal, INRIA Rocquencourt         *)\n(*                                                                     *)\n(*  Copyright 2002 Institut National de Recherche en Informatique et   *)\n(*  en Automatique.  All rights reserved.  This file is distributed    *)\n(*  under the terms of the GNU Library General Public License, with    *)\n(*  the special exception on linking described in file ../LICENSE.     *)\n(*                                                                     *)\n(***********************************************************************)\n\nopen Obj\n\n(**** Object representation ****)\n\nexternal set_id: 'a -> 'a = \"caml_set_oo_id\" \"noalloc\"\n\n(**** Object copy ****)\n\nlet copy o =\n  let o = (Obj.obj (Obj.dup (Obj.repr o))) in\n  set_id o\n\n(**** Compression options ****)\n(* Parameters *)\ntype params = {\n    mutable compact_table : bool;\n    mutable copy_parent : bool;\n    mutable clean_when_copying : bool;\n    mutable retry_count : int;\n    mutable bucket_small_size : int\n  }\n\nlet params = {\n  compact_table = true;\n  copy_parent = true;\n  clean_when_copying = true;\n  retry_count = 3;\n  bucket_small_size = 16\n}\n\n(**** Parameters ****)\n\nlet step = Sys.word_size / 16\nlet initial_object_size = 2\n\n(**** Items ****)\n\ntype item = DummyA | DummyB | DummyC of int\nlet _ = [DummyA; DummyB; DummyC 0] (* to avoid warnings *)\n\nlet dummy_item = (magic () : item)\n\n(**** Types ****)\n\ntype tag\ntype label = int\ntype closure = item\ntype t = DummyA | DummyB | DummyC of int\nlet _ = [DummyA; DummyB; DummyC 0] (* to avoid warnings *)\n\ntype obj = t array\nexternal ret : (obj -> 'a) -> closure = \"%identity\"\n\n(**** Labels ****)\n\nlet public_method_label s : tag =\n  let accu = ref 0 in\n  for i = 0 to String.length s - 1 do\n    accu := 223 * !accu + Char.code s.[i]\n  done;\n  (* reduce to 31 bits *)\n  accu := !accu land (1 lsl 31 - 1);\n  (* make it signed for 64 bits architectures *)\n  let tag = if !accu > 0x3FFFFFFF then !accu - (1 lsl 31) else !accu in\n  (* Printf.eprintf \"%s = %d\\n\" s tag; flush stderr; *)\n  magic tag\n\n(**** Sparse array ****)\n\nmodule Vars =\n  Map.Make(struct type t = string let compare (x:t) y = compare x y end)\ntype vars = int Vars.t\n\nmodule Meths =\n  Map.Make(struct type t = string let compare (x:t) y = compare x y end)\ntype meths = label Meths.t\nmodule Labs =\n  Map.Make(struct type t = label let compare (x:t) y = compare x y end)\ntype labs = bool Labs.t\n\n(* The compiler assumes that the first field of this structure is [size]. *)\ntype table =\n { mutable size: int;\n   mutable methods: closure array;\n   mutable methods_by_name: meths;\n   mutable methods_by_label: labs;\n   mutable previous_states:\n     (meths * labs * (label * item) list * vars *\n      label list * string list) list;\n   mutable hidden_meths: (label * item) list;\n   mutable vars: vars;\n   mutable initializers: (obj -> unit) list }\n\nlet dummy_table =\n  { methods = [| dummy_item |];\n    methods_by_name = Meths.empty;\n    methods_by_label = Labs.empty;\n    previous_states = [];\n    hidden_meths = [];\n    vars = Vars.empty;\n    initializers = [];\n    size = 0 }\n\nlet table_count = ref 0\n\n(* dummy_met should be a pointer, so use an atom *)\nlet dummy_met : item = obj (Obj.new_block 0 0)\n(* if debugging is needed, this could be a good idea: *)\n(* let dummy_met () = failwith \"Undefined method\" *)\n\nlet rec fit_size n =\n  if n <= 2 then n else\n  fit_size ((n+1)/2) * 2\n\nlet new_table pub_labels =\n  incr table_count;\n  let len = Array.length pub_labels in\n  let methods = Array.make (len*2+2) dummy_met in\n  methods.(0) <- magic len;\n  methods.(1) <- magic (fit_size len * Sys.word_size / 8 - 1);\n  for i = 0 to len - 1 do methods.(i*2+3) <- magic pub_labels.(i) done;\n  { methods = methods;\n    methods_by_name = Meths.empty;\n    methods_by_label = Labs.empty;\n    previous_states = [];\n    hidden_meths = [];\n    vars = Vars.empty;\n    initializers = [];\n    size = initial_object_size }\n\nlet resize array new_size =\n  let old_size = Array.length array.methods in\n  if new_size > old_size then begin\n    let new_buck = Array.make new_size dummy_met in\n    Array.blit array.methods 0 new_buck 0 old_size;\n    array.methods <- new_buck\n end\n\nlet put array label element =\n  resize array (label + 1);\n  array.methods.(label) <- element\n\n(**** Classes ****)\n\nlet method_count = ref 0\nlet inst_var_count = ref 0\n\n(* type t *)\ntype meth = item\n\nlet new_method table =\n  let index = Array.length table.methods in\n  resize table (index + 1);\n  index\n\nlet get_method_label table name =\n  try\n    Meths.find name table.methods_by_name\n  with Not_found ->\n    let label = new_method table in\n    table.methods_by_name <- Meths.add name label table.methods_by_name;\n    table.methods_by_label <- Labs.add label true table.methods_by_label;\n    label\n\nlet get_method_labels table names =\n  Array.map (get_method_label table) names\n\nlet set_method table label element =\n  incr method_count;\n  if Labs.find label table.methods_by_label then\n    put table label element\n  else\n    table.hidden_meths <- (label, element) :: table.hidden_meths\n\nlet get_method table label =\n  try List.assoc label table.hidden_meths\n  with Not_found -> table.methods.(label)\n\nlet to_list arr =\n  if arr == magic 0 then [] else Array.to_list arr\n\nlet narrow table vars virt_meths concr_meths =\n  let vars = to_list vars\n  and virt_meths = to_list virt_meths\n  and concr_meths = to_list concr_meths in\n  let virt_meth_labs = List.map (get_method_label table) virt_meths in\n  let concr_meth_labs = List.map (get_method_label table) concr_meths in\n  table.previous_states <-\n     (table.methods_by_name, table.methods_by_label, table.hidden_meths,\n      table.vars, virt_meth_labs, vars)\n     :: table.previous_states;\n  table.vars <-\n    Vars.fold\n      (fun lab info tvars ->\n        if List.mem lab vars then Vars.add lab info tvars else tvars)\n      table.vars Vars.empty;\n  let by_name = ref Meths.empty in\n  let by_label = ref Labs.empty in\n  List.iter2\n    (fun met label ->\n       by_name := Meths.add met label !by_name;\n       by_label :=\n          Labs.add label\n            (try Labs.find label table.methods_by_label with Not_found -> true)\n            !by_label)\n    concr_meths concr_meth_labs;\n  List.iter2\n    (fun met label ->\n       by_name := Meths.add met label !by_name;\n       by_label := Labs.add label false !by_label)\n    virt_meths virt_meth_labs;\n  table.methods_by_name <- !by_name;\n  table.methods_by_label <- !by_label;\n  table.hidden_meths <-\n     List.fold_right\n       (fun ((lab, _) as met) hm ->\n          if List.mem lab virt_meth_labs then hm else met::hm)\n       table.hidden_meths\n       []\n\nlet widen table =\n  let (by_name, by_label, saved_hidden_meths, saved_vars, virt_meths, vars) =\n    List.hd table.previous_states\n  in\n  table.previous_states <- List.tl table.previous_states;\n  table.vars <-\n     List.fold_left\n       (fun s v -> Vars.add v (Vars.find v table.vars) s)\n       saved_vars vars;\n  table.methods_by_name <- by_name;\n  table.methods_by_label <- by_label;\n  table.hidden_meths <-\n     List.fold_right\n       (fun ((lab, _) as met) hm ->\n          if List.mem lab virt_meths then hm else met::hm)\n       table.hidden_meths\n       saved_hidden_meths\n\nlet new_slot table =\n  let index = table.size in\n  table.size <- index + 1;\n  index\n\nlet new_variable table name =\n  try Vars.find name table.vars\n  with Not_found ->\n    let index = new_slot table in\n    if name <> \"\" then table.vars <- Vars.add name index table.vars;\n    index\n\nlet to_array arr =\n  if arr = Obj.magic 0 then [||] else arr\n\nlet new_methods_variables table meths vals =\n  let meths = to_array meths in\n  let nmeths = Array.length meths and nvals = Array.length vals in\n  let res = Array.make (nmeths + nvals) 0 in\n  for i = 0 to nmeths - 1 do\n    res.(i) <- get_method_label table meths.(i)\n  done;\n  for i = 0 to nvals - 1 do\n    res.(i+nmeths) <- new_variable table vals.(i)\n  done;\n  res\n\nlet get_variable table name =\n  try Vars.find name table.vars with Not_found -> assert false\n\nlet get_variables table names =\n  Array.map (get_variable table) names\n\nlet add_initializer table f =\n  table.initializers <- f::table.initializers\n\n(*\nmodule Keys =\n  Map.Make(struct type t = tag array let compare (x:t) y = compare x y end)\nlet key_map = ref Keys.empty\nlet get_key tags : item =\n  try magic (Keys.find tags !key_map : tag array)\n  with Not_found ->\n    key_map := Keys.add tags tags !key_map;\n    magic tags\n*)\n\nlet create_table public_methods =\n  if public_methods == magic 0 then new_table [||] else\n  (* [public_methods] must be in ascending order for bytecode *)\n  let tags = Array.map public_method_label public_methods in\n  let table = new_table tags in\n  Array.iteri\n    (fun i met ->\n      let lab = i*2+2 in\n      table.methods_by_name  <- Meths.add met lab table.methods_by_name;\n      table.methods_by_label <- Labs.add lab true table.methods_by_label)\n    public_methods;\n  table\n\nlet init_class table =\n  inst_var_count := !inst_var_count + table.size - 1;\n  table.initializers <- List.rev table.initializers;\n  resize table (3 + magic table.methods.(1) * 16 / Sys.word_size)\n\nlet inherits cla vals virt_meths concr_meths (_, super, _, env) top =\n  narrow cla vals virt_meths concr_meths;\n  let init =\n    if top then super cla env else Obj.repr (super cla) in\n  widen cla;\n  Array.concat\n    [[| repr init |];\n     magic (Array.map (get_variable cla) (to_array vals) : int array);\n     Array.map\n       (fun nm -> repr (get_method cla (get_method_label cla nm) : closure))\n       (to_array concr_meths) ]\n\nlet make_class pub_meths class_init =\n  let table = create_table pub_meths in\n  let env_init = class_init table in\n  init_class table;\n  (env_init (Obj.repr 0), class_init, env_init, Obj.repr 0)\n\ntype init_table = { mutable env_init: t; mutable class_init: table -> t }\n\nlet make_class_store pub_meths class_init init_table =\n  let table = create_table pub_meths in\n  let env_init = class_init table in\n  init_class table;\n  init_table.class_init <- class_init;\n  init_table.env_init <- env_init\n\nlet dummy_class loc =\n  let undef = fun _ -> raise (Undefined_recursive_module loc) in\n  (Obj.magic undef, undef, undef, Obj.repr 0)\n\n(**** Objects ****)\n\nlet create_object table =\n  (* XXX Appel de [obj_block] *)\n  let obj = Obj.new_block Obj.object_tag table.size in\n  (* XXX Appel de [caml_modify] *)\n  Obj.set_field obj 0 (Obj.repr table.methods);\n  Obj.obj (set_id obj)\n\nlet create_object_opt obj_0 table =\n  if (Obj.magic obj_0 : bool) then obj_0 else begin\n    (* XXX Appel de [obj_block] *)\n    let obj = Obj.new_block Obj.object_tag table.size in\n    (* XXX Appel de [caml_modify] *)\n    Obj.set_field obj 0 (Obj.repr table.methods);\n    Obj.obj (set_id obj)\n  end\n\nlet rec iter_f obj =\n  function\n    []   -> ()\n  | f::l -> f obj; iter_f obj l\n\nlet run_initializers obj table =\n  let inits = table.initializers in\n  if inits <> [] then\n    iter_f obj inits\n\nlet run_initializers_opt obj_0 obj table =\n  if (Obj.magic obj_0 : bool) then obj else begin\n    let inits = table.initializers in\n    if inits <> [] then iter_f obj inits;\n    obj\n  end\n\nlet create_object_and_run_initializers obj_0 table =\n  if (Obj.magic obj_0 : bool) then obj_0 else begin\n    let obj = create_object table in\n    run_initializers obj table;\n    obj\n  end\n\n(* Equivalent primitive below\nlet sendself obj lab =\n  (magic obj : (obj -> t) array array).(0).(lab) obj\n*)\nexternal send : obj -> tag -> 'a = \"%send\"\nexternal sendcache : obj -> tag -> t -> int -> 'a = \"%sendcache\"\nexternal sendself : obj -> label -> 'a = \"%sendself\"\nexternal get_public_method : obj -> tag -> closure\n    = \"caml_get_public_method\" \"noalloc\"\n\n(**** table collection access ****)\n\ntype tables = Empty | Cons of closure * tables * tables\ntype mut_tables =\n    {key: closure; mutable data: tables; mutable next: tables}\nexternal mut : tables -> mut_tables = \"%identity\"\nexternal demut : mut_tables -> tables = \"%identity\"\n\nlet build_path n keys tables =\n  (* Be careful not to create a seemingly immutable block, otherwise it could\n     be statically allocated.  See #5779. *)\n  let res = demut {key = Obj.magic 0; data = Empty; next = Empty} in\n  let r = ref res in\n  for i = 0 to n do\n    r := Cons (keys.(i), !r, Empty)\n  done;\n  tables.data <- !r;\n  res\n\nlet rec lookup_keys i keys tables =\n  if i < 0 then tables else\n  let key = keys.(i) in\n  let rec lookup_key tables =\n    if tables.key == key then lookup_keys (i-1) keys tables.data else\n    if tables.next <> Empty then lookup_key (mut tables.next) else\n    let next = Cons (key, Empty, Empty) in\n    tables.next <- next;\n    build_path (i-1) keys (mut next)\n  in\n  lookup_key (mut tables)\n\nlet lookup_tables root keys =\n  let root = mut root in\n  if root.data <> Empty then\n    lookup_keys (Array.length keys - 1) keys root.data\n  else\n    build_path (Array.length keys - 1) keys root\n\n(**** builtin methods ****)\n\nlet get_const x = ret (fun obj -> x)\nlet get_var n   = ret (fun obj -> Array.unsafe_get obj n)\nlet get_env e n =\n  ret (fun obj ->\n    Array.unsafe_get (Obj.magic (Array.unsafe_get obj e) : obj) n)\nlet get_meth n  = ret (fun obj -> sendself obj n)\nlet set_var n   = ret (fun obj x -> Array.unsafe_set obj n x)\nlet app_const f x = ret (fun obj -> f x)\nlet app_var f n   = ret (fun obj -> f (Array.unsafe_get obj n))\nlet app_env f e n =\n  ret (fun obj ->\n    f (Array.unsafe_get (Obj.magic (Array.unsafe_get obj e) : obj) n))\nlet app_meth f n  = ret (fun obj -> f (sendself obj n))\nlet app_const_const f x y = ret (fun obj -> f x y)\nlet app_const_var f x n   = ret (fun obj -> f x (Array.unsafe_get obj n))\nlet app_const_meth f x n = ret (fun obj -> f x (sendself obj n))\nlet app_var_const f n x = ret (fun obj -> f (Array.unsafe_get obj n) x)\nlet app_meth_const f n x = ret (fun obj -> f (sendself obj n) x)\nlet app_const_env f x e n =\n  ret (fun obj ->\n    f x (Array.unsafe_get (Obj.magic (Array.unsafe_get obj e) : obj) n))\nlet app_env_const f e n x =\n  ret (fun obj ->\n    f (Array.unsafe_get (Obj.magic (Array.unsafe_get obj e) : obj) n) x)\nlet meth_app_const n x = ret (fun obj -> (sendself obj n : _ -> _) x)\nlet meth_app_var n m =\n  ret (fun obj -> (sendself obj n : _ -> _) (Array.unsafe_get obj m))\nlet meth_app_env n e m =\n  ret (fun obj -> (sendself obj n : _ -> _)\n      (Array.unsafe_get (Obj.magic (Array.unsafe_get obj e) : obj) m))\nlet meth_app_meth n m =\n  ret (fun obj -> (sendself obj n : _ -> _) (sendself obj m))\nlet send_const m x c =\n  ret (fun obj -> sendcache x m (Array.unsafe_get obj 0) c)\nlet send_var m n c =\n  ret (fun obj ->\n    sendcache (Obj.magic (Array.unsafe_get obj n) : obj) m\n      (Array.unsafe_get obj 0) c)\nlet send_env m e n c =\n  ret (fun obj ->\n    sendcache\n      (Obj.magic (Array.unsafe_get\n                    (Obj.magic (Array.unsafe_get obj e) : obj) n) : obj)\n      m (Array.unsafe_get obj 0) c)\nlet send_meth m n c =\n  ret (fun obj ->\n    sendcache (sendself obj n) m (Array.unsafe_get obj 0) c)\nlet new_cache table =\n  let n = new_method table in\n  let n =\n    if n mod 2 = 0 || n > 2 + magic table.methods.(1) * 16 / Sys.word_size\n    then n else new_method table\n  in\n  table.methods.(n) <- Obj.magic 0;\n  n\n\ntype impl =\n    GetConst\n  | GetVar\n  | GetEnv\n  | GetMeth\n  | SetVar\n  | AppConst\n  | AppVar\n  | AppEnv\n  | AppMeth\n  | AppConstConst\n  | AppConstVar\n  | AppConstEnv\n  | AppConstMeth\n  | AppVarConst\n  | AppEnvConst\n  | AppMethConst\n  | MethAppConst\n  | MethAppVar\n  | MethAppEnv\n  | MethAppMeth\n  | SendConst\n  | SendVar\n  | SendEnv\n  | SendMeth\n  | Closure of closure\n\nlet method_impl table i arr =\n  let next () = incr i; magic arr.(!i) in\n  match next() with\n    GetConst -> let x : t = next() in get_const x\n  | GetVar   -> let n = next() in get_var n\n  | GetEnv   -> let e = next() and n = next() in get_env e n\n  | GetMeth  -> let n = next() in get_meth n\n  | SetVar   -> let n = next() in set_var n\n  | AppConst -> let f = next() and x = next() in app_const f x\n  | AppVar   -> let f = next() and n = next () in app_var f n\n  | AppEnv   ->\n      let f = next() and e = next() and n = next() in app_env f e n\n  | AppMeth  -> let f = next() and n = next () in app_meth f n\n  | AppConstConst ->\n      let f = next() and x = next() and y = next() in app_const_const f x y\n  | AppConstVar ->\n      let f = next() and x = next() and n = next() in app_const_var f x n\n  | AppConstEnv ->\n      let f = next() and x = next() and e = next () and n = next() in\n      app_const_env f x e n\n  | AppConstMeth ->\n      let f = next() and x = next() and n = next() in app_const_meth f x n\n  | AppVarConst ->\n      let f = next() and n = next() and x = next() in app_var_const f n x\n  | AppEnvConst ->\n      let f = next() and e = next () and n = next() and x = next() in\n      app_env_const f e n x\n  | AppMethConst ->\n      let f = next() and n = next() and x = next() in app_meth_const f n x\n  | MethAppConst ->\n      let n = next() and x = next() in meth_app_const n x\n  | MethAppVar ->\n      let n = next() and m = next() in meth_app_var n m\n  | MethAppEnv ->\n      let n = next() and e = next() and m = next() in meth_app_env n e m\n  | MethAppMeth ->\n      let n = next() and m = next() in meth_app_meth n m\n  | SendConst ->\n      let m = next() and x = next() in send_const m x (new_cache table)\n  | SendVar ->\n      let m = next() and n = next () in send_var m n (new_cache table)\n  | SendEnv ->\n      let m = next() and e = next() and n = next() in\n      send_env m e n (new_cache table)\n  | SendMeth ->\n      let m = next() and n = next () in send_meth m n (new_cache table)\n  | Closure _ as clo -> magic clo\n\nlet set_methods table methods =\n  let len = Array.length methods and i = ref 0 in\n  while !i < len do\n    let label = methods.(!i) and clo = method_impl table i methods in\n    set_method table label clo;\n    incr i\n  done\n\n(**** Statistics ****)\n\ntype stats =\n  { classes: int; methods: int; inst_vars: int; }\n\nlet stats () =\n  { classes = !table_count;\n    methods = !method_count; inst_vars = !inst_var_count; }\n",
  "(* Padding position. *)\ntype padty =\n  | Left   (* Text is left justified ('-' option).               *)\n  | Right  (* Text is right justified (no '-' option).           *)\n  | Zeros  (* Text is right justified by zeros (see '0' option). *)\n\n(***)\n\n(* Integer conversion. *)\ntype int_conv =\n  | Int_d | Int_pd | Int_sd        (*  %d | %+d | % d  *)\n  | Int_i | Int_pi | Int_si        (*  %i | %+i | % i  *)\n  | Int_x | Int_Cx                 (*  %x | %#x        *)\n  | Int_X | Int_CX                 (*  %X | %#X        *)\n  | Int_o | Int_Co                 (*  %o | %#o        *)\n  | Int_u                          (*  %u              *)\n\n(* Float conversion. *)\ntype float_conv =\n  | Float_f | Float_pf | Float_sf  (*  %f | %+f | % f  *)\n  | Float_e | Float_pe | Float_se  (*  %e | %+e | % e  *)\n  | Float_E | Float_pE | Float_sE  (*  %E | %+E | % E  *)\n  | Float_g | Float_pg | Float_sg  (*  %g | %+g | % g  *)\n  | Float_G | Float_pG | Float_sG  (*  %G | %+G | % G  *)\n  | Float_F                        (*  %F              *)\n\n(***)\n\n(* Char sets (see %[...]) are bitmaps implemented as 32-char strings. *)\ntype char_set = string\n\n(***)\n\n(* Counter used in Scanf. *)\ntype counter =\n  | Line_counter     (*  %l      *)\n  | Char_counter     (*  %n      *)\n  | Token_counter    (*  %N, %L  *)\n\n(***)\n\n(* Padding of strings and numbers. *)\ntype ('a, 'b) padding =\n  (* No padding (ex: \"%d\") *)\n  | No_padding  : ('a, 'a) padding\n  (* Literal padding (ex: \"%8d\") *)\n  | Lit_padding : padty * int -> ('a, 'a) padding\n  (* Padding as extra argument (ex: \"%*d\") *)\n  | Arg_padding : padty -> (int -> 'a, 'a) padding\n\n(* Some formats, such as %_d,\n   only accept an optional number as padding option (no extra argument) *)\ntype pad_option = int option\n\n(* Precision of floats and '0'-padding of integers. *)\ntype ('a, 'b) precision =\n  (* No precision (ex: \"%f\") *)\n  | No_precision : ('a, 'a) precision\n  (* Literal precision (ex: \"%.3f\") *)\n  | Lit_precision : int -> ('a, 'a) precision\n  (* Precision as extra argument (ex: \"%.*f\") *)\n  | Arg_precision : (int -> 'a, 'a) precision\n\n(* Some formats, such as %_f,\n   only accept an optional number as precision option (no extra argument) *)\ntype prec_option = int option\n\n(* see the Custom format combinator *)\ntype ('a, 'b, 'c) custom_arity =\n  | Custom_zero : ('a, string, 'a) custom_arity\n  | Custom_succ : ('a, 'b, 'c) custom_arity ->\n    ('a, 'x -> 'b, 'x -> 'c) custom_arity\n\n(***)\n\n(*        Relational format types\n\nIn the first format+gadts implementation, the type for %(..%) in the\nfmt GADT was as follows:\n\n| Format_subst :                                           (* %(...%) *)\n    pad_option * ('d1, 'q1, 'd2, 'q2) reader_nb_unifier *\n    ('x, 'b, 'c, 'd1, 'q1, 'u) fmtty *\n    ('u, 'b, 'c, 'q1, 'e1, 'f) fmt ->\n      (('x, 'b, 'c, 'd2, 'q2, 'u) format6 -> 'x, 'b, 'c, 'd1, 'e1, 'f) fmt\n\nNotice that the 'u parameter in 'f position in the format argument\n(('x, .., 'u) format6 -> ..) is equal to the 'u parameter in 'a\nposition in the format tail (('u, .., 'f) fmt). This means that the\ntype of the expected format parameter depends of where the %(...%)\nare in the format string:\n\n  # Printf.printf \"%(%)\";;\n  - : (unit, out_channel, unit, '_a, '_a, unit)\n      CamlinternalFormatBasics.format6 -> unit\n  = <fun>\n  # Printf.printf \"%(%)%d\";;\n  - : (int -> unit, out_channel, unit, '_a, '_a, int -> unit)\n      CamlinternalFormatBasics.format6 -> int -> unit\n  = <fun>\n\nOn the contrary, the legacy typer gives a clever type that does not\ndepend on the position of %(..%) in the format string. For example,\n%(%) will have the polymorphic type ('a, 'b, 'c, 'd, 'd, 'a): it can\nbe concatenated to any format type, and only enforces the constraint\nthat its 'a and 'f parameters are equal (no format arguments) and 'd\nand 'e are equal (no reader argument).\n\nThe weakening of this parameter type in the GADT version broke user\ncode (in fact it essentially made %(...%) unusable except at the last\nposition of a format). In particular, the following would not work\nanymore:\n\n  fun sep ->\n    Format.printf \"foo%(%)bar%(%)baz\" sep sep\n\nAs the type-checker would require two *incompatible* types for the %(%)\nin different positions.\n\nThe solution to regain a general type for %(..%) is to generalize this\ntechnique, not only on the 'd, 'e parameters, but on all six\nparameters of a format: we introduce a \"relational\" type\n  ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n   'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\nwhose values are proofs that ('a1, .., 'f1) and ('a2, .., 'f2) morally\ncorrespond to the same format type: 'a1 is obtained from 'f1,'b1,'c1\nin the exact same way that 'a2 is obtained from 'f2,'b2,'c2, etc.\n\nFor example, the relation between two format types beginning with a Char\nparameter is as follows:\n\n| Char_ty :                                                 (* %c  *)\n    ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n     'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n    (char -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n     char -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n\nIn the general case, the term structure of fmtty_rel is (almost¹)\nisomorphic to the fmtty of the previous implementation: every\nconstructor is re-read with a binary, relational type, instead of the\nprevious unary typing. fmtty can then be re-defined as the diagonal of\nfmtty_rel:\n\n  type ('a, 'b, 'c, 'd, 'e, 'f) fmtty =\n       ('a, 'b, 'c, 'd, 'e, 'f,\n        'a, 'b, 'c, 'd, 'e, 'f) fmtty_rel\n\nOnce we have this fmtty_rel type in place, we can give the more\ngeneral type to %(...%):\n\n| Format_subst :                                           (* %(...%) *)\n    pad_option *\n    ('g, 'h, 'i, 'j, 'k, 'l,\n     'g2, 'b, 'c, 'j2, 'd, 'a) fmtty_rel *\n    ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n    (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g2, 'b, 'c, 'j2, 'e, 'f) fmt\n\nWe accept any format (('g, 'h, 'i, 'j, 'k, 'l) format6) (this is\ncompletely unrelated to the type of the current format), but also\nrequire a proof that this format is in relation to another format that\nis concatenable to the format tail. When executing a %(...%) format\n(in camlinternalFormat.ml:make_printf or scanf.ml:make_scanf), we\ntranstype the format along this relation using the 'recast' function\nto transpose between related format types.\n\n  val recast :\n     ('a1, 'b1, 'c1, 'd1, 'e1, 'f1) fmt\n  -> ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n      'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  -> ('a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmt\n\nNOTE ¹: the typing of Format_subst_ty requires not one format type, but\ntwo, one to establish the link between the format argument and the\nfirst six parameters, and the other for the link between the format\nargumant and the last six parameters.\n\n| Format_subst_ty :                                         (* %(...%) *)\n    ('g, 'h, 'i, 'j, 'k, 'l,\n     'g1, 'b1, 'c1, 'j1, 'd1, 'a1) fmtty_rel *\n    ('g, 'h, 'i, 'j, 'k, 'l,\n     'g2, 'b2, 'c2, 'j2, 'd2, 'a2) fmtty_rel *\n    ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n     'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n    (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g1, 'b1, 'c1, 'j1, 'e1, 'f1,\n     ('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g2, 'b2, 'c2, 'j2, 'e2, 'f2) fmtty_rel\n\nWhen we generate a format AST, we generate exactly the same witness\nfor both relations, and the witness-conversion functions in\ncamlinternalFormat do rely on this invariant. For example, the\nfunction that proves that the relation is transitive\n\n  val trans :\n     ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n      'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  -> ('a2, 'b2, 'c2, 'd2, 'e2, 'f2,\n      'a3, 'b3, 'c3, 'd3, 'e3, 'f3) fmtty_rel\n  -> ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n      'a3, 'b3, 'c3, 'd3, 'e3, 'f3) fmtty_rel\n\ndoes assume that the two input have exactly the same term structure\n(and is only every used for argument witnesses of the\nFormat_subst_ty constructor).\n*)\n\n(* Type of a block used by the Format pretty-printer. *)\ntype block_type =\n  | Pp_hbox   (* Horizontal block no line breaking *)\n  | Pp_vbox   (* Vertical block each break leads to a new line *)\n  | Pp_hvbox  (* Horizontal-vertical block: same as vbox, except if this block\n                 is small enough to fit on a single line *)\n  | Pp_hovbox (* Horizontal or Vertical block: breaks lead to new line\n                 only when necessary to print the content of the block *)\n  | Pp_box    (* Horizontal or Indent block: breaks lead to new line\n                 only when necessary to print the content of the block, or\n                 when it leads to a new indentation of the current line *)\n  | Pp_fits   (* Internal usage: when a block fits on a single line *)\n\n(* Formatting element used by the Format pretty-printter. *)\ntype formatting_lit =\n  | Close_box                                           (* @]   *)\n  | Close_tag                                           (* @}   *)\n  | Break of string * int * int          (* @, | @  | @; | @;<> *)\n  | FFlush                                              (* @?   *)\n  | Force_newline                                       (* @\\n  *)\n  | Flush_newline                                       (* @.   *)\n  | Magic_size of string * int                          (* @<n> *)\n  | Escaped_at                                          (* @@   *)\n  | Escaped_percent                                     (* @%%  *)\n  | Scan_indic of char                                  (* @X   *)\n\n(* Formatting element used by the Format pretty-printter. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) formatting_gen =\n  | Open_tag : ('a, 'b, 'c, 'd, 'e, 'f) format6 ->      (* @{   *)\n    ('a, 'b, 'c, 'd, 'e, 'f) formatting_gen\n  | Open_box : ('a, 'b, 'c, 'd, 'e, 'f) format6 ->      (* @[   *)\n    ('a, 'b, 'c, 'd, 'e, 'f) formatting_gen\n\n(***)\n\n(* List of format type elements. *)\n(* In particular used to represent %(...%) and %{...%} contents. *)\nand ('a, 'b, 'c, 'd, 'e, 'f) fmtty =\n     ('a, 'b, 'c, 'd, 'e, 'f,\n      'a, 'b, 'c, 'd, 'e, 'f) fmtty_rel\nand ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n     'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel =\n  | Char_ty :                                                 (* %c  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (char -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       char -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | String_ty :                                               (* %s  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (string -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       string -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Int_ty :                                                  (* %d  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (int -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       int -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Int32_ty :                                                (* %ld *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (int32 -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       int32 -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Nativeint_ty :                                            (* %nd *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (nativeint -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       nativeint -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Int64_ty :                                                (* %Ld *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (int64 -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       int64 -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Float_ty :                                                (* %f  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (float -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       float -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Bool_ty :                                                 (* %B  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (bool -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       bool -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n\n  | Format_arg_ty :                                           (* %{...%} *)\n      ('g, 'h, 'i, 'j, 'k, 'l) fmtty *\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       ('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Format_subst_ty :                                         (* %(...%) *)\n      ('g, 'h, 'i, 'j, 'k, 'l,\n       'g1, 'b1, 'c1, 'j1, 'd1, 'a1) fmtty_rel *\n      ('g, 'h, 'i, 'j, 'k, 'l,\n       'g2, 'b2, 'c2, 'j2, 'd2, 'a2) fmtty_rel *\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g1, 'b1, 'c1, 'j1, 'e1, 'f1,\n       ('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g2, 'b2, 'c2, 'j2, 'e2, 'f2) fmtty_rel\n\n  (* Printf and Format specific constructors. *)\n  | Alpha_ty :                                                (* %a  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (('b1 -> 'x -> 'c1) -> 'x -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       ('b2 -> 'x -> 'c2) -> 'x -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Theta_ty :                                                (* %t  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (('b1 -> 'c1) -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       ('b2 -> 'c2) -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Any_ty :                                                  (* Used for custom formats *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      ('x -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'x -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n\n  (* Scanf specific constructor. *)\n  | Reader_ty :                                               (* %r  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      ('x -> 'a1, 'b1, 'c1, ('b1 -> 'x) -> 'd1, 'e1, 'f1,\n       'x -> 'a2, 'b2, 'c2, ('b2 -> 'x) -> 'd2, 'e2, 'f2) fmtty_rel\n  | Ignored_reader_ty :                                       (* %_r  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      ('a1, 'b1, 'c1, ('b1 -> 'x) -> 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, ('b2 -> 'x) -> 'd2, 'e2, 'f2) fmtty_rel\n\n  | End_of_fmtty :\n      ('f1, 'b1, 'c1, 'd1, 'd1, 'f1,\n       'f2, 'b2, 'c2, 'd2, 'd2, 'f2) fmtty_rel\n\n(***)\n\n(* List of format elements. *)\nand ('a, 'b, 'c, 'd, 'e, 'f) fmt =\n  | Char :                                                   (* %c *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (char -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Caml_char :                                              (* %C *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (char -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | String :                                                 (* %s *)\n      ('x, string -> 'a) padding * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Caml_string :                                            (* %S *)\n      ('x, string -> 'a) padding * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Int :                                                    (* %[dixXuo] *)\n      int_conv * ('x, 'y) padding * ('y, int -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Int32 :                                                  (* %l[dixXuo] *)\n      int_conv * ('x, 'y) padding * ('y, int32 -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Nativeint :                                              (* %n[dixXuo] *)\n      int_conv * ('x, 'y) padding * ('y, nativeint -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Int64 :                                                  (* %L[dixXuo] *)\n      int_conv * ('x, 'y) padding * ('y, int64 -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Float :                                                  (* %[feEgGF] *)\n      float_conv * ('x, 'y) padding * ('y, float -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Bool :                                                   (* %[bB] *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (bool -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Flush :                                                  (* %! *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n\n  | String_literal :                                         (* abc *)\n      string * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Char_literal :                                           (* x *)\n      char * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n\n  | Format_arg :                                             (* %{...%} *)\n      pad_option * ('g, 'h, 'i, 'j, 'k, 'l) fmtty *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Format_subst :                                           (* %(...%) *)\n      pad_option *\n      ('g, 'h, 'i, 'j, 'k, 'l,\n       'g2, 'b, 'c, 'j2, 'd, 'a) fmtty_rel *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n      (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g2, 'b, 'c, 'j2, 'e, 'f) fmt\n\n  (* Printf and Format specific constructor. *)\n  | Alpha :                                                  (* %a *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (('b -> 'x -> 'c) -> 'x -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Theta :                                                  (* %t *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (('b -> 'c) -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n\n  (* Format specific constructor: *)\n  | Formatting_lit :                                         (* @_ *)\n      formatting_lit * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Formatting_gen :                                             (* @_ *)\n      ('a1, 'b, 'c, 'd1, 'e1, 'f1) formatting_gen *\n      ('f1, 'b, 'c, 'e1, 'e2, 'f2) fmt -> ('a1, 'b, 'c, 'd1, 'e2, 'f2) fmt\n\n  (* Scanf specific constructors: *)\n  | Reader :                                                 (* %r *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x -> 'a, 'b, 'c, ('b -> 'x) -> 'd, 'e, 'f) fmt\n  | Scan_char_set :                                          (* %[...] *)\n      pad_option * char_set * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (string -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Scan_get_counter :                                       (* %[nlNL] *)\n      counter * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (int -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Scan_next_char :                                         (* %0c *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n      (char -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Ignored_param :                                          (* %_ *)\n      ('a, 'b, 'c, 'd, 'y, 'x) ignored * ('x, 'b, 'c, 'y, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n\n  (* Custom printing format (PR#6452, GPR#140)\n\n     We include a type Custom of \"custom converters\", where an\n     arbitrary function can be used to convert one or more\n     arguments. There is no syntax for custom converters, it is only\n     inteded for custom processors that wish to rely on the\n     stdlib-defined format GADTs.\n\n     For instance a pre-processor could choose to interpret strings\n     prefixed with [\"!\"] as format strings where [%{{ ... }}] is\n     a special form to pass a to_string function, so that one could\n     write:\n\n     {[\n       type t = { x : int; y : int }\n\n       let string_of_t t = Printf.sprintf \"{ x = %d; y = %d }\" t.x t.y\n\n       Printf.printf !\"t = %{{string_of_t}}\" { x = 42; y = 42 }\n     ]}\n  *)\n  | Custom :\n      ('a, 'x, 'y) custom_arity * (unit -> 'x) * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n      ('y, 'b, 'c, 'd, 'e, 'f) fmt\n\n  (* end of a format specification *)\n  | End_of_format :\n        ('f, 'b, 'c, 'e, 'e, 'f) fmt\n\n(***)\n\n(* Type for ignored parameters (see \"%_\"). *)\nand ('a, 'b, 'c, 'd, 'e, 'f) ignored =\n  | Ignored_char :                                           (* %_c *)\n      ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_caml_char :                                      (* %_C *)\n      ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_string :                                         (* %_s *)\n      pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_caml_string :                                    (* %_S *)\n      pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_int :                                            (* %_d *)\n      int_conv * pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_int32 :                                          (* %_ld *)\n      int_conv * pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_nativeint :                                      (* %_nd *)\n      int_conv * pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_int64 :                                          (* %_Ld *)\n      int_conv * pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_float :                                          (* %_f *)\n      pad_option * prec_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_bool :                                           (* %_B *)\n      ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_format_arg :                                     (* %_{...%} *)\n      pad_option * ('g, 'h, 'i, 'j, 'k, 'l) fmtty ->\n        ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_format_subst :                                   (* %_(...%) *)\n      pad_option * ('a, 'b, 'c, 'd, 'e, 'f) fmtty ->\n        ('a, 'b, 'c, 'd, 'e, 'f) ignored\n  | Ignored_reader :                                         (* %_r *)\n      ('a, 'b, 'c, ('b -> 'x) -> 'd, 'd, 'a) ignored\n  | Ignored_scan_char_set :                                  (* %_[...] *)\n      pad_option * char_set -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_scan_get_counter :                               (* %_[nlNL] *)\n      counter -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_scan_next_char :                                 (* %_0c *)\n      ('a, 'b, 'c, 'd, 'd, 'a) ignored\n\nand ('a, 'b, 'c, 'd, 'e, 'f) format6 =\n  Format of ('a, 'b, 'c, 'd, 'e, 'f) fmt * string\n\nlet rec erase_rel : type a b c d e f g h i j k l .\n  (a, b, c, d, e, f,\n   g, h, i, j, k, l) fmtty_rel -> (a, b, c, d, e, f) fmtty\n= function\n  | Char_ty rest ->\n    Char_ty (erase_rel rest)\n  | String_ty rest ->\n    String_ty (erase_rel rest)\n  | Int_ty rest ->\n    Int_ty (erase_rel rest)\n  | Int32_ty rest ->\n    Int32_ty (erase_rel rest)\n  | Int64_ty rest ->\n    Int64_ty (erase_rel rest)\n  | Nativeint_ty rest ->\n    Nativeint_ty (erase_rel rest)\n  | Float_ty rest ->\n    Float_ty (erase_rel rest)\n  | Bool_ty rest ->\n    Bool_ty (erase_rel rest)\n  | Format_arg_ty (ty, rest) ->\n    Format_arg_ty (ty, erase_rel rest)\n  | Format_subst_ty (ty1, ty2, rest) ->\n    Format_subst_ty (ty1, ty1, erase_rel rest)\n  | Alpha_ty rest ->\n    Alpha_ty (erase_rel rest)\n  | Theta_ty rest ->\n    Theta_ty (erase_rel rest)\n  | Any_ty rest ->\n    Any_ty (erase_rel rest)\n  | Reader_ty rest ->\n    Reader_ty (erase_rel rest)\n  | Ignored_reader_ty rest ->\n    Ignored_reader_ty (erase_rel rest)\n  | End_of_fmtty -> End_of_fmtty\n\n(******************************************************************************)\n                         (* Format type concatenation *)\n\n(* Concatenate two format types. *)\n(* Used by:\n   * reader_nb_unifier_of_fmtty to count readers in an fmtty,\n   * Scanf.take_fmtty_format_readers to extract readers inside %(...%),\n   * CamlinternalFormat.fmtty_of_ignored_format to extract format type. *)\n\n(*\nlet rec concat_fmtty : type a b c d e f g h .\n    (a, b, c, d, e, f) fmtty ->\n    (f, b, c, e, g, h) fmtty ->\n    (a, b, c, d, g, h) fmtty =\n*)\nlet rec concat_fmtty :\n  type a1 b1 c1 d1 e1 f1\n       a2 b2 c2 d2 e2 f2\n       g1 j1 g2 j2\n  .\n    (g1, b1, c1, j1, d1, a1,\n     g2, b2, c2, j2, d2, a2) fmtty_rel ->\n    (a1, b1, c1, d1, e1, f1,\n     a2, b2, c2, d2, e2, f2) fmtty_rel ->\n    (g1, b1, c1, j1, e1, f1,\n     g2, b2, c2, j2, e2, f2) fmtty_rel =\nfun fmtty1 fmtty2 -> match fmtty1 with\n  | Char_ty rest ->\n    Char_ty (concat_fmtty rest fmtty2)\n  | String_ty rest ->\n    String_ty (concat_fmtty rest fmtty2)\n  | Int_ty rest ->\n    Int_ty (concat_fmtty rest fmtty2)\n  | Int32_ty rest ->\n    Int32_ty (concat_fmtty rest fmtty2)\n  | Nativeint_ty rest ->\n    Nativeint_ty (concat_fmtty rest fmtty2)\n  | Int64_ty rest ->\n    Int64_ty (concat_fmtty rest fmtty2)\n  | Float_ty rest ->\n    Float_ty (concat_fmtty rest fmtty2)\n  | Bool_ty rest ->\n    Bool_ty (concat_fmtty rest fmtty2)\n  | Alpha_ty rest ->\n    Alpha_ty (concat_fmtty rest fmtty2)\n  | Theta_ty rest ->\n    Theta_ty (concat_fmtty rest fmtty2)\n  | Any_ty rest ->\n    Any_ty (concat_fmtty rest fmtty2)\n  | Reader_ty rest ->\n    Reader_ty (concat_fmtty rest fmtty2)\n  | Ignored_reader_ty rest ->\n    Ignored_reader_ty (concat_fmtty rest fmtty2)\n  | Format_arg_ty (ty, rest) ->\n    Format_arg_ty (ty, concat_fmtty rest fmtty2)\n  | Format_subst_ty (ty1, ty2, rest) ->\n    Format_subst_ty (ty1, ty2, concat_fmtty rest fmtty2)\n  | End_of_fmtty -> fmtty2\n\n(******************************************************************************)\n                           (* Format concatenation *)\n\n(* Concatenate two formats. *)\nlet rec concat_fmt : type a b c d e f g h .\n    (a, b, c, d, e, f) fmt ->\n    (f, b, c, e, g, h) fmt ->\n    (a, b, c, d, g, h) fmt =\nfun fmt1 fmt2 -> match fmt1 with\n  | String (pad, rest) ->\n    String (pad, concat_fmt rest fmt2)\n  | Caml_string (pad, rest) ->\n    Caml_string (pad, concat_fmt rest fmt2)\n\n  | Int (iconv, pad, prec, rest) ->\n    Int (iconv, pad, prec, concat_fmt rest fmt2)\n  | Int32 (iconv, pad, prec, rest) ->\n    Int32 (iconv, pad, prec, concat_fmt rest fmt2)\n  | Nativeint (iconv, pad, prec, rest) ->\n    Nativeint (iconv, pad, prec, concat_fmt rest fmt2)\n  | Int64 (iconv, pad, prec, rest) ->\n    Int64 (iconv, pad, prec, concat_fmt rest fmt2)\n  | Float (fconv, pad, prec, rest) ->\n    Float (fconv, pad, prec, concat_fmt rest fmt2)\n\n  | Char (rest) ->\n    Char (concat_fmt rest fmt2)\n  | Caml_char rest ->\n    Caml_char (concat_fmt rest fmt2)\n  | Bool rest ->\n    Bool (concat_fmt rest fmt2)\n  | Alpha rest ->\n    Alpha (concat_fmt rest fmt2)\n  | Theta rest ->\n    Theta (concat_fmt rest fmt2)\n  | Custom (arity, f, rest) ->\n    Custom (arity, f, concat_fmt rest fmt2)\n  | Reader rest ->\n    Reader (concat_fmt rest fmt2)\n  | Flush rest ->\n    Flush (concat_fmt rest fmt2)\n\n  | String_literal (str, rest) ->\n    String_literal (str, concat_fmt rest fmt2)\n  | Char_literal (chr, rest) ->\n    Char_literal   (chr, concat_fmt rest fmt2)\n\n  | Format_arg (pad, fmtty, rest) ->\n    Format_arg   (pad, fmtty, concat_fmt rest fmt2)\n  | Format_subst (pad, fmtty, rest) ->\n    Format_subst (pad, fmtty, concat_fmt rest fmt2)\n\n  | Scan_char_set (width_opt, char_set, rest) ->\n    Scan_char_set (width_opt, char_set, concat_fmt rest fmt2)\n  | Scan_get_counter (counter, rest) ->\n    Scan_get_counter (counter, concat_fmt rest fmt2)\n  | Scan_next_char (rest) ->\n    Scan_next_char (concat_fmt rest fmt2)\n  | Ignored_param (ign, rest) ->\n    Ignored_param (ign, concat_fmt rest fmt2)\n\n  | Formatting_lit (fmting_lit, rest) ->\n    Formatting_lit (fmting_lit, concat_fmt rest fmt2)\n  | Formatting_gen (fmting_gen, rest) ->\n    Formatting_gen (fmting_gen, concat_fmt rest fmt2)\n\n  | End_of_format ->\n    fmt2\n",
  "let module Bindings_utils = {\n  open Helpers;\n  let require_module s =>\n    Js.Unsafe.fun_call (Js.Unsafe.js_expr \"require\") [|Js.Unsafe.inject (Js.string s)|];\n\n  /** Same as console.log */\n  let log obj => Firebug.console##log obj;\n\n  /** Call method of a JavaScript object */\n  let m = Js.Unsafe.meth_call;\n\n  /** Inject something as a JS object, be sure its Js.t already,\n      functions seemingly exempt */\n  let i = Js.Unsafe.inject;\n\n  /** Turn a JavaScript Object into a string */\n  let stringify o => Js._JSON##stringify o |> Js.to_string;\n\n  /** Turn an OCaml string into a JavaScript string */\n  let to_js_str s => Js.string s |> Js.Unsafe.inject;\n\n  /** Turn a string into a JSON object */\n  let json_of_string s => Js._JSON##parse (s |> Js.string);\n\n  /** Create a JavaScript Object out of an alist */\n  let obj_of_alist a_l =>\n    List.map (fun (key, value) => (key, Js.Unsafe.inject value)) a_l |> Array.of_list |> Js.Unsafe.obj;\n\n  /** Turn JavaScript string array into OCaml list of string */\n  let to_string_list g =>\n    g |> Js.str_array |> Js.to_array |> Array.map Js.to_string |> Array.to_list;\n\n  /** Turn OCaml list of strings into JavaScript string array */\n  let of_string_list g => g |> Array.of_list |> Array.map Js.string |> Js.array;\n\n  /** Get all keys of an Object */\n  let keys obj =>\n    m (Js.Unsafe.variable \"Object\") \"keys\" [|obj|] |> Js.to_array |> Array.map Js.to_string |> Array.to_list;\n\n  /** Call a function for each value of each key in an Object, throw\n      away result */\n  let for_each_iter f::f obj => keys obj |> List.iter (fun k => f (Js.Unsafe.get obj k));\n\n  /** Call a function for each value of each key in an Object, keep\n      result */\n  let for_each_map f::f obj => keys obj |> List.map (fun k => f k (Js.Unsafe.get obj k));\n  let debug thing field => Firebug.console##log (m (thing <!> field) \"toString\" [||]);\n  type error_arg = Js.opt Js.error;\n  let __filename () :Js.t Js.js_string => Js.Unsafe.eval_string \"__filename\";\n  let __dirname () :Js.t Js.js_string => Js.Unsafe.eval_string \"__dirname\";\n  let (|>>) = Js.Unsafe.fun_call;\n  let putStr a => Js.Unsafe.inject (Js.string a);\n};\n",
  "/*\n * vim: set ft=rust:\n * vim: set ft=reason:\n */\nmodule type T = {let pixi: 'a;};\n\nlet module Init (M: T) => {\n  open Js.Unsafe;\n\n  let module Console = {\n    /* Log level 0 - 1 - 2  <=> Debug - Info - Important */\n    let logLevel = ref 0;\n    let log str => ignore @@ meth_call Firebug.console \"log\" [|inject (Js.string str)|];\n    let unsafelog e => ignore @@ meth_call Firebug.console \"log\" [|e|];\n    let debug str =>\n      if (!logLevel == 0) {\n        ignore @@ meth_call Firebug.console \"debug\" [|inject (Js.string str)|]\n      };\n    let unsafedebug e =>\n      if (!logLevel == 0) {\n        ignore @@ meth_call Firebug.console \"debug\" [|e|]\n      };\n  };\n\n  let pi = 3.14159265358979312;\n  /* Hack to get around the fact that PIXI might not be defined. */\n  let pixi = M.pixi;\n  /* Console.log pixi; */\n  let module Events = {\n    type mouseEventT =\n      | MouseDown\n      | MouseUp\n      | MouseUpOutside\n      | MouseOver\n      | MouseOut\n      | TouchStart\n      | TouchEnd\n      | TouchEndOutside;\n    type keyboardEventT =\n      | KeyDown\n      | KeyUp\n      | KeyPress;\n    type mouseOrKeyboard =\n      | Mouse mouseEventT\n      | Keyboard keyboardEventT;\n    let stringForEventType evtType =>\n      switch evtType {\n      | Mouse e =>\n        switch e {\n        | MouseDown => \"mousedown\"\n        | MouseUp => \"mouseup\"\n        | MouseUpOutside => \"mouseupoutside\"\n        | MouseOver => \"mouseover\"\n        | MouseOut => \"mouseout\"\n        | TouchStart => \"touchstart\"\n        | TouchEnd => \"touchend\"\n        | TouchEndOutside => \"touchendoutside\"\n        }\n      | Keyboard e =>\n        switch e {\n        | KeyDown => \"keydown\"\n        | KeyUp => \"keyup\"\n        | KeyPress => \"keypress\"\n        }\n      };\n    let onMouse (element: any) (evt: mouseEventT) (cb: any => unit) =>\n      ignore @@\n      meth_call\n        element\n        \"on\"\n        [|inject (Js.string (stringForEventType (Mouse evt))), inject (Js.wrap_meth_callback cb)|];\n    let onKeyboard (evt: keyboardEventT) (cb: any => unit) =>\n      ignore @@\n      meth_call\n        (variable \"window\")\n        \"addEventListener\"\n        [|inject (Js.string (stringForEventType (Keyboard evt))), inject (Js.wrap_callback cb)|];\n  };\n  let module Renderable = {\n    class virtual t = {\n      as self;\n      method virtual raw: any;\n      method setAnchor (x: float, y: float) =>\n        ignore @@\n        meth_call\n          (get self#raw \"anchor\")\n          \"set\"\n          [|inject (Js.number_of_float x), inject (Js.number_of_float y)|];\n      method position: (int, int) = {\n        let p = get self#raw \"position\";\n        let x = get p \"x\";\n        let y = get p \"y\";\n        /* Check JSOO docs again to see if you really have to wrap ints and floats with\n         * Js.number_of_float/Js.float_of_number */\n        (x, y)\n      };\n      method setPosition (x: int, y: int) => {\n        let p = get self#raw \"position\";\n        set p \"x\" x;\n        set p \"y\" y\n      };\n      method positionf: (float, float) = {\n        let p = get self#raw \"position\";\n        let x = get p \"x\";\n        let y = get p \"y\";\n        (Js.float_of_number x, Js.float_of_number y)\n      };\n      method setPositionf (x: float, y: float) => {\n        let p = get self#raw \"position\";\n        set p \"x\" (Js.number_of_float x);\n        set p \"y\" (Js.number_of_float y)\n      };\n      method scale: (float, float) = {\n        let s = get self#raw \"scale\";\n        let x = get s \"x\";\n        let y = get s \"y\";\n        (Js.float_of_number x, Js.float_of_number y)\n      };\n      method setScale (x: float, y: float) =>\n        ignore @@\n        meth_call\n          (get self#raw \"scale\")\n          \"set\"\n          [|inject (Js.number_of_float x), inject (Js.number_of_float y)|];\n      method rotation: float = Js.float_of_number (get self#raw \"rotation\");\n      method setRotation (v: float) => set self#raw \"rotation\" (Js.number_of_float v);\n      method interactive: bool = get self#raw \"interactive\";\n      method setInteractive (i: bool) => set self#raw \"interactive\" i;\n    };\n  };\n  let module View = {\n    class t = {\n      as self;\n    };\n  };\n  let module Texture = {\n    class t (uri: string) => {\n      as self;\n      val _innerSelf: any = meth_call (get pixi \"Texture\") \"fromImage\" [|inject (Js.string uri)|];\n      method raw = _innerSelf;\n    };\n    let fromImage uri::uri => (new t) uri;\n  };\n  let module ScaleModes = {\n    type t =\n      | Linear\n      | Nearest;\n  };\n  let module Sprite = {\n    /* `texture` here isn't type checked properly.\n     * class bla = {\n     *   method raw = inject 10;\n     * }\n     * let a = new t (new bla)\n     *\n     * This would work ^ while not making any sense.\n     *\n     * We need to define a sum type over all possible Renderable texture.i\n     * This is a bit difficulte to do inside the same file, as `Container.t` needs `Sprite.t` to be defined\n     * and `RenderTexture.t` needs `Container.t` to be defined.\n     * */\n    class t texture => {\n      as self;\n      inherit class Renderable.t;\n      val _innerSelf: any = new_obj (get pixi \"Sprite\") [|texture#raw|];\n      method raw = _innerSelf;\n      method width: int = get _innerSelf \"width\";\n      method height: int = get _innerSelf \"height\";\n      method setWidth (v: int) => set _innerSelf \"width\" v;\n      method setHeight (v: int) => set _innerSelf \"height\" v;\n      method buttonMode: bool = get _innerSelf \"buttonMode\";\n      method setButtonMode (b: bool) => ignore @@ set _innerSelf \"buttonMode\" b;\n      method setTap (f: unit => unit) => set _innerSelf \"tap\" f;\n      method setClick (f: unit => unit) => set _innerSelf \"click\" f;\n      method isDown = Js.to_bool (get _innerSelf \"isDown\");\n      method setIsDown (i: bool) => set _innerSelf \"isDown\" i;\n      method setAlpha (a: float) => set _innerSelf \"alpha\" a;\n      method setTexture (t: Texture.t) => set _innerSelf \"texture\" t#raw;\n      method isOver = Js.to_bool (get _innerSelf \"isOver\");\n      method setIsOver (i: bool) => set _innerSelf \"isOver\" i;\n      method on evt (cb: t => unit) => {\n        /* This is a \"hack\" to get the compiler to accept that the function innerCb is referencing\n         * the class itself.\n         * Look at http://caml.inria.fr/pub/docs/manual-ocaml/objectexamples.html#ss%3Ausing-coercions\n         * and look for the example `class c = object (self) method m = (self :> c) end;;` which\n         * is explained to be a special case for the compiler.*/\n        let innerCb _ => cb (self :> t);\n        Events.onMouse _innerSelf evt innerCb\n      };\n    };\n    let fromImage uri::uri => (new t) (Texture.fromImage uri::uri);\n  };\n  let module Spine = {\n    type spineT = {spineData: any};\n    class t (spineData: spineT) => {\n      as self;\n      inherit class Renderable.t;\n      val _innerSelf = new_obj (get (get pixi \"spine\") \"Spine\") [|spineData.spineData|];\n      method raw = _innerSelf;\n      /* No `too` isn't a typo, `to` is a keyword. */\n      method setMixByName from::(from: string) too::(too: string) duration::(duration: float) =>\n        ignore @@\n        meth_call\n          (get _innerSelf \"stateData\")\n          \"setMixByName\"\n          [|inject (Js.string from), inject (Js.string too), inject (Js.number_of_float duration)|];\n      method setAnimationByName\n             startTime::(startTime: int)\n             animName::(animName: string)\n             loop::(loop: bool) =>\n        ignore @@\n        meth_call\n          (get _innerSelf \"state\")\n          \"setAnimationByName\"\n          [|inject startTime, inject (Js.string animName), inject (Js.bool loop)|];\n      method addAnimationByName\n             startTime::(startTime: int)\n             animName::animName\n             loop::(loop: bool)\n             randomInt::(randomInt: int) =>\n        ignore @@\n        meth_call\n          (get _innerSelf \"state\")\n          \"addAnimationByName\"\n          [|\n            inject startTime,\n            inject (Js.string animName),\n            inject (Js.bool loop),\n            inject randomInt\n          |];\n    };\n  };\n  let module Container = {\n    class t = {\n      as self;\n      inherit class Renderable.t;\n      val _innerSelf: any = new_obj (get pixi \"Container\") [||];\n      method raw = _innerSelf;\n      method addChild (child: Sprite.t) => ignore @@ meth_call self#raw \"addChild\" [|child#raw|];\n      method addChildContainer (child: t) =>\n        ignore @@ meth_call _innerSelf \"addChild\" [|(child :> t)#raw|];\n      method addChildSpine (child: Spine.t) =>\n        ignore @@ meth_call _innerSelf \"addChild\" [|child#raw|];\n      method on evt (cb: t => unit) => {\n        /* This is a \"hack\" to get the compiler to accept that the function innerCb is referencing\n         * the class itself.\n         * Look at http://caml.inria.fr/pub/docs/manual-ocaml/objectexamples.html#ss%3Ausing-coercions\n         * and look for the example `class c = object (self) method m = (self :> c) end;;` which\n         * is explained to be a special case for the compiler.*/\n        let innerCb _ => cb (self :> t);\n        Events.onMouse self#raw evt innerCb\n      };\n    };\n  };\n  let module RenderTexture = {\n    class t\n          scaleModes::scaleModes=ScaleModes.Linear\n          sampleRatio::sampleRatio=1.0\n          (width: int)\n          (height: int) => {\n      as self;\n      val _innerSelf: any =\n        meth_call\n          (get pixi \"RenderTexture\")\n          \"create\"\n          /* Totally relying on ScaleModes.Linear's serialization mechanism (integers starting from 0 in\n           * declaration order) */\n          [|\n            inject width,\n            inject height,\n            inject scaleModes,\n            inject (Js.number_of_float sampleRatio)\n          |];\n      method raw = _innerSelf;\n      method render (c: Container.t) => ignore @@ meth_call _innerSelf \"render\" [|c#raw|];\n    };\n  };\n  let module Renderer = {\n    type paramT = {backgroundColor: int};\n    let paramToAny param => {\n      let p = new_obj (variable \"Object\") [||];\n      set p \"backgroundColor\" param.backgroundColor;\n      p\n    };\n    class t param::(param: option paramT)=? (width: int) (height: int) (renderedStr: string) => {\n      as self;\n      val _innerSelf: any =\n        switch param {\n        | None => new_obj (get pixi renderedStr) [|inject width, inject height|]\n        | Some param =>\n          new_obj (get pixi renderedStr) [|inject width, inject height, paramToAny param|]\n        };\n      method raw = _innerSelf;\n      method width: int = get _innerSelf \"width\";\n      method height: int = get _innerSelf \"height\";\n      method view: View.t = get _innerSelf \"view\";\n      method render renderTexture::(renderTexture: option RenderTexture.t)=? (stage: Container.t) =>\n        ignore @@\n        meth_call\n          _innerSelf\n          \"render\"\n          (\n            switch renderTexture {\n            | None => [|stage#raw|]\n            | Some rt => [|stage#raw, rt#raw|]\n            }\n          );\n      method renderToTexture (container: Container.t) (renderTexture: RenderTexture.t) =>\n        ignore @@ meth_call _innerSelf \"render\" [|container#raw, renderTexture#raw|];\n      method renderToSprite (renderTexture: RenderTexture.t) (sprite: Sprite.t) =>\n        ignore @@ meth_call _innerSelf \"render\" [|sprite#raw, renderTexture#raw|];\n    };\n  };\n  let module Loader = {\n    class t prevInner::(prevInner: option any)=? (name: string) (uri: string) => {\n      as self;\n      val _innerSelf: any =\n        meth_call\n          (\n            switch prevInner {\n            | None => get pixi \"loader\"\n            | Some prevInner => prevInner\n            }\n          )\n          \"add\"\n          [|inject (Js.string name), inject (Js.string uri)|];\n      method load (cb: t => Spine.spineT => unit) => {\n        /* hack again... Now we're using `name` inside res to get the data itself...\n         * I need to figure out what the best way to convert the \"chain\" paradigm that looks like\n         * `obj.add().add().add().load()` where `load` changes the state of the whole thing\n         * such that whenever any `add` is ready, it'll call the cb given to `load`.\n         * I'm not sure that paradigm makes any sense here in OCaml.\n         * Right now `add` returns a new Loader with a `prevInner` making a new instance of the class\n         * by calling the `add` JS function on `prevInner` instead of `get pixi \"loader\"`*/\n        let innerCb loader res => {\n          let data = get res name;\n          cb (self :> t) {spineData: get data \"spineData\"}\n        };\n        ignore @@ meth_call _innerSelf \"load\" [|inject (Js.wrap_callback innerCb)|]\n      };\n      method add name::name uri::uri => (new t) prevInner::_innerSelf name uri;\n    };\n    let add name::name uri::uri => (new t) name uri;\n  };\n  let module Dom = {\n    let appendToBody (child: View.t) =>\n      ignore @@ meth_call (get Dom_html.document \"body\") \"appendChild\" [|inject child|];\n  };\n  let autoDetectRenderer width::width height::height =>\n    (new Renderer.t) width height \"autoDetectRenderer\";\n  let autoDetectRendererWithParam param::param width::width height::height =>\n    (new Renderer.t) param::param width height \"autoDetectRenderer\";\n  let requestAnimationFrame (cb: float => unit) =>\n    ignore @@ meth_call Dom_html.window \"requestAnimationFrame\" [|inject (Js.wrap_callback cb)|];\n};\n",
  "let (!@) f => Js.wrap_callback f;\n\nlet (!!) o => Js.Unsafe.inject o;\n\n\n/** Get the field of a JavaScript Object */\nlet (<!>) obj field => Js.Unsafe.get obj field;\n\nlet (|>>) = Js.Unsafe.fun_call;\n\nlet putStr a => Js.Unsafe.inject (Js.string a);\n",
  "open Js.Unsafe;\n\nopen Helpers;\n\ntype actionT 'a = {\n  typ: string,\n  packet: 'a,\n};\ntype ioT;\n\nlet start () : ioT => Js.Unsafe.fun_call (Js.Unsafe.js_expr \"io\") [||];\n\nlet on (io : ioT) (cb : actionT 'a => unit) => ignore @@ meth_call io \"on\" [|putStr \"action\", !! !@cb|];\n\nlet emit (io : ioT) (data : actionT 'a) => ignore @@ meth_call io \"emit\" [|putStr \"action\", !!data|];\n",
  "let module Node = Nodejs.Bindings_utils;\n\nopen Js.Unsafe;\n\nopen Helpers;\n\ntype posT = {x: int, y: int};\n\ntype screenCoordT =\n  | ScreenCoord posT;\n\ntype gameCoordT =\n  | GameCoord posT;\n\ntype dudeT = {mutable pos: gameCoordT, mutable health: int, id: string};\n\nlet getGameCoord (ScreenCoord cord) => GameCoord {x: cord.x / 200, y: cord.y / 200};\n\nlet updateDude {pos: GameCoord {x, y}} sprite => sprite#setPosition (x * 200, y * 200);\n\nlet start () => {\n  let module M = {\n    let pixi = Js.Unsafe.js_expr \"PIXI\";\n  };\n  /* Module alias is 10/10 better than open */\n  let module R = Repixi.Repixi.Init M;\n  let getTileAt (grid: list R.Sprite.t) (GameCoord cord) => List.nth grid (cord.x * 8 + cord.y);\n  let createDudeSprite dude => {\n    let dudeTexture = R.Texture.fromImage uri::\"sprites/knight.gif\";\n    let sprite = (new R.Sprite.t) dudeTexture;\n    sprite#setButtonMode true;\n    let GameCoord {x, y} = dude.pos;\n    sprite#setPosition (x * 200, y * 200);\n    sprite#setInteractive true;\n    sprite\n    /* tile#on MouseDown onButtonDown;\n       tile#on TouchStart onButtonDown;\n       tile#on MouseUp onButtonUp;\n       tile#on TouchEnd onButtonUp;\n       tile#on MouseUpOutside onButtonUp;\n       tile#on TouchEndOutside onButtonUp; */\n  };\n  let io = Clientsocket.start ();\n  let width = Js.Unsafe.get (Js.Unsafe.js_expr \"window\") \"innerWidth\";\n  let height = Js.Unsafe.get (Js.Unsafe.js_expr \"window\") \"innerHeight\";\n  Node.log width;\n  Node.log height;\n  let renderer = R.autoDetectRenderer width::width height::height;\n  Js.Unsafe.set renderer#raw \"backgroundColor\" \"0xFFFFFF\";\n  R.Dom.appendToBody renderer#view;\n  let stage = new R.Container.t;\n  let scale = 200. *. 5. /. (min (width +. 60.) height);\n  stage#setScale (scale, scale);\n  /* let background = R.Sprite.fromImage uri::\"_assets/button_test_BG.jpg\";\n     background#setWidth renderer#width;\n     background#setHeight renderer#height;\n     stage#addChild background; */\n  let textureButton = R.Texture.fromImage uri::\"sprites/bg.gif\";\n  let dude = {pos: GameCoord {x: 2, y: 2}, id: \"kek-lord\", health: 100};\n  let dudeSprite = createDudeSprite dude;\n  let gridCells = ref [];\n  let otherDudes: ref (list dudeT) = ref [];\n  let otherDudesSprites: ref (list R.Sprite.t) = ref [];\n  let onButtonDown this => {\n    let x: int = Js.Unsafe.get this#raw \"x\" / 200;\n    let y: int = Js.Unsafe.get this#raw \"y\" / 200;\n    /* If tile contains monster, something else happens */\n    let (centerX, centerY) = (2, 2);\n    let GameCoord {x: dudeX, y: dudeY} = dude.pos;\n    let (dx, dy) = (x - centerX, y - centerY);\n    if (abs dx > abs dy) {\n      if (dx > 0) {\n        dude.pos = GameCoord {x: dudeX + 1, y: dudeY}\n      } else {\n        dude.pos = GameCoord {x: dudeX - 1, y: dudeY}\n      }\n    } else if (\n      abs dy > abs dx\n    ) {\n      if (dy > 0) {\n        dude.pos = GameCoord {x: dudeX, y: dudeY + 1}\n      } else {\n        dude.pos = GameCoord {x: dudeX, y: dudeY - 1}\n      }\n    } else if\n      /* We go along the y axis because... fuck */\n      (dy > 0) {\n      dude.pos = GameCoord {x: dudeX, y: dudeY + 1}\n    } else {\n      dude.pos = GameCoord {x: dudeX, y: dudeY - 1}\n    };\n    Clientsocket.emit io {typ: \"move\", packet: dude}\n  };\n  let everythingElseStage = new R.Container.t;\n  R.Events.(\n    for i in 0 to 4 {\n      for j in 0 to 4 {\n        let tile = (new R.Sprite.t) textureButton;\n        tile#setButtonMode true;\n        tile#setPosition (i * 200, j * 200);\n        tile#setInteractive true;\n        tile#on MouseDown onButtonDown;\n        tile#on TouchStart onButtonDown;\n        stage#addChild tile;\n        gridCells := !gridCells @ [tile]\n      }\n    }\n  );\n  everythingElseStage#addChild dudeSprite;\n  stage#addChildContainer everythingElseStage;\n  Clientsocket.on\n    io\n    (\n      fun {typ, packet} =>\n        switch typ {\n        | \"move\" =>\n          print_endline \"I guess trying to move\";\n          let {id, pos}: dudeT = packet;\n          Node.log (List.nth !otherDudes 0).id;\n          let theDude = List.find (fun value => value.id == id) !otherDudes;\n          theDude.pos = pos;\n        | \"new-dude-arrived\" =>\n          let dude: dudeT = packet;\n          print_endline \"new-dude-arrived\";\n          otherDudes := !otherDudes @ [dude];\n          let dudeSprite = createDudeSprite dude;\n          otherDudesSprites := !otherDudesSprites @ [dudeSprite];\n          everythingElseStage#addChild dudeSprite\n        | _ => print_endline @@ \"unsupported \" ^ typ\n        }\n    );\n  let rec animate () => {\n    Dom_html._requestAnimationFrame (Js.wrap_callback animate);\n    updateDude dude dudeSprite;\n    let (dudeX, dudeY) = dudeSprite#position;\n    Js.Unsafe.set everythingElseStage#raw \"x\" (-dudeX + 400);\n    Js.Unsafe.set everythingElseStage#raw \"y\" (-dudeY + 400);\n    ignore @@ List.map2 (fun dude sprite => updateDude dude sprite) !otherDudes !otherDudesSprites;\n    renderer#render stage\n  };\n  animate ();\n  Clientsocket.emit io {typ: \"new-dude-arrived\", packet: dude}\n};\n",
  "/* Huge hack to prevent server side code to run in the client :) */\n\nlet isServer = Js.to_bool (Js.Unsafe.js_expr {|\n  (function(){return typeof require !== \"undefined\";})()\n|});\n\nif (isServer) {\n  Server.start ();\n} else {\n  Client.start ();\n}\n",
  "(***********************************************************************)\n(*                                                                     *)\n(*                                OCaml                                *)\n(*                                                                     *)\n(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)\n(*                                                                     *)\n(*  Copyright 1996 Institut National de Recherche en Informatique et   *)\n(*  en Automatique.  All rights reserved.  This file is distributed    *)\n(*  under the terms of the GNU Library General Public License, with    *)\n(*  the special exception on linking described in file ../LICENSE.     *)\n(*                                                                     *)\n(***********************************************************************)\n\n(* Ensure that [at_exit] functions are called at the end of every program *)\n\nlet _ = do_at_exit()\n"]}